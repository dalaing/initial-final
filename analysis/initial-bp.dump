In order, the following will be built (use -v for more details):
 - initial-bp-0.1.0.0 (lib:initial-bp-eval) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base-mul) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-print) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-term) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul-sig) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-sig) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul-print) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul-eval) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-print) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-eval) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul-print with Mul.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul-eval with Base.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type, Mul.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-print with Base.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-print with Base.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-eval with Base.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-eval with Base.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-base) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base-print) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base-mul-print) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base-eval) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base-mul-eval) +dump (first run)
 - initial-bp-0.1.0.0 (lib) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-mul) +dump (first run)
Configuring library 'initial-bp-term' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-print' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-eval' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-example-term-base' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-example-term-base-mul' for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-print' for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-eval' for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-example-term-base' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base' for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-term' for initial-bp-0.1.0.0..
Building library 'initial-bp-term' instantiated with Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[1 of 1] Compiling Interpret.Print  ( initial-bp-print/Interpret/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-print/build/initial-bp-print/Interpret/Print.o )
[1 of 1] Compiling Interpret.Eval   ( initial-bp-eval/Interpret/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-eval/build/initial-bp-eval/Interpret/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 101, types: 63, coercions: 0, joins: 1/2}

-- RHS size: {terms: 29, types: 34, coercions: 0, joins: 1/2}
mkEval :: forall tm. [EvalRule tm] -> tm -> tm
mkEval
  = \ (@ tm) (rules :: [EvalRule tm]) (eta :: tm) ->
      letrec {
        eval :: tm -> tm
        eval
          = \ (tm1 :: tm) ->
              joinrec {
                go :: [EvalRule tm] -> tm
                go (ds :: [EvalRule tm])
                  = case ds of {
                      [] -> tm1;
                      : y ys ->
                        case y of { EvalRule f ->
                        case f eval tm1 of {
                          Nothing -> jump go ys;
                          Just ipv -> eval ipv
                        }
                        }
                    }; } in
              jump go rules; } in
      eval eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-bp-0.1.0.0-inplace-initial-bp-eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Interpret.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepFun $krep $krep

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep2 :: [KindRep]
$krep2 = : $krep []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepTyConApp $tcMaybe $krep2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepFun $krep $krep3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepFun $krep1 $krep4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcEvalRule2 :: Addr#
$tcEvalRule2 = "EvalRule"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcEvalRule1 :: TrName
$tcEvalRule1 = TrNameS $tcEvalRule2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcEvalRule :: TyCon
$tcEvalRule
  = TyCon
      9472438337276186837##
      497777784813275738##
      $trModule
      $tcEvalRule1
      0#
      krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepTyConApp $tcEvalRule $krep2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'EvalRule1 :: KindRep
$tc'EvalRule1 = KindRepFun $krep5 $krep6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'EvalRule3 :: Addr#
$tc'EvalRule3 = "'EvalRule"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'EvalRule2 :: TrName
$tc'EvalRule2 = TrNameS $tc'EvalRule3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'EvalRule :: TyCon
$tc'EvalRule
  = TyCon
      334386987452718255##
      1365779866568676607##
      $trModule
      $tc'EvalRule2
      1#
      $tc'EvalRule1




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 112, types: 78, coercions: 0, joins: 1/2}

-- RHS size: {terms: 28, types: 38, coercions: 0, joins: 1/2}
mkPrint :: forall tm. [PrintRule tm] -> tm -> Maybe String
mkPrint
  = \ (@ tm) (rules :: [PrintRule tm]) (eta :: tm) ->
      letrec {
        pr :: tm -> Maybe String
        pr
          = \ (tm1 :: tm) ->
              joinrec {
                go :: [PrintRule tm] -> Maybe String
                go (ds :: [PrintRule tm])
                  = case ds of {
                      [] -> Nothing;
                      : y ys ->
                        case y of { PrintRule f ->
                        case f pr tm1 of wild2 {
                          Nothing -> jump go ys;
                          Just ipv -> wild2
                        }
                        }
                    }; } in
              jump go rules; } in
      pr eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-bp-0.1.0.0-inplace-initial-bp-print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Interpret.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcChar []

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1 :: [KindRep]
$krep1 = : $krep []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepTyConApp $tc[] $krep1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep3 :: [KindRep]
$krep3 = : $krep2 []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepTyConApp $tcMaybe $krep3

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepFun $krep5 $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7 :: KindRep
$krep7 = KindRepFun $krep6 $krep6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcPrintRule2 :: Addr#
$tcPrintRule2 = "PrintRule"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcPrintRule1 :: TrName
$tcPrintRule1 = TrNameS $tcPrintRule2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcPrintRule :: TyCon
$tcPrintRule
  = TyCon
      17714313620178505416##
      17504649792137627185##
      $trModule
      $tcPrintRule1
      0#
      krep$*Arr*

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep8 :: [KindRep]
$krep8 = : $krep5 []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9 :: KindRep
$krep9 = KindRepTyConApp $tcPrintRule $krep8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule1 :: KindRep
$tc'PrintRule1 = KindRepFun $krep7 $krep9

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule3 :: Addr#
$tc'PrintRule3 = "'PrintRule"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule2 :: TrName
$tc'PrintRule2 = TrNameS $tc'PrintRule3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule :: TyCon
$tc'PrintRule
  = TyCon
      3231236959102998075##
      13503017589867352638##
      $trModule
      $tc'PrintRule2
      1#
      $tc'PrintRule1



[1 of 1] Compiling Term.Type[sig]   ( initial-bp-term/Term/Type.hsig, nothing )
[1 of 2] Compiling Term.Type        ( initial-bp-example-term-base/Term/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base/build/initial-bp-example-term-base/Term/Type.o )
Preprocessing library 'initial-bp-example-term-base-mul' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base-mul' for initial-bp-0.1.0.0..
[1 of 3] Compiling Term.Type        ( initial-bp-example-term-base-mul/Term/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-mul/build/initial-bp-example-term-base-mul/Term/Type.o )

==================== Simplified expression ====================
makePrisms
  (mkNameG_tc
     (unpackCString#
        "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base"#)
     (unpackCString# "Term.Type"#)
     (unpackCString# "Term"#))


Configuring library 'initial-bp-mul-sig' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base-sig' for initial-bp-0.1.0.0..

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 451, types: 403, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Addr#
lvl = "Add "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1 :: Addr#
lvl1 = "Lit "#

Rec {
-- RHS size: {terms: 79, types: 41, coercions: 0, joins: 0/0}
$w$cshowsPrec :: Int# -> Term -> String -> String
$w$cshowsPrec
  = \ (ww :: Int#) (w :: Term) (w1 :: String) ->
      case w of {
        Lit b1 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl1
                (case b1 of { I# ww3 ->
                 case $wshowSignedInt 11# ww3 w1 of { (# ww5, ww6 #) -> : ww5 ww6 }
                 });
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl1
                   (case b1 of { I# ww3 ->
                    case $wshowSignedInt 11# ww3 (: $fShow(,)2 w1) of
                    { (# ww5, ww6 #) ->
                    : ww5 ww6
                    }
                    }))
          };
        Add b1 b2 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl
                ($w$cshowsPrec 11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 w1)));
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl
                   ($w$cshowsPrec
                      11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 (: $fShow(,)2 w1)))))
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
$fShowTerm_$cshowsPrec :: Int -> Term -> ShowS
$fShowTerm_$cshowsPrec
  = \ (w :: Int) (w1 :: Term) (w2 :: String) ->
      case w of { I# ww1 -> $w$cshowsPrec ww1 w1 w2 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTerm2 :: Int
$fShowTerm2 = I# 0#

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$fShowTerm_$cshow :: Term -> String
$fShowTerm_$cshow = \ (x :: Term) -> $w$cshowsPrec 0# x []

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
$fShowTerm1 :: Term -> ShowS
$fShowTerm1 = \ (w :: Term) (w1 :: String) -> $w$cshowsPrec 0# w w1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$fShowTerm_$cshowList :: [Term] -> ShowS
$fShowTerm_$cshowList = showList__ $fShowTerm1

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$fShowTerm :: Show Term
$fShowTerm
  = C:Show
      $fShowTerm_$cshowsPrec $fShowTerm_$cshow $fShowTerm_$cshowList

Rec {
-- RHS size: {terms: 29, types: 15, coercions: 0, joins: 0/0}
$fEqTerm_$c== :: Term -> Term -> Bool
$fEqTerm_$c==
  = \ (ds :: Term) (ds1 :: Term) ->
      case ds of {
        Lit a1 ->
          case ds1 of {
            Lit b1 -> eqInt a1 b1;
            Add ipv ipv1 -> False
          };
        Add a1 a2 ->
          case ds1 of {
            Lit ipv -> False;
            Add b1 b2 ->
              case $fEqTerm_$c== a1 b1 of {
                False -> False;
                True -> $fEqTerm_$c== a2 b2
              }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fEqTerm_$c/= :: Term -> Term -> Bool
$fEqTerm_$c/=
  = \ (a :: Term) (b :: Term) ->
      case $fEqTerm_$c== a b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$fEqTerm :: Eq Term
$fEqTerm = C:Eq $fEqTerm_$c== $fEqTerm_$c/=

Rec {
-- RHS size: {terms: 31, types: 15, coercions: 0, joins: 0/0}
$fOrdTerm_$ccompare :: Term -> Term -> Ordering
$fOrdTerm_$ccompare
  = \ (a :: Term) (b :: Term) ->
      case a of {
        Lit a1 ->
          case b of {
            Lit b1 -> compareInt a1 b1;
            Add ipv ipv1 -> LT
          };
        Add a1 a2 ->
          case b of {
            Lit ipv -> GT;
            Add b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> LT;
                EQ -> $fOrdTerm_$ccompare a2 b2;
                GT -> GT
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 31, types: 15, coercions: 0, joins: 0/0}
$fOrdTerm_$c< :: Term -> Term -> Bool
$fOrdTerm_$c<
  = \ (a :: Term) (b :: Term) ->
      case a of {
        Lit a1 ->
          case b of {
            Lit b1 -> ltInt a1 b1;
            Add ipv ipv1 -> True
          };
        Add a1 a2 ->
          case b of {
            Lit ipv -> False;
            Add b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> True;
                EQ -> $fOrdTerm_$c< a2 b2;
                GT -> False
              }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$c<= :: Term -> Term -> Bool
$fOrdTerm_$c<=
  = \ (a :: Term) (b :: Term) ->
      case $fOrdTerm_$c< b a of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$cmax :: Term -> Term -> Term
$fOrdTerm_$cmax
  = \ (x :: Term) (y :: Term) ->
      case $fOrdTerm_$c< y x of {
        False -> y;
        True -> x
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$fOrdTerm_$c> :: Term -> Term -> Bool
$fOrdTerm_$c> = \ (a :: Term) (b :: Term) -> $fOrdTerm_$c< b a

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$c>= :: Term -> Term -> Bool
$fOrdTerm_$c>=
  = \ (a :: Term) (b :: Term) ->
      case $fOrdTerm_$c< a b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$cmin :: Term -> Term -> Term
$fOrdTerm_$cmin
  = \ (x :: Term) (y :: Term) ->
      case $fOrdTerm_$c< y x of {
        False -> x;
        True -> y
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
$fOrdTerm :: Ord Term
$fOrdTerm
  = C:Ord
      $fEqTerm
      $fOrdTerm_$ccompare
      $fOrdTerm_$c<
      $fOrdTerm_$c<=
      $fOrdTerm_$c>
      $fOrdTerm_$c>=
      $fOrdTerm_$cmax
      $fOrdTerm_$cmin

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
_Lit1 :: Term -> Either Term Int
_Lit1
  = \ (x :: Term) ->
      case x of wild {
        Lit y1 -> Right y1;
        Add ipv ipv1 -> Left wild
      }

-- RHS size: {terms: 29, types: 68, coercions: 0, joins: 0/2}
_Lit :: Prism' Term Int
_Lit
  = \ (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1 :: p (Either Term Int) (Either Term (f Int)) -> p Term (f Term)
        f1
          = dimap
              ($p1Choice $dChoice)
              _Lit1
              (let {
                 ds :: f Int -> f Term
                 ds = fmap ($p1Applicative $dApplicative) Lit } in
               \ (ds1 :: Either Term (f Int)) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p Int (f Int)) -> f1 (right' $dChoice x)

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/0}
_Add2 :: Term -> Either Term (Term, Term)
_Add2
  = \ (x :: Term) ->
      case x of wild {
        Lit ipv -> Left wild;
        Add y1 y2 -> Right (y1, y2)
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
_Add1 :: (Term, Term) -> Term
_Add1
  = \ (ds :: (Term, Term)) -> case ds of { (x1, x2) -> Add x1 x2 }

-- RHS size: {terms: 29, types: 94, coercions: 0, joins: 0/2}
_Add :: Prism' Term (Term, Term)
_Add
  = \ (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1
          :: p (Either Term (Term, Term)) (Either Term (f (Term, Term)))
             -> p Term (f Term)
        f1
          = dimap
              ($p1Choice $dChoice)
              _Add2
              (let {
                 ds :: f (Term, Term) -> f Term
                 ds = fmap ($p1Applicative $dApplicative) _Add1 } in
               \ (ds1 :: Either Term (f (Term, Term))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Term, Term) (f (Term, Term))) -> f1 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcTerm2 :: Addr#
$tcTerm2 = "Term"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcTerm1 :: TrName
$tcTerm1 = TrNameS $tcTerm2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcTerm :: TyCon
$tcTerm
  = TyCon
      13125389909717632925##
      158444914085072705##
      $trModule
      $tcTerm1
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepTyConApp $tcTerm []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Lit1 :: KindRep
$tc'Lit1 = KindRepFun $krep $krep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Lit3 :: Addr#
$tc'Lit3 = "'Lit"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Lit2 :: TrName
$tc'Lit2 = TrNameS $tc'Lit3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Lit :: TyCon
$tc'Lit
  = TyCon
      2127915294760195072##
      6083989906909856787##
      $trModule
      $tc'Lit2
      0#
      $tc'Lit1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepFun $krep1 $krep1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Add1 :: KindRep
$tc'Add1 = KindRepFun $krep1 $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Add3 :: Addr#
$tc'Add3 = "'Add"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Add2 :: TrName
$tc'Add2 = TrNameS $tc'Add3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Add :: TyCon
$tc'Add
  = TyCon
      3340925227475816255##
      17560363796720736399##
      $trModule
      $tc'Add2
      0#
      $tc'Add1



[2 of 2] Compiling Base.Type        ( initial-bp-example-term-base/Base/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base/build/initial-bp-example-term-base/Base/Type.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Simplified expression ====================
makePrisms
  (mkNameG_tc
     (unpackCString#
        "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul"#)
     (unpackCString# "Term.Type"#)
     (unpackCString# "Term"#))



==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 680, types: 1,800, coercions: 716, joins: 0/6}

-- RHS size: {terms: 24, types: 528, coercions: 347, joins: 0/0}
$fGenericTerm_$cto :: forall x. Rep Term x -> Term
$fGenericTerm_$cto
  = \ (@ x) (ds :: Rep Term x) ->
      case ds `cast` <Co:124> of {
        L1 ds1 -> Lit (ds1 `cast` <Co:47>);
        R1 ds1 ->
          case ds1 of {
            L1 ds2 ->
              case ds2 `cast` <Co:42> of { :*: ds3 ds4 ->
              Add (ds3 `cast` <Co:23>) (ds4 `cast` <Co:23>)
              };
            R1 ds2 ->
              case ds2 `cast` <Co:42> of { :*: ds3 ds4 ->
              Mul (ds3 `cast` <Co:23>) (ds4 `cast` <Co:23>)
              }
          }
      }

-- RHS size: {terms: 19, types: 577, coercions: 236, joins: 0/0}
$fGenericTerm1
  :: forall x.
     Term
     -> (:+:)
          (M1
             C
             ('MetaCons "Lit" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                (K1 R Int)))
          (M1
             C
             ('MetaCons "Add" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                (K1 R Term)
              :*: M1
                    S
                    ('MetaSel
                       'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                    (K1 R Term))
           :+: M1
                 C
                 ('MetaCons "Mul" 'PrefixI 'False)
                 (M1
                    S
                    ('MetaSel
                       'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                    (K1 R Term)
                  :*: M1
                        S
                        ('MetaSel
                           'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                        (K1 R Term)))
          x
$fGenericTerm1
  = \ (@ x) (x1 :: Term) ->
      case x1 of {
        Lit g1 -> L1 (g1 `cast` <Co:50>);
        Add g1 g2 ->
          R1
            (L1
               ((:*: (g1 `cast` <Co:25>) (g2 `cast` <Co:25>)) `cast` <Co:43>));
        Mul g1 g2 ->
          R1
            (R1 ((:*: (g1 `cast` <Co:25>) (g2 `cast` <Co:25>)) `cast` <Co:43>))
      }

-- RHS size: {terms: 3, types: 1, coercions: 130, joins: 0/0}
$fGenericTerm :: Generic Term
$fGenericTerm
  = C:Generic ($fGenericTerm1 `cast` <Co:130>) $fGenericTerm_$cto

Rec {
-- RHS size: {terms: 22, types: 11, coercions: 0, joins: 0/0}
$fNFDataTerm_$crnf :: Term -> ()
$fNFDataTerm_$crnf
  = \ (x :: Term) ->
      case x of {
        Lit g1 -> case g1 of { I# ipv -> () };
        Add g1 g2 ->
          case $fNFDataTerm_$crnf g1 of { () -> $fNFDataTerm_$crnf g2 };
        Mul g1 g2 ->
          case $fNFDataTerm_$crnf g1 of { () -> $fNFDataTerm_$crnf g2 }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fNFDataTerm :: NFData Term
$fNFDataTerm = $fNFDataTerm_$crnf `cast` <Co:3>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Addr#
lvl = "Mul "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1 :: Addr#
lvl1 = "Add "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2 :: Addr#
lvl2 = "Lit "#

Rec {
-- RHS size: {terms: 113, types: 49, coercions: 0, joins: 0/0}
$w$cshowsPrec :: Int# -> Term -> String -> String
$w$cshowsPrec
  = \ (ww :: Int#) (w :: Term) (w1 :: String) ->
      case w of {
        Lit b1 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl2
                (case b1 of { I# ww3 ->
                 case $wshowSignedInt 11# ww3 w1 of { (# ww5, ww6 #) -> : ww5 ww6 }
                 });
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl2
                   (case b1 of { I# ww3 ->
                    case $wshowSignedInt 11# ww3 (: $fShow(,)2 w1) of
                    { (# ww5, ww6 #) ->
                    : ww5 ww6
                    }
                    }))
          };
        Add b1 b2 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl1
                ($w$cshowsPrec 11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 w1)));
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl1
                   ($w$cshowsPrec
                      11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 (: $fShow(,)2 w1)))))
          };
        Mul b1 b2 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl
                ($w$cshowsPrec 11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 w1)));
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl
                   ($w$cshowsPrec
                      11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 (: $fShow(,)2 w1)))))
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
$fShowTerm_$cshowsPrec :: Int -> Term -> ShowS
$fShowTerm_$cshowsPrec
  = \ (w :: Int) (w1 :: Term) (w2 :: String) ->
      case w of { I# ww1 -> $w$cshowsPrec ww1 w1 w2 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTerm2 :: Int
$fShowTerm2 = I# 0#

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$fShowTerm_$cshow :: Term -> String
$fShowTerm_$cshow = \ (x :: Term) -> $w$cshowsPrec 0# x []

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
$fShowTerm1 :: Term -> ShowS
$fShowTerm1 = \ (w :: Term) (w1 :: String) -> $w$cshowsPrec 0# w w1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$fShowTerm_$cshowList :: [Term] -> ShowS
$fShowTerm_$cshowList = showList__ $fShowTerm1

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$fShowTerm :: Show Term
$fShowTerm
  = C:Show
      $fShowTerm_$cshowsPrec $fShowTerm_$cshow $fShowTerm_$cshowList

Rec {
-- RHS size: {terms: 45, types: 18, coercions: 0, joins: 0/0}
$fEqTerm_$c== :: Term -> Term -> Bool
$fEqTerm_$c==
  = \ (ds :: Term) (ds1 :: Term) ->
      case ds of {
        Lit a1 ->
          case ds1 of {
            __DEFAULT -> False;
            Lit b1 -> eqInt a1 b1
          };
        Add a1 a2 ->
          case ds1 of {
            __DEFAULT -> False;
            Add b1 b2 ->
              case $fEqTerm_$c== a1 b1 of {
                False -> False;
                True -> $fEqTerm_$c== a2 b2
              }
          };
        Mul a1 a2 ->
          case ds1 of {
            __DEFAULT -> False;
            Mul b1 b2 ->
              case $fEqTerm_$c== a1 b1 of {
                False -> False;
                True -> $fEqTerm_$c== a2 b2
              }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fEqTerm_$c/= :: Term -> Term -> Bool
$fEqTerm_$c/=
  = \ (a :: Term) (b :: Term) ->
      case $fEqTerm_$c== a b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$fEqTerm :: Eq Term
$fEqTerm = C:Eq $fEqTerm_$c== $fEqTerm_$c/=

Rec {
-- RHS size: {terms: 51, types: 21, coercions: 0, joins: 0/0}
$fOrdTerm_$ccompare :: Term -> Term -> Ordering
$fOrdTerm_$ccompare
  = \ (a :: Term) (b :: Term) ->
      case a of {
        Lit a1 ->
          case b of {
            __DEFAULT -> LT;
            Lit b1 -> compareInt a1 b1
          };
        Add a1 a2 ->
          case b of {
            Lit ds -> GT;
            Add b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> LT;
                EQ -> $fOrdTerm_$ccompare a2 b2;
                GT -> GT
              };
            Mul ipv ipv1 -> LT
          };
        Mul a1 a2 ->
          case b of {
            __DEFAULT -> GT;
            Mul b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> LT;
                EQ -> $fOrdTerm_$ccompare a2 b2;
                GT -> GT
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 51, types: 21, coercions: 0, joins: 0/0}
$fOrdTerm_$c< :: Term -> Term -> Bool
$fOrdTerm_$c<
  = \ (a :: Term) (b :: Term) ->
      case a of {
        Lit a1 ->
          case b of {
            __DEFAULT -> True;
            Lit b1 -> ltInt a1 b1
          };
        Add a1 a2 ->
          case b of {
            Lit ds -> False;
            Add b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> True;
                EQ -> $fOrdTerm_$c< a2 b2;
                GT -> False
              };
            Mul ipv ipv1 -> True
          };
        Mul a1 a2 ->
          case b of {
            __DEFAULT -> False;
            Mul b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> True;
                EQ -> $fOrdTerm_$c< a2 b2;
                GT -> False
              }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$c<= :: Term -> Term -> Bool
$fOrdTerm_$c<=
  = \ (a :: Term) (b :: Term) ->
      case $fOrdTerm_$c< b a of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$cmax :: Term -> Term -> Term
$fOrdTerm_$cmax
  = \ (x :: Term) (y :: Term) ->
      case $fOrdTerm_$c< y x of {
        False -> y;
        True -> x
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$fOrdTerm_$c> :: Term -> Term -> Bool
$fOrdTerm_$c> = \ (a :: Term) (b :: Term) -> $fOrdTerm_$c< b a

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$c>= :: Term -> Term -> Bool
$fOrdTerm_$c>=
  = \ (a :: Term) (b :: Term) ->
      case $fOrdTerm_$c< a b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$cmin :: Term -> Term -> Term
$fOrdTerm_$cmin
  = \ (x :: Term) (y :: Term) ->
      case $fOrdTerm_$c< y x of {
        False -> x;
        True -> y
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
$fOrdTerm :: Ord Term
$fOrdTerm
  = C:Ord
      $fEqTerm
      $fOrdTerm_$ccompare
      $fOrdTerm_$c<
      $fOrdTerm_$c<=
      $fOrdTerm_$c>
      $fOrdTerm_$c>=
      $fOrdTerm_$cmax
      $fOrdTerm_$cmin

-- RHS size: {terms: 9, types: 7, coercions: 0, joins: 0/0}
_Lit1 :: Term -> Either Term Int
_Lit1
  = \ (x :: Term) ->
      case x of wild {
        __DEFAULT -> Left wild;
        Lit y1 -> Right y1
      }

-- RHS size: {terms: 29, types: 68, coercions: 0, joins: 0/2}
_Lit :: Prism' Term Int
_Lit
  = \ (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1 :: p (Either Term Int) (Either Term (f Int)) -> p Term (f Term)
        f1
          = dimap
              ($p1Choice $dChoice)
              _Lit1
              (let {
                 ds :: f Int -> f Term
                 ds = fmap ($p1Applicative $dApplicative) Lit } in
               \ (ds1 :: Either Term (f Int)) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p Int (f Int)) -> f1 (right' $dChoice x)

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
_Add2 :: Term -> Either Term (Term, Term)
_Add2
  = \ (x :: Term) ->
      case x of wild {
        __DEFAULT -> Left wild;
        Add y1 y2 -> Right (y1, y2)
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
_Add1 :: (Term, Term) -> Term
_Add1
  = \ (ds :: (Term, Term)) -> case ds of { (x1, x2) -> Add x1 x2 }

-- RHS size: {terms: 29, types: 94, coercions: 0, joins: 0/2}
_Add :: Prism' Term (Term, Term)
_Add
  = \ (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1
          :: p (Either Term (Term, Term)) (Either Term (f (Term, Term)))
             -> p Term (f Term)
        f1
          = dimap
              ($p1Choice $dChoice)
              _Add2
              (let {
                 ds :: f (Term, Term) -> f Term
                 ds = fmap ($p1Applicative $dApplicative) _Add1 } in
               \ (ds1 :: Either Term (f (Term, Term))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Term, Term) (f (Term, Term))) -> f1 (right' $dChoice x)

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
_Mul2 :: Term -> Either Term (Term, Term)
_Mul2
  = \ (x :: Term) ->
      case x of wild {
        __DEFAULT -> Left wild;
        Mul y1 y2 -> Right (y1, y2)
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
_Mul1 :: (Term, Term) -> Term
_Mul1
  = \ (ds :: (Term, Term)) -> case ds of { (x1, x2) -> Mul x1 x2 }

-- RHS size: {terms: 29, types: 94, coercions: 0, joins: 0/2}
_Mul :: Prism' Term (Term, Term)
_Mul
  = \ (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1
          :: p (Either Term (Term, Term)) (Either Term (f (Term, Term)))
             -> p Term (f Term)
        f1
          = dimap
              ($p1Choice $dChoice)
              _Mul2
              (let {
                 ds :: f (Term, Term) -> f Term
                 ds = fmap ($p1Applicative $dApplicative) _Mul1 } in
               \ (ds1 :: Either Term (f (Term, Term))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Term, Term) (f (Term, Term))) -> f1 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcTerm2 :: Addr#
$tcTerm2 = "Term"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcTerm1 :: TrName
$tcTerm1 = TrNameS $tcTerm2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcTerm :: TyCon
$tcTerm
  = TyCon
      2630348280895690721##
      15105938534310112005##
      $trModule
      $tcTerm1
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepTyConApp $tcTerm []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Lit1 :: KindRep
$tc'Lit1 = KindRepFun $krep $krep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Lit3 :: Addr#
$tc'Lit3 = "'Lit"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Lit2 :: TrName
$tc'Lit2 = TrNameS $tc'Lit3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Lit :: TyCon
$tc'Lit
  = TyCon
      7433755091468295160##
      2253289015062990466##
      $trModule
      $tc'Lit2
      0#
      $tc'Lit1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepFun $krep1 $krep1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Add1 :: KindRep
$tc'Add1 = KindRepFun $krep1 $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Add3 :: Addr#
$tc'Add3 = "'Add"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Add2 :: TrName
$tc'Add2 = TrNameS $tc'Add3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Add :: TyCon
$tc'Add
  = TyCon
      13550697149459958477##
      17169862476243244848##
      $trModule
      $tc'Add2
      0#
      $tc'Add1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Mul2 :: Addr#
$tc'Mul2 = "'Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Mul1 :: TrName
$tc'Mul1 = TrNameS $tc'Mul2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Mul :: TyCon
$tc'Mul
  = TyCon
      6038886010926779136##
      14959456524522162931##
      $trModule
      $tc'Mul1
      0#
      $tc'Add1



[2 of 3] Compiling Mul.Type         ( initial-bp-example-term-base-mul/Mul/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-mul/build/initial-bp-example-term-base-mul/Mul/Type.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[3 of 3] Compiling Base.Type        ( initial-bp-example-term-base-mul/Base/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-mul/build/initial-bp-example-term-base-mul/Base/Type.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Preprocessing library 'initial-bp-base-sig' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-sig' instantiated with
  Base.Type = <Base.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-mul-sig' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul-sig' instantiated with
  Mul.Type = <Mul.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[1 of 2] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-sig/build/initial-bp-base-sig/autogen/Term/Type.hsig, nothing )
[1 of 2] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-sig/build/initial-bp-mul-sig/autogen/Term/Type.hsig, nothing )
[2 of 2] Compiling Base.Type[sig]   ( initial-bp-base-sig/Base/Type.hsig, nothing )
[2 of 2] Compiling Mul.Type[sig]    ( initial-bp-mul-sig/Mul/Type.hsig, nothing )
Configuring library 'initial-bp-base-print' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base-eval' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-mul-eval' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-mul' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-mul-print' for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-base' for initial-bp-0.1.0.0..
Building library 'initial-bp-base' instantiated with
  Base.Type = <Base.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-base-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-eval' instantiated with
  Base.Type = <Base.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-mul-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul-eval' instantiated with
  Base.Type = <Base.Type>
  Mul.Type = <Mul.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-base-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-print' instantiated with
  Base.Type = <Base.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-mul' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul' instantiated with
  Mul.Type = <Mul.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base/build/initial-bp-base/autogen/Term/Type.hsig, nothing )
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/build/initial-bp-base-eval/autogen/Term/Type.hsig, nothing )
Preprocessing library 'initial-bp-mul-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul-print' instantiated with
  Mul.Type = <Mul.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[1 of 4] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/build/initial-bp-mul-eval/autogen/Term/Type.hsig, nothing )
[2 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base/build/initial-bp-base/autogen/Base/Type.hsig, nothing )
[2 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/build/initial-bp-base-eval/autogen/Base/Type.hsig, nothing )
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/build/initial-bp-base-print/autogen/Term/Type.hsig, nothing )
[2 of 4] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/build/initial-bp-mul-eval/autogen/Mul/Type.hsig, nothing )
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul/build/initial-bp-mul/autogen/Term/Type.hsig, nothing )
[2 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/build/initial-bp-base-print/autogen/Base/Type.hsig, nothing )
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/build/initial-bp-mul-print/autogen/Term/Type.hsig, nothing )
[2 of 3] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul/build/initial-bp-mul/autogen/Mul/Type.hsig, nothing )
[2 of 3] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/build/initial-bp-mul-print/autogen/Mul/Type.hsig, nothing )
[3 of 3] Compiling Base.Eval        ( initial-bp-base-eval/Base/Eval.hs, nothing )
[3 of 3] Compiling Base             ( initial-bp-base/Base.hs, nothing )
[3 of 4] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/build/initial-bp-mul-eval/autogen/Base/Type.hsig, nothing )
[4 of 4] Compiling Mul.Eval         ( initial-bp-mul-eval/Mul/Eval.hs, nothing )
[3 of 3] Compiling Base.Print       ( initial-bp-base-print/Base/Print.hs, nothing )
[3 of 3] Compiling Mul              ( initial-bp-mul/Mul.hs, nothing )
[3 of 3] Compiling Mul.Print        ( initial-bp-mul-print/Mul/Print.hs, nothing )
Configuring library 'initial-bp-base-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type
for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
Configuring library 'initial-bp-example-base' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-mul-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Mul.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base-print' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type
for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base-print' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
Configuring library 'initial-bp-mul-print' instantiated with
  Mul.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-base-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-base-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
[1 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/autogen/Base/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/Base/Type.o )
Preprocessing library 'initial-bp-example-base' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-base' instantiated with
  Base.Type = <Base.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-mul-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Mul.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
[1 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/autogen/Base/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/Base/Type.o )
Preprocessing library 'initial-bp-base-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-print' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type
for initial-bp-0.1.0.0..
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-base/build/initial-bp-example-base/autogen/Term/Type.hsig, nothing )
[1 of 4] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/autogen/Base/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/Base/Type.o )
[2 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-base/build/initial-bp-example-base/autogen/Base/Type.hsig, nothing )
Preprocessing library 'initial-bp-base-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-print' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
[1 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/autogen/Base/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/Base/Type.o )
Preprocessing library 'initial-bp-mul-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul-print' instantiated with
  Mul.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
[1 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/autogen/Base/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/Base/Type.o )
[2 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/Term/Type.o )
[3 of 3] Compiling Example.Base     ( initial-bp-example-base/Example/Base.hs, nothing )
[1 of 3] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/autogen/Mul/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/Mul/Type.o )
[3 of 3] Compiling Base.Eval        ( initial-bp-base-eval/Base/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/Base/Eval.o )
[2 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/Term/Type.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 46, types: 39, coercions: 0, joins: 0/0}

-- RHS size: {terms: 24, types: 19, coercions: 0, joins: 0/0}
evalRules1 :: (Term -> Term) -> Term -> Maybe Term
evalRules1
  = \ (e :: Term -> Term) (tm :: Term) ->
      case tm of {
        Lit ipv -> Nothing;
        Add y1 y2 ->
          case e y1 of {
            Lit y4 ->
              case e y2 of {
                Lit y5 -> Just (Lit ($fNumInt_$c+ y4 y5));
                Add ipv ipv1 -> Nothing
              };
            Add ipv ipv1 -> Nothing
          }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
evalRules2 :: EvalRule Term
evalRules2 = EvalRule evalRules1

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
evalRules :: [EvalRule Term]
evalRules = : evalRules2 []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[3 of 3] Compiling Base.Eval        ( initial-bp-base-eval/Base/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/Base/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 46, types: 34, coercions: 0, joins: 0/0}

-- RHS size: {terms: 24, types: 14, coercions: 0, joins: 0/0}
evalRules1 :: (Term -> Term) -> Term -> Maybe Term
evalRules1
  = \ (e :: Term -> Term) (tm :: Term) ->
      case tm of {
        __DEFAULT -> Nothing;
        Add y1 y2 ->
          case e y1 of {
            __DEFAULT -> Nothing;
            Lit y4 ->
              case e y2 of {
                __DEFAULT -> Nothing;
                Lit y5 -> Just (Lit ($fNumInt_$c+ y4 y5))
              }
          }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
evalRules2 :: EvalRule Term
evalRules2 = EvalRule evalRules1

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
evalRules :: [EvalRule Term]
evalRules = : evalRules2 []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[2 of 4] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/autogen/Mul/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/Mul/Type.o )
[2 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/Term/Type.o )
[3 of 4] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/Term/Type.o )
[3 of 3] Compiling Base.Print       ( initial-bp-base-print/Base/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/Base/Print.o )
[4 of 4] Compiling Mul.Eval         ( initial-bp-mul-eval/Mul/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/Mul/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 78, types: 81, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules7 :: Addr#
printRules7 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules6 :: Addr#
printRules6 = " + "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules5 :: Addr#
printRules5 = ")"#

-- RHS size: {terms: 10, types: 10, coercions: 0, joins: 0/0}
printRules9 :: (Term -> Maybe String) -> Term -> Maybe String
printRules9
  = \ _ (tm :: Term) ->
      case tm of {
        Lit y1 -> Just ($fShowInt_$cshow y1);
        Add ipv ipv1 -> Nothing
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printRules8 :: PrintRule Term
printRules8 = PrintRule printRules9

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
printRules4 :: [Char]
printRules4 = unpackCString# printRules5

-- RHS size: {terms: 29, types: 29, coercions: 0, joins: 0/0}
printRules3 :: (Term -> Maybe [Char]) -> Term -> Maybe [Char]
printRules3
  = \ (pr :: Term -> Maybe [Char]) (tm :: Term) ->
      case tm of {
        Lit ipv -> Nothing;
        Add y1 y2 ->
          case pr y1 of {
            Nothing -> Nothing;
            Just x ->
              case pr y2 of {
                Nothing -> Nothing;
                Just x1 ->
                  Just
                    (unpackAppendCString#
                       printRules7
                       (++ x (unpackAppendCString# printRules6 (++ x1 printRules4))))
              }
          }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printRules2 :: PrintRule Term
printRules2 = PrintRule printRules3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
printRules1 :: [PrintRule Term]
printRules1 = : printRules2 []

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
printRules :: [PrintRule Term]
printRules = : printRules8 printRules1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 46, types: 34, coercions: 0, joins: 0/0}

-- RHS size: {terms: 24, types: 14, coercions: 0, joins: 0/0}
evalRules1 :: (Term -> Term) -> Term -> Maybe Term
evalRules1
  = \ (e :: Term -> Term) (tm :: Term) ->
      case tm of {
        __DEFAULT -> Nothing;
        Mul y1 y2 ->
          case e y1 of {
            __DEFAULT -> Nothing;
            Lit y4 ->
              case e y2 of {
                __DEFAULT -> Nothing;
                Lit y5 -> Just (Lit ($fNumInt_$c* y4 y5))
              }
          }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
evalRules2 :: EvalRule Term
evalRules2 = EvalRule evalRules1

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
evalRules :: [EvalRule Term]
evalRules = : evalRules2 []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[2 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/Term/Type.o )
Configuring library 'initial-bp-example-mul' for initial-bp-0.1.0.0..
[3 of 3] Compiling Base.Print       ( initial-bp-base-print/Base/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/Base/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 78, types: 78, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules7 :: Addr#
printRules7 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules6 :: Addr#
printRules6 = " + "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules5 :: Addr#
printRules5 = ")"#

-- RHS size: {terms: 10, types: 8, coercions: 0, joins: 0/0}
printRules9 :: (Term -> Maybe String) -> Term -> Maybe String
printRules9
  = \ _ (tm :: Term) ->
      case tm of {
        __DEFAULT -> Nothing;
        Lit y1 -> Just ($fShowInt_$cshow y1)
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printRules8 :: PrintRule Term
printRules8 = PrintRule printRules9

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
printRules4 :: [Char]
printRules4 = unpackCString# printRules5

-- RHS size: {terms: 29, types: 28, coercions: 0, joins: 0/0}
printRules3 :: (Term -> Maybe [Char]) -> Term -> Maybe [Char]
printRules3
  = \ (pr :: Term -> Maybe [Char]) (tm :: Term) ->
      case tm of {
        __DEFAULT -> Nothing;
        Add y1 y2 ->
          case pr y1 of {
            Nothing -> Nothing;
            Just x ->
              case pr y2 of {
                Nothing -> Nothing;
                Just x1 ->
                  Just
                    (unpackAppendCString#
                       printRules7
                       (++ x (unpackAppendCString# printRules6 (++ x1 printRules4))))
              }
          }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printRules2 :: PrintRule Term
printRules2 = PrintRule printRules3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
printRules1 :: [PrintRule Term]
printRules1 = : printRules2 []

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
printRules :: [PrintRule Term]
printRules = : printRules8 printRules1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[2 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/Term/Type.o )
[3 of 3] Compiling Mul.Print        ( initial-bp-mul-print/Mul/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/Mul/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 60, types: 56, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules6 :: Addr#
printRules6 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules5 :: Addr#
printRules5 = " * "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules4 :: Addr#
printRules4 = ")"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
printRules3 :: [Char]
printRules3 = unpackCString# printRules4

-- RHS size: {terms: 29, types: 28, coercions: 0, joins: 0/0}
printRules2 :: (Term -> Maybe [Char]) -> Term -> Maybe [Char]
printRules2
  = \ (p :: Term -> Maybe [Char]) (tm :: Term) ->
      case tm of {
        __DEFAULT -> Nothing;
        Mul y1 y2 ->
          case p y1 of {
            Nothing -> Nothing;
            Just x ->
              case p y2 of {
                Nothing -> Nothing;
                Just x1 ->
                  Just
                    (unpackAppendCString#
                       printRules6
                       (++ x (unpackAppendCString# printRules5 (++ x1 printRules3))))
              }
          }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printRules1 :: PrintRule Term
printRules1 = PrintRule printRules2

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
printRules :: [PrintRule Term]
printRules = : printRules1 []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Configuring library 'initial-bp-example-term-base-eval' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-example-term-base-mul-eval' for initial-bp-0.1.0.0..
Configuring library for initial-bp-0.1.0.0..
Configuring library 'initial-bp-example-term-base-print' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-example-term-base-mul-print' for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-example-mul' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-mul' instantiated with
  Base.Type = <Base.Type>
  Mul.Type = <Mul.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[1 of 4] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-mul/build/initial-bp-example-mul/autogen/Term/Type.hsig, nothing )
[2 of 4] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-mul/build/initial-bp-example-mul/autogen/Mul/Type.hsig, nothing )
[3 of 4] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-mul/build/initial-bp-example-mul/autogen/Base/Type.hsig, nothing )
[4 of 4] Compiling Example.Mul      ( initial-bp-example-mul/Example/Mul.hs, nothing )
Preprocessing library 'initial-bp-example-term-base-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base-eval' for initial-bp-0.1.0.0..
Preprocessing library for initial-bp-0.1.0.0..
Building library for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-example-term-base-mul-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base-mul-eval' for initial-bp-0.1.0.0..
[1 of 1] Compiling Term.Eval        ( initial-bp-example-term-base-eval/Term/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-eval/build/initial-bp-example-term-base-eval/Term/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 17, types: 8, coercions: 0, joins: 0/0}

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
evalTerm :: Term -> Term
evalTerm = mkEval evalRules

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Preprocessing library 'initial-bp-example-term-base-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base-print' for initial-bp-0.1.0.0..
[1 of 1] Compiling InitialBP.Bench  ( src/InitialBP/Bench.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/build/InitialBP/Bench.o )
[1 of 1] Compiling Term.Eval        ( initial-bp-example-term-base-mul-eval/Term/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-mul-eval/build/initial-bp-example-term-base-mul-eval/Term/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 21, types: 13, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
evalTerm1 :: [EvalRule Term]
evalTerm1 = ++ evalRules evalRules

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
evalTerm :: Term -> Term
evalTerm = mkEval evalTerm1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul-eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 97, types: 51, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
evalTerm1 :: [EvalRule Term]
evalTerm1 = ++ evalRules evalRules

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
evalTerm :: Term -> Term
evalTerm = mkEval evalTerm1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lit1 :: Int
lit1 = I# 2#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lit2 :: Term
lit2 = Lit lit1

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
evalAddSmall :: (Term -> Term) -> Term -> Term
evalAddSmall
  = \ (eval :: Term -> Term) (tm :: Term) -> eval (Add tm tm)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddBig4 :: Int
evalAddBig4 = I# 3#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddBig3 :: Term
evalAddBig3 = Lit evalAddBig4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddBig2 :: Int
evalAddBig2 = I# 5#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddBig1 :: Term
evalAddBig1 = Lit evalAddBig2

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
evalAddMulSmall :: (Term -> Term) -> Term -> Term
evalAddMulSmall
  = \ (eval :: Term -> Term) (tm :: Term) ->
      eval (Add (Mul tm evalAddBig3) evalAddBig1)

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
evalAddBig :: (Term -> Term) -> Term -> Term
evalAddBig
  = \ (eval :: Term -> Term) (tm :: Term) ->
      eval (Add (Add tm evalAddBig3) (Add tm evalAddBig1))

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddMulBig4 :: Int
evalAddMulBig4 = I# 7#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddMulBig3 :: Term
evalAddMulBig3 = Lit evalAddMulBig4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddMulBig2 :: Int
evalAddMulBig2 = I# 11#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddMulBig1 :: Term
evalAddMulBig1 = Lit evalAddMulBig2

-- RHS size: {terms: 18, types: 3, coercions: 0, joins: 0/0}
evalAddMulBig :: (Term -> Term) -> Term -> Term
evalAddMulBig
  = \ (eval :: Term -> Term) (tm :: Term) ->
      eval
        (Add
           (Mul (Add tm evalAddBig3) (Add tm evalAddBig1))
           (Mul (Add tm evalAddMulBig3) (Add tm evalAddMulBig1)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-bp-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "InitialBP.Bench"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[1 of 1] Compiling Term.Print       ( initial-bp-example-term-base-print/Term/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-print/build/initial-bp-example-term-base-print/Term/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 17, types: 9, coercions: 0, joins: 0/0}

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printTerm :: Term -> Maybe String
printTerm = mkPrint printRules

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Preprocessing library 'initial-bp-example-term-base-mul-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base-mul-print' for initial-bp-0.1.0.0..
[1 of 1] Compiling Term.Print       ( initial-bp-example-term-base-mul-print/Term/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-mul-print/build/initial-bp-example-term-base-mul-print/Term/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 21, types: 14, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
printTerm1 :: [PrintRule Term]
printTerm1 = ++ printRules printRules

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printTerm :: Term -> Maybe String
printTerm = mkPrint printTerm1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul-print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



