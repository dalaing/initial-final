In order, the following will be built (use -v for more details):
 - initial-0.1.0.0 (lib) +dump (file src/Example/Term/BaseMul/Type.hs changed)
 - initial-final-bench-0.1.0.0 (exe:bench) (dependency rebuilt)
Preprocessing library for initial-0.1.0.0..
Building library for initial-0.1.0.0..
[ 4 of 20] Compiling Mul.Type         ( src/Mul/Type.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Mul/Type.o )

==================== Simplified expression ====================
makePrisms
  (mkNameG_tc
     (unpackCString# "initial-0.1.0.0-inplace"#)
     (unpackCString# "Mul.Type"#)
     (unpackCString# "MulF"#))



==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 687, types: 1,702, coercions: 728, joins: 0/7}

-- RHS size: {terms: 3, types: 10, coercions: 2, joins: 0/0}
_MulF
  :: forall (tm :: (* -> *) -> * -> *).
     HasMulF tm =>
     forall (f :: * -> *) a. Prism' (tm f a) (MulF f a)
_MulF
  = \ (@ (tm :: (* -> *) -> * -> *)) (v :: HasMulF tm) ->
      v `cast` <Co:2>

-- RHS size: {terms: 7, types: 28, coercions: 0, joins: 0/0}
$fHasMulFMulF_$c_MulF
  :: forall (f :: * -> *) a. Prism' (MulF f a) (MulF f a)
$fHasMulFMulF_$c_MulF
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      _
      _ ->
      id

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fHasMulFMulF :: HasMulF MulF
$fHasMulFMulF = $fHasMulFMulF_$c_MulF `cast` <Co:3>

-- RHS size: {terms: 10, types: 84, coercions: 152, joins: 0/0}
$fGenericMulF_$cto
  :: forall (f :: * -> *) a x. Rep (MulF f a) x -> MulF f a
$fGenericMulF_$cto
  = \ (@ (f :: * -> *)) (@ a) (@ x) (ds :: Rep (MulF f a) x) ->
      case ds `cast` <Co:102> of { :*: ds1 ds2 ->
      TmMul (ds1 `cast` <Co:25>) (ds2 `cast` <Co:25>)
      }

-- RHS size: {terms: 10, types: 52, coercions: 99, joins: 0/0}
$fGenericMulF1
  :: forall (f :: * -> *) a x.
     MulF f a
     -> M1
          C
          ('MetaCons "TmMul" 'PrefixI 'False)
          (M1
             S
             ('MetaSel
                'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
             (K1 R (f a))
           :*: M1
                 S
                 ('MetaSel
                    'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                 (K1 R (f a)))
          x
$fGenericMulF1
  = \ (@ (f :: * -> *)) (@ a) (@ x) (x1 :: MulF f a) ->
      case x1 of { TmMul g1 g2 ->
      (:*: (g1 `cast` <Co:27>) (g2 `cast` <Co:27>)) `cast` <Co:45>
      }

-- RHS size: {terms: 5, types: 13, coercions: 66, joins: 0/0}
$fGenericMulF :: forall (f :: * -> *) a. Generic (MulF f a)
$fGenericMulF
  = \ (@ (f :: * -> *)) (@ a) ->
      C:Generic ($fGenericMulF1 `cast` <Co:66>) $fGenericMulF_$cto

-- RHS size: {terms: 13, types: 20, coercions: 6, joins: 0/0}
$fNFDataMulF_$crnf
  :: forall (f :: * -> *) a. NFData (f a) => MulF f a -> ()
$fNFDataMulF_$crnf
  = \ (@ (f :: * -> *))
      (@ a)
      ($dNFData :: NFData (f a))
      (eta :: MulF f a) ->
      case eta of { TmMul g1 g2 ->
      case ($dNFData `cast` <Co:3>) g1 of { () ->
      ($dNFData `cast` <Co:3>) g2
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
$fNFDataMulF
  :: forall (f :: * -> *) a. NFData (f a) => NFData (MulF f a)
$fNFDataMulF = $fNFDataMulF_$crnf `cast` <Co:17>

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowMulF3 :: Int
$fShowMulF3 = I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowMulF2 :: Addr#
$fShowMulF2 = "TmMul "#

-- RHS size: {terms: 43, types: 30, coercions: 0, joins: 0/2}
$w$cshowsPrec
  :: forall (f :: * -> *) a.
     Show (f a) =>
     Int# -> f a -> f a -> ShowS
$w$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (ww :: Int#)
      (ww1 :: f a)
      (ww2 :: f a) ->
      let {
        f1 :: String -> String
        f1 = showsPrec w $fShowMulF3 ww1 } in
      let {
        g :: String -> String
        g = showsPrec w $fShowMulF3 ww2 } in
      case tagToEnum# (>=# ww 11#) of {
        False ->
          \ (x :: String) ->
            unpackAppendCString# $fShowMulF2 (f1 (: showSpace1 (g x)));
        True ->
          \ (x :: String) ->
            : $fShow(,)4
              (unpackAppendCString#
                 $fShowMulF2 (f1 (: showSpace1 (g (: $fShow(,)2 x)))))
      }

-- RHS size: {terms: 16, types: 24, coercions: 0, joins: 0/0}
$fShowMulF_$cshowsPrec
  :: forall (f :: * -> *) a. Show (f a) => Int -> MulF f a -> ShowS
$fShowMulF_$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (w1 :: Int)
      (w2 :: MulF f a) ->
      case w1 of { I# ww1 ->
      case w2 of { TmMul ww3 ww4 -> $w$cshowsPrec w ww1 ww3 ww4 }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowMulF1 :: Int
$fShowMulF1 = I# 0#

-- RHS size: {terms: 13, types: 22, coercions: 0, joins: 0/0}
$fShowMulF_$cshow
  :: forall (f :: * -> *) a. Show (f a) => MulF f a -> String
$fShowMulF_$cshow
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (x :: MulF f a) ->
      case x of { TmMul ww1 ww2 -> $w$cshowsPrec $dShow 0# ww1 ww2 [] }

-- RHS size: {terms: 17, types: 29, coercions: 0, joins: 0/0}
$fShowMulF_$cshowList
  :: forall (f :: * -> *) a. Show (f a) => [MulF f a] -> ShowS
$fShowMulF_$cshowList
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (eta :: [MulF f a])
      (eta1 :: String) ->
      showList__
        (\ (w :: MulF f a) ->
           case w of { TmMul ww1 ww2 -> $w$cshowsPrec $dShow 0# ww1 ww2 })
        eta
        eta1

-- RHS size: {terms: 10, types: 18, coercions: 0, joins: 0/0}
$fShowMulF :: forall (f :: * -> *) a. Show (f a) => Show (MulF f a)
$fShowMulF
  = \ (@ (f :: * -> *)) (@ a) ($dShow :: Show (f a)) ->
      C:Show
        ($fShowMulF_$cshowsPrec $dShow)
        ($fShowMulF_$cshow $dShow)
        ($fShowMulF_$cshowList $dShow)

-- RHS size: {terms: 21, types: 22, coercions: 0, joins: 0/0}
$w$c<
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     f a -> f a -> f a -> f a -> Bool
$w$c<
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (ww :: f a)
      (ww1 :: f a)
      (ww2 :: f a)
      (ww3 :: f a) ->
      case compare w ww ww2 of {
        LT -> True;
        EQ -> < w ww1 ww3;
        GT -> False
      }

-- RHS size: {terms: 17, types: 31, coercions: 0, joins: 0/0}
$fOrdMulF_$c<
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> Bool
$fOrdMulF_$c<
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of { TmMul ww1 ww2 ->
      case w2 of { TmMul ww4 ww5 -> $w$c< w ww1 ww2 ww4 ww5 }
      }

-- RHS size: {terms: 21, types: 22, coercions: 0, joins: 0/0}
$w$ccompare
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     f a -> f a -> f a -> f a -> Ordering
$w$ccompare
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (ww :: f a)
      (ww1 :: f a)
      (ww2 :: f a)
      (ww3 :: f a) ->
      case compare w ww ww2 of {
        LT -> LT;
        EQ -> compare w ww1 ww3;
        GT -> GT
      }

-- RHS size: {terms: 17, types: 31, coercions: 0, joins: 0/0}
$fOrdMulF_$ccompare
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> Ordering
$fOrdMulF_$ccompare
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of { TmMul ww1 ww2 ->
      case w2 of { TmMul ww4 ww5 -> $w$ccompare w ww1 ww2 ww4 ww5 }
      }

-- RHS size: {terms: 19, types: 22, coercions: 0, joins: 0/0}
$w$c==
  :: forall (f :: * -> *) a.
     Eq (f a) =>
     f a -> f a -> f a -> f a -> Bool
$w$c==
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Eq (f a))
      (ww :: f a)
      (ww1 :: f a)
      (ww2 :: f a)
      (ww3 :: f a) ->
      case == w ww ww2 of {
        False -> False;
        True -> == w ww1 ww3
      }

-- RHS size: {terms: 17, types: 31, coercions: 0, joins: 0/0}
$fEqMulF_$c==
  :: forall (f :: * -> *) a. Eq (f a) => MulF f a -> MulF f a -> Bool
$fEqMulF_$c==
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Eq (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of { TmMul ww1 ww2 ->
      case w2 of { TmMul ww4 ww5 -> $w$c== w ww1 ww2 ww4 ww5 }
      }

-- RHS size: {terms: 28, types: 35, coercions: 0, joins: 0/0}
$fEqMulF_$c/=
  :: forall (f :: * -> *) a. Eq (f a) => MulF f a -> MulF f a -> Bool
$fEqMulF_$c/=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dEq :: Eq (f a))
      (a1 :: MulF f a)
      (b :: MulF f a) ->
      case a1 of { TmMul ww1 ww2 ->
      case b of { TmMul ww4 ww5 ->
      case == $dEq ww1 ww4 of {
        False -> True;
        True ->
          case == $dEq ww2 ww5 of {
            False -> True;
            True -> False
          }
      }
      }
      }

-- RHS size: {terms: 8, types: 16, coercions: 0, joins: 0/0}
$fEqMulF :: forall (f :: * -> *) a. Eq (f a) => Eq (MulF f a)
$fEqMulF
  = \ (@ (f :: * -> *)) (@ a) ($dEq :: Eq (f a)) ->
      C:Eq ($fEqMulF_$c== $dEq) ($fEqMulF_$c/= $dEq)

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
$fOrdMulF_$cp1Ord
  :: forall (f :: * -> *) a. Ord (f a) => Eq (MulF f a)
$fOrdMulF_$cp1Ord
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      $fEqMulF ($p1Ord $dOrd)

-- RHS size: {terms: 26, types: 23, coercions: 0, joins: 0/0}
$w$c<=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     f a -> f a -> f a -> f a -> Bool
$w$c<=
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (ww :: f a)
      (ww1 :: f a)
      (ww2 :: f a)
      (ww3 :: f a) ->
      case compare w ww2 ww of {
        LT -> False;
        EQ ->
          case < w ww3 ww1 of {
            False -> True;
            True -> False
          };
        GT -> True
      }

-- RHS size: {terms: 17, types: 31, coercions: 0, joins: 0/0}
$fOrdMulF_$c<=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> Bool
$fOrdMulF_$c<=
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of { TmMul ww1 ww2 ->
      case w2 of { TmMul ww4 ww5 -> $w$c<= w ww1 ww2 ww4 ww5 }
      }

-- RHS size: {terms: 30, types: 35, coercions: 0, joins: 0/0}
$fOrdMulF_$cmax
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> MulF f a
$fOrdMulF_$cmax
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of ww { TmMul ww1 ww2 ->
      case w2 of ww3 { TmMul ww4 ww5 ->
      case compare w ww4 ww1 of {
        LT -> ww;
        EQ ->
          case < w ww5 ww2 of {
            False -> ww3;
            True -> ww
          };
        GT -> ww3
      }
      }
      }

-- RHS size: {terms: 26, types: 23, coercions: 0, joins: 0/0}
$w$c>=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     f a -> f a -> f a -> f a -> Bool
$w$c>=
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (ww :: f a)
      (ww1 :: f a)
      (ww2 :: f a)
      (ww3 :: f a) ->
      case compare w ww ww2 of {
        LT -> False;
        EQ ->
          case < w ww1 ww3 of {
            False -> True;
            True -> False
          };
        GT -> True
      }

-- RHS size: {terms: 17, types: 31, coercions: 0, joins: 0/0}
$fOrdMulF_$c>=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> Bool
$fOrdMulF_$c>=
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of { TmMul ww1 ww2 ->
      case w2 of { TmMul ww4 ww5 -> $w$c>= w ww1 ww2 ww4 ww5 }
      }

-- RHS size: {terms: 30, types: 35, coercions: 0, joins: 0/0}
$fOrdMulF_$cmin
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> MulF f a
$fOrdMulF_$cmin
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of ww { TmMul ww1 ww2 ->
      case w2 of ww3 { TmMul ww4 ww5 ->
      case compare w ww4 ww1 of {
        LT -> ww3;
        EQ ->
          case < w ww5 ww2 of {
            False -> ww;
            True -> ww3
          };
        GT -> ww
      }
      }
      }

-- RHS size: {terms: 24, types: 34, coercions: 0, joins: 0/0}
$fOrdMulF :: forall (f :: * -> *) a. Ord (f a) => Ord (MulF f a)
$fOrdMulF
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      C:Ord
        ($fOrdMulF_$cp1Ord $dOrd)
        ($fOrdMulF_$ccompare $dOrd)
        ($fOrdMulF_$c< $dOrd)
        ($fOrdMulF_$c<= $dOrd)
        (\ (a1 :: MulF f a) (b :: MulF f a) -> $fOrdMulF_$c< $dOrd b a1)
        ($fOrdMulF_$c>= $dOrd)
        ($fOrdMulF_$cmax $dOrd)
        ($fOrdMulF_$cmin $dOrd)

-- RHS size: {terms: 9, types: 20, coercions: 0, joins: 0/0}
_Mul2 :: forall (f :: * -> *) a. MulF f a -> (f a, f a)
_Mul2
  = \ (@ (f :: * -> *)) (@ a) (ds :: MulF f a) ->
      case ds of { TmMul x1 x2 -> (x1, x2) }

-- RHS size: {terms: 9, types: 22, coercions: 0, joins: 0/0}
_Mul1 :: forall (f :: * -> *) a. (f a, f a) -> MulF f a
_Mul1
  = \ (@ (f :: * -> *)) (@ a) (ds :: (f a, f a)) ->
      case ds of { (x1, x2) -> TmMul x1 x2 }

-- RHS size: {terms: 14, types: 58, coercions: 0, joins: 0/0}
_TmMul
  :: forall (f1 :: * -> *) a1 (f2 :: * -> *) a2.
     Iso (MulF f2 a2) (MulF f1 a1) (f2 a2, f2 a2) (f1 a1, f1 a1)
_TmMul
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (f1 :: * -> *))
      (@ a1)
      (@ (p :: * -> * -> *))
      (@ (f2 :: * -> *))
      ($dProfunctor :: Profunctor p)
      ($dFunctor :: Functor f2) ->
      dimap $dProfunctor _Mul2 (fmap $dFunctor _Mul1)

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
_Mul4
  :: forall (tm :: (* -> *) -> * -> *) a. Term tm a -> Term tm a
_Mul4
  = \ (@ (tm :: (* -> *) -> * -> *)) (@ a) (x :: Term tm a) -> x

-- RHS size: {terms: 4, types: 14, coercions: 0, joins: 0/0}
_Mul3
  :: forall (tm :: (* -> *) -> * -> *) a.
     Unwrapped (Term tm a) -> Unwrapped (Term tm a)
_Mul3
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      (x :: Unwrapped (Term tm a)) ->
      x

-- RHS size: {terms: 36, types: 189, coercions: 383, joins: 0/5}
_Mul
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasMulF tm =>
     Prism' (Term tm a) (Term tm a, Term tm a)
_Mul
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasMulF :: HasMulF tm)
      (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        $dProfunctor :: Profunctor p
        $dProfunctor = $p1Choice $dChoice } in
      let {
        $dFunctor :: Functor f
        $dFunctor = $p1Applicative $dApplicative } in
      let {
        f1
          :: p (Unwrapped (Term tm a)) (f (Unwrapped (Term tm a)))
             -> p (Term tm a) (f (Term tm a))
        f1
          = dimap
              $dProfunctor
              (_Mul4 `cast` <Co:13>)
              (fmap $dFunctor (_Mul3 `cast` <Co:358>)) } in
      let {
        f2
          :: p (MulF (Term tm) a) (f (MulF (Term tm) a))
             -> p (tm (Term tm) a) (f (tm (Term tm) a))
        f2 = ($dHasMulF `cast` <Co:2>) $dChoice $dApplicative } in
      let {
        g :: p (Term tm a, Term tm a) (f (Term tm a, Term tm a))
             -> p (MulF (Term tm) a) (f (MulF (Term tm) a))
        g = dimap $dProfunctor _Mul2 (fmap $dFunctor _Mul1) } in
      \ (x :: p (Term tm a, Term tm a) (f (Term tm a, Term tm a))) ->
        f1 ((f2 (g x)) `cast` <Co:10>)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcConstraint []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcMulF1 :: KindRep
$tcMulF1 = KindRepFun krep$*Arr* krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcHasMulF1 :: KindRep
$tcHasMulF1 = KindRepFun $tcMulF1 $krep

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepApp $krep2 $krep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcMulF3 :: Addr#
$tcMulF3 = "MulF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcMulF2 :: TrName
$tcMulF2 = TrNameS $tcMulF3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcMulF :: TyCon
$tcMulF
  = TyCon
      4149507353333929091##
      1246214443398506002##
      $trModule
      $tcMulF2
      0#
      $tcMulF1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep4 :: [KindRep]
$krep4 = : $krep1 []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep5 :: [KindRep]
$krep5 = : $krep2 $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepTyConApp $tcMulF $krep5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7 :: KindRep
$krep7 = KindRepFun $krep3 $krep6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'TmMul1 :: KindRep
$tc'TmMul1 = KindRepFun $krep3 $krep7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'TmMul3 :: Addr#
$tc'TmMul3 = "'TmMul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'TmMul2 :: TrName
$tc'TmMul2 = TrNameS $tc'TmMul3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'TmMul :: TyCon
$tc'TmMul
  = TyCon
      14380589956823869737##
      11960804867761406589##
      $trModule
      $tc'TmMul2
      2#
      $tc'TmMul1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcHasMulF3 :: Addr#
$tcHasMulF3 = "HasMulF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcHasMulF2 :: TrName
$tcHasMulF2 = TrNameS $tcHasMulF3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcHasMulF :: TyCon
$tcHasMulF
  = TyCon
      12787519524745627131##
      12586991464795375984##
      $trModule
      $tcHasMulF2
      0#
      $tcHasMulF1



[ 5 of 20] Compiling Mul.Print        ( src/Mul/Print.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Mul/Print.o ) [Mul.Type changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 85, types: 291, coercions: 77, joins: 0/1}

-- RHS size: {terms: 4, types: 25, coercions: 0, joins: 0/0}
printRules5
  :: forall (f :: (* -> *) -> * -> *) a.
     Applicative (Const (First (Term f a, Term f a)))
printRules5
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) ->
      $fApplicativeConst $fMonoidFirst

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules4 :: Addr#
printRules4 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules3 :: Addr#
printRules3 = " * "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules2 :: Addr#
printRules2 = ")"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
printRules1 :: [Char]
printRules1 = unpackCString# printRules2

-- RHS size: {terms: 45, types: 154, coercions: 77, joins: 0/1}
$wprintRules
  :: forall (f :: (* -> *) -> * -> *) a.
     HasMulF f =>
     (# PrintRule (Term f a), [PrintRule (Term f a)] #)
$wprintRules
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (w :: HasMulF f) ->
      let {
        lvl
          :: ((Term f a, Term f a)
              -> Const (First (Term f a, Term f a)) (Term f a, Term f a))
             -> Term f a -> Const (First (Term f a, Term f a)) (Term f a)
        lvl = _Mul w $fChoice(->) printRules5 } in
      (# PrintRule
           (\ (p :: Term f a -> Maybe [Char]) (tm :: Term f a) ->
              case (lvl (Just `cast` <Co:45>) tm) `cast` <Co:32> of {
                Nothing -> Nothing;
                Just x ->
                  case x of { (tm1, tm2) ->
                  case p tm1 of {
                    Nothing -> Nothing;
                    Just x1 ->
                      case p tm2 of {
                        Nothing -> Nothing;
                        Just x2 ->
                          Just
                            (unpackAppendCString#
                               printRules4
                               (++ x1 (unpackAppendCString# printRules3 (++ x2 printRules1))))
                      }
                  }
                  }
              }),
         [] #)

-- RHS size: {terms: 10, types: 39, coercions: 0, joins: 0/0}
printRules
  :: forall (f :: (* -> *) -> * -> *) a.
     HasMulF f =>
     [PrintRule (Term f a)]
printRules
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (w :: HasMulF f) ->
      case $wprintRules w of { (# ww1, ww2 #) -> : ww1 ww2 }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[ 6 of 20] Compiling Mul              ( src/Mul.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Mul.o ) [Mul.Type changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 29, types: 84, coercions: 246, joins: 0/0}

-- RHS size: {terms: 12, types: 30, coercions: 113, joins: 0/0}
mul1
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasMulF tm =>
     Term tm a -> Term tm a -> Tagged (Term tm a) (Identity (Term tm a))
mul1
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasMulF :: HasMulF tm)
      (tm1 :: Term tm a)
      (tm2 :: Term tm a) ->
      _Mul
        $dHasMulF
        $fChoiceTagged
        $fApplicativeIdentity
        ((tm1, tm2) `cast` <Co:113>)

-- RHS size: {terms: 1, types: 0, coercions: 133, joins: 0/0}
mul
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasMulF tm =>
     Term tm a -> Term tm a -> Term tm a
mul = mul1 `cast` <Co:133>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[ 7 of 20] Compiling Base.Type        ( src/Base/Type.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Base/Type.o )

==================== Simplified expression ====================
makePrisms
  (mkNameG_tc
     (unpackCString# "initial-0.1.0.0-inplace"#)
     (unpackCString# "Base.Type"#)
     (unpackCString# "BaseF"#))



==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 735, types: 2,196, coercions: 1,260, joins: 0/12}

-- RHS size: {terms: 3, types: 10, coercions: 2, joins: 0/0}
_BaseF
  :: forall (tm :: (* -> *) -> * -> *).
     HasBaseF tm =>
     forall (f :: * -> *) a. Prism' (tm f a) (BaseF f a)
_BaseF
  = \ (@ (tm :: (* -> *) -> * -> *)) (v :: HasBaseF tm) ->
      v `cast` <Co:2>

-- RHS size: {terms: 7, types: 28, coercions: 0, joins: 0/0}
$fHasBaseFBaseF_$c_BaseF
  :: forall (f :: * -> *) a. Prism' (BaseF f a) (BaseF f a)
$fHasBaseFBaseF_$c_BaseF
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      _
      _ ->
      id

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fHasBaseFBaseF :: HasBaseF BaseF
$fHasBaseFBaseF = $fHasBaseFBaseF_$c_BaseF `cast` <Co:3>

-- RHS size: {terms: 16, types: 224, coercions: 225, joins: 0/0}
$fGenericBaseF_$cto
  :: forall (f :: * -> *) a x. Rep (BaseF f a) x -> BaseF f a
$fGenericBaseF_$cto
  = \ (@ (f :: * -> *)) (@ a) (@ x) (ds :: Rep (BaseF f a) x) ->
      case ds `cast` <Co:84> of {
        L1 ds1 -> TmLit (ds1 `cast` <Co:47>);
        R1 ds1 ->
          case ds1 `cast` <Co:44> of { :*: ds2 ds3 ->
          TmAdd (ds2 `cast` <Co:25>) (ds3 `cast` <Co:25>)
          }
      }

-- RHS size: {terms: 14, types: 191, coercions: 149, joins: 0/0}
$fGenericBaseF1
  :: forall (f :: * -> *) a x.
     BaseF f a
     -> (:+:)
          (M1
             C
             ('MetaCons "TmLit" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                (K1 R Int)))
          (M1
             C
             ('MetaCons "TmAdd" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                (K1 R (f a))
              :*: M1
                    S
                    ('MetaSel
                       'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                    (K1 R (f a))))
          x
$fGenericBaseF1
  = \ (@ (f :: * -> *)) (@ a) (@ x) (x1 :: BaseF f a) ->
      case x1 of {
        TmLit g1 -> L1 (g1 `cast` <Co:50>);
        TmAdd g1 g2 ->
          R1 ((:*: (g1 `cast` <Co:27>) (g2 `cast` <Co:27>)) `cast` <Co:45>)
      }

-- RHS size: {terms: 5, types: 13, coercions: 92, joins: 0/0}
$fGenericBaseF :: forall (f :: * -> *) a. Generic (BaseF f a)
$fGenericBaseF
  = \ (@ (f :: * -> *)) (@ a) ->
      C:Generic ($fGenericBaseF1 `cast` <Co:92>) $fGenericBaseF_$cto

-- RHS size: {terms: 18, types: 23, coercions: 6, joins: 0/0}
$fNFDataBaseF_$crnf
  :: forall (f :: * -> *) a. NFData (f a) => BaseF f a -> ()
$fNFDataBaseF_$crnf
  = \ (@ (f :: * -> *))
      (@ a)
      ($dNFData :: NFData (f a))
      (eta :: BaseF f a) ->
      case eta of {
        TmLit g1 -> case g1 of { I# ipv -> () };
        TmAdd g1 g2 ->
          case ($dNFData `cast` <Co:3>) g1 of { () ->
          ($dNFData `cast` <Co:3>) g2
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
$fNFDataBaseF
  :: forall (f :: * -> *) a. NFData (f a) => NFData (BaseF f a)
$fNFDataBaseF = $fNFDataBaseF_$crnf `cast` <Co:17>

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowBaseF3 :: Int
$fShowBaseF3 = I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowBaseF4 :: Addr#
$fShowBaseF4 = "TmLit "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowBaseF2 :: Addr#
$fShowBaseF2 = "TmAdd "#

-- RHS size: {terms: 87, types: 67, coercions: 0, joins: 0/2}
$w$cshowsPrec
  :: forall (f :: * -> *) a. Show (f a) => Int# -> BaseF f a -> ShowS
$w$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (ww :: Int#)
      (w1 :: BaseF f a) ->
      case w1 of {
        TmLit b1 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              \ (x :: String) ->
                unpackAppendCString#
                  $fShowBaseF4
                  (case b1 of { I# ww3 ->
                   case $wshowSignedInt 11# ww3 x of { (# ww5, ww6 #) -> : ww5 ww6 }
                   });
            True ->
              \ (x :: String) ->
                : $fShow(,)4
                  (unpackAppendCString#
                     $fShowBaseF4
                     (case b1 of { I# ww3 ->
                      case $wshowSignedInt 11# ww3 (: $fShow(,)2 x) of
                      { (# ww5, ww6 #) ->
                      : ww5 ww6
                      }
                      }))
          };
        TmAdd b1 b2 ->
          let {
            f1 :: String -> String
            f1 = showsPrec w $fShowBaseF3 b1 } in
          let {
            g :: String -> String
            g = showsPrec w $fShowBaseF3 b2 } in
          case tagToEnum# (>=# ww 11#) of {
            False ->
              \ (x :: String) ->
                unpackAppendCString# $fShowBaseF2 (f1 (: showSpace1 (g x)));
            True ->
              \ (x :: String) ->
                : $fShow(,)4
                  (unpackAppendCString#
                     $fShowBaseF2 (f1 (: showSpace1 (g (: $fShow(,)2 x)))))
          }
      }

-- RHS size: {terms: 12, types: 17, coercions: 0, joins: 0/0}
$fShowBaseF_$cshowsPrec
  :: forall (f :: * -> *) a. Show (f a) => Int -> BaseF f a -> ShowS
$fShowBaseF_$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (w1 :: Int)
      (w2 :: BaseF f a) ->
      case w1 of { I# ww1 -> $w$cshowsPrec w ww1 w2 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowBaseF1 :: Int
$fShowBaseF1 = I# 0#

-- RHS size: {terms: 9, types: 15, coercions: 0, joins: 0/0}
$fShowBaseF_$cshow
  :: forall (f :: * -> *) a. Show (f a) => BaseF f a -> String
$fShowBaseF_$cshow
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (x :: BaseF f a) ->
      $w$cshowsPrec $dShow 0# x []

-- RHS size: {terms: 13, types: 22, coercions: 0, joins: 0/0}
$fShowBaseF_$cshowList
  :: forall (f :: * -> *) a. Show (f a) => [BaseF f a] -> ShowS
$fShowBaseF_$cshowList
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (eta :: [BaseF f a])
      (eta1 :: String) ->
      showList__
        (\ (w :: BaseF f a) -> $w$cshowsPrec $dShow 0# w) eta eta1

-- RHS size: {terms: 10, types: 18, coercions: 0, joins: 0/0}
$fShowBaseF
  :: forall (f :: * -> *) a. Show (f a) => Show (BaseF f a)
$fShowBaseF
  = \ (@ (f :: * -> *)) (@ a) ($dShow :: Show (f a)) ->
      C:Show
        ($fShowBaseF_$cshowsPrec $dShow)
        ($fShowBaseF_$cshow $dShow)
        ($fShowBaseF_$cshowList $dShow)

-- RHS size: {terms: 36, types: 44, coercions: 0, joins: 0/0}
$fOrdBaseF_$c<
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> Bool
$fOrdBaseF_$c<
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: BaseF f a)
      (b :: BaseF f a) ->
      case a1 of {
        TmLit a2 ->
          case b of {
            TmLit b1 -> ltInt a2 b1;
            TmAdd ipv ipv1 -> True
          };
        TmAdd a2 a3 ->
          case b of {
            TmLit ipv -> False;
            TmAdd b1 b2 ->
              case compare $dOrd a2 b1 of {
                LT -> True;
                EQ -> < $dOrd a3 b2;
                GT -> False
              }
          }
      }

-- RHS size: {terms: 36, types: 44, coercions: 0, joins: 0/0}
$fOrdBaseF_$ccompare
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> Ordering
$fOrdBaseF_$ccompare
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: BaseF f a)
      (b :: BaseF f a) ->
      case a1 of {
        TmLit a2 ->
          case b of {
            TmLit b1 -> compareInt a2 b1;
            TmAdd ipv ipv1 -> LT
          };
        TmAdd a2 a3 ->
          case b of {
            TmLit ipv -> GT;
            TmAdd b1 b2 ->
              case compare $dOrd a2 b1 of {
                LT -> LT;
                EQ -> compare $dOrd a3 b2;
                GT -> GT
              }
          }
      }

-- RHS size: {terms: 34, types: 44, coercions: 0, joins: 0/0}
$fEqBaseF_$c==
  :: forall (f :: * -> *) a.
     Eq (f a) =>
     BaseF f a -> BaseF f a -> Bool
$fEqBaseF_$c==
  = \ (@ (f :: * -> *))
      (@ a)
      ($dEq :: Eq (f a))
      (ds :: BaseF f a)
      (ds1 :: BaseF f a) ->
      case ds of {
        TmLit a1 ->
          case ds1 of {
            TmLit b1 -> eqInt a1 b1;
            TmAdd ipv ipv1 -> False
          };
        TmAdd a1 a2 ->
          case ds1 of {
            TmLit ipv -> False;
            TmAdd b1 b2 ->
              case == $dEq a1 b1 of {
                False -> False;
                True -> == $dEq a2 b2
              }
          }
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fEqBaseF_$c/=
  :: forall (f :: * -> *) a.
     Eq (f a) =>
     BaseF f a -> BaseF f a -> Bool
$fEqBaseF_$c/=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dEq :: Eq (f a))
      (a1 :: BaseF f a)
      (b :: BaseF f a) ->
      case $fEqBaseF_$c== $dEq a1 b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 8, types: 16, coercions: 0, joins: 0/0}
$fEqBaseF :: forall (f :: * -> *) a. Eq (f a) => Eq (BaseF f a)
$fEqBaseF
  = \ (@ (f :: * -> *)) (@ a) ($dEq :: Eq (f a)) ->
      C:Eq ($fEqBaseF_$c== $dEq) ($fEqBaseF_$c/= $dEq)

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
$fOrdBaseF_$cp1Ord
  :: forall (f :: * -> *) a. Ord (f a) => Eq (BaseF f a)
$fOrdBaseF_$cp1Ord
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      $fEqBaseF ($p1Ord $dOrd)

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdBaseF_$c<=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> Bool
$fOrdBaseF_$c<=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: BaseF f a)
      (b :: BaseF f a) ->
      case $fOrdBaseF_$c< $dOrd b a1 of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdBaseF_$cmax
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> BaseF f a
$fOrdBaseF_$cmax
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (x :: BaseF f a)
      (y :: BaseF f a) ->
      case $fOrdBaseF_$c< $dOrd y x of {
        False -> y;
        True -> x
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdBaseF_$c>=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> Bool
$fOrdBaseF_$c>=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: BaseF f a)
      (b :: BaseF f a) ->
      case $fOrdBaseF_$c< $dOrd a1 b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdBaseF_$cmin
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> BaseF f a
$fOrdBaseF_$cmin
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (x :: BaseF f a)
      (y :: BaseF f a) ->
      case $fOrdBaseF_$c< $dOrd y x of {
        False -> x;
        True -> y
      }

-- RHS size: {terms: 24, types: 34, coercions: 0, joins: 0/0}
$fOrdBaseF :: forall (f :: * -> *) a. Ord (f a) => Ord (BaseF f a)
$fOrdBaseF
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      C:Ord
        ($fOrdBaseF_$cp1Ord $dOrd)
        ($fOrdBaseF_$ccompare $dOrd)
        ($fOrdBaseF_$c< $dOrd)
        ($fOrdBaseF_$c<= $dOrd)
        (\ (a1 :: BaseF f a) (b :: BaseF f a) -> $fOrdBaseF_$c< $dOrd b a1)
        ($fOrdBaseF_$c>= $dOrd)
        ($fOrdBaseF_$cmax $dOrd)
        ($fOrdBaseF_$cmin $dOrd)

-- RHS size: {terms: 11, types: 25, coercions: 0, joins: 0/0}
_TmLit1
  :: forall (f :: * -> *) a. BaseF f a -> Either (BaseF f a) Int
_TmLit1
  = \ (@ (f :: * -> *)) (@ a) (x :: BaseF f a) ->
      case x of wild {
        TmLit y1 -> Right y1;
        TmAdd ipv ipv1 -> Left wild
      }

-- RHS size: {terms: 31, types: 108, coercions: 0, joins: 0/2}
_TmLit :: forall (f :: * -> *) a. Prism' (BaseF f a) Int
_TmLit
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f1) ->
      let {
        f2
          :: p (Either (BaseF f a) Int) (Either (BaseF f a) (f1 Int))
             -> p (BaseF f a) (f1 (BaseF f a))
        f2
          = dimap
              ($p1Choice $dChoice)
              _TmLit1
              (let {
                 ds :: f1 Int -> f1 (BaseF f a)
                 ds = fmap ($p1Applicative $dApplicative) TmLit } in
               \ (ds1 :: Either (BaseF f a) (f1 Int)) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p Int (f1 Int)) -> f2 (right' $dChoice x)

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
_Add2
  :: forall (tm :: (* -> *) -> * -> *) a. Term tm a -> Term tm a
_Add2
  = \ (@ (tm :: (* -> *) -> * -> *)) (@ a) (x :: Term tm a) -> x

-- RHS size: {terms: 4, types: 14, coercions: 0, joins: 0/0}
_Add1
  :: forall (tm :: (* -> *) -> * -> *) a.
     Unwrapped (Term tm a) -> Unwrapped (Term tm a)
_Add1
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      (x :: Unwrapped (Term tm a)) ->
      x

-- RHS size: {terms: 29, types: 123, coercions: 383, joins: 0/3}
_Lit
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Prism' (Term tm a) Int
_Lit
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm)
      (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1
          :: p (Unwrapped (Term tm a)) (f (Unwrapped (Term tm a)))
             -> p (Term tm a) (f (Term tm a))
        f1
          = dimap
              ($p1Choice $dChoice)
              (_Add2 `cast` <Co:13>)
              (fmap ($p1Applicative $dApplicative) (_Add1 `cast` <Co:358>)) } in
      let {
        f2
          :: p (BaseF (Term tm) a) (f (BaseF (Term tm) a))
             -> p (tm (Term tm) a) (f (tm (Term tm) a))
        f2 = ($dHasBaseF `cast` <Co:2>) $dChoice $dApplicative } in
      let {
        g :: p Int (f Int) -> p (BaseF (Term tm) a) (f (BaseF (Term tm) a))
        g = _TmLit $dChoice $dApplicative } in
      \ (x :: p Int (f Int)) -> f1 ((f2 (g x)) `cast` <Co:10>)

-- RHS size: {terms: 16, types: 45, coercions: 0, joins: 0/0}
_TmAdd2
  :: forall (f1 :: * -> *) a1 (f2 :: * -> *) a2.
     BaseF f1 a1 -> Either (BaseF f2 a2) (f1 a1, f1 a1)
_TmAdd2
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (f1 :: * -> *))
      (@ a1)
      (x :: BaseF f a) ->
      case x of {
        TmLit y1 -> Left (TmLit y1);
        TmAdd y1 y2 -> Right (y1, y2)
      }

-- RHS size: {terms: 9, types: 22, coercions: 0, joins: 0/0}
_TmAdd1 :: forall (f :: * -> *) a. (f a, f a) -> BaseF f a
_TmAdd1
  = \ (@ (f :: * -> *)) (@ a) (ds :: (f a, f a)) ->
      case ds of { (x1, x2) -> TmAdd x1 x2 }

-- RHS size: {terms: 33, types: 168, coercions: 0, joins: 0/2}
_TmAdd
  :: forall (f1 :: * -> *) a1 (f2 :: * -> *) a2.
     Prism (BaseF f2 a2) (BaseF f1 a1) (f2 a2, f2 a2) (f1 a1, f1 a1)
_TmAdd
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (f1 :: * -> *))
      (@ a1)
      (@ (p :: * -> * -> *))
      (@ (f2 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f2) ->
      let {
        f3
          :: p (Either (BaseF f a) (f1 a1, f1 a1)) (Either
                                                      (BaseF f a) (f2 (f a, f a)))
             -> p (BaseF f1 a1) (f2 (BaseF f a))
        f3
          = dimap
              ($p1Choice $dChoice)
              _TmAdd2
              (let {
                 ds :: f2 (f a, f a) -> f2 (BaseF f a)
                 ds = fmap ($p1Applicative $dApplicative) _TmAdd1 } in
               \ (ds1 :: Either (BaseF f a) (f2 (f a, f a))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (f1 a1, f1 a1) (f2 (f a, f a))) -> f3 (right' $dChoice x)

-- RHS size: {terms: 29, types: 150, coercions: 383, joins: 0/3}
_Add
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Prism' (Term tm a) (Term tm a, Term tm a)
_Add
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm)
      (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1
          :: p (Unwrapped (Term tm a)) (f (Unwrapped (Term tm a)))
             -> p (Term tm a) (f (Term tm a))
        f1
          = dimap
              ($p1Choice $dChoice)
              (_Add2 `cast` <Co:13>)
              (fmap ($p1Applicative $dApplicative) (_Add1 `cast` <Co:358>)) } in
      let {
        f2
          :: p (BaseF (Term tm) a) (f (BaseF (Term tm) a))
             -> p (tm (Term tm) a) (f (tm (Term tm) a))
        f2 = ($dHasBaseF `cast` <Co:2>) $dChoice $dApplicative } in
      let {
        g :: p (Term tm a, Term tm a) (f (Term tm a, Term tm a))
             -> p (BaseF (Term tm) a) (f (BaseF (Term tm) a))
        g = _TmAdd $dChoice $dApplicative } in
      \ (x :: p (Term tm a, Term tm a) (f (Term tm a, Term tm a))) ->
        f1 ((f2 (g x)) `cast` <Co:10>)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepTyConApp $tcConstraint []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcBaseF1 :: KindRep
$tcBaseF1 = KindRepFun krep$*Arr* krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcHasBaseF1 :: KindRep
$tcHasBaseF1 = KindRepFun $tcBaseF1 $krep1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepApp $krep3 $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcBaseF3 :: Addr#
$tcBaseF3 = "BaseF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcBaseF2 :: TrName
$tcBaseF2 = TrNameS $tcBaseF3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcBaseF :: TyCon
$tcBaseF
  = TyCon
      5710402104387038467##
      1385426594668003690##
      $trModule
      $tcBaseF2
      0#
      $tcBaseF1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep5 :: [KindRep]
$krep5 = : $krep2 []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep6 :: [KindRep]
$krep6 = : $krep3 $krep5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7 :: KindRep
$krep7 = KindRepTyConApp $tcBaseF $krep6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8 :: KindRep
$krep8 = KindRepFun $krep4 $krep7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'TmAdd1 :: KindRep
$tc'TmAdd1 = KindRepFun $krep4 $krep8

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'TmAdd3 :: Addr#
$tc'TmAdd3 = "'TmAdd"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'TmAdd2 :: TrName
$tc'TmAdd2 = TrNameS $tc'TmAdd3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'TmAdd :: TyCon
$tc'TmAdd
  = TyCon
      18055387651722055321##
      14156134494288808707##
      $trModule
      $tc'TmAdd2
      2#
      $tc'TmAdd1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'TmLit1 :: KindRep
$tc'TmLit1 = KindRepFun $krep $krep7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'TmLit3 :: Addr#
$tc'TmLit3 = "'TmLit"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'TmLit2 :: TrName
$tc'TmLit2 = TrNameS $tc'TmLit3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'TmLit :: TyCon
$tc'TmLit
  = TyCon
      1739297698197566515##
      4377365426959515487##
      $trModule
      $tc'TmLit2
      2#
      $tc'TmLit1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcHasBaseF3 :: Addr#
$tcHasBaseF3 = "HasBaseF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcHasBaseF2 :: TrName
$tcHasBaseF2 = TrNameS $tcHasBaseF3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcHasBaseF :: TyCon
$tcHasBaseF
  = TyCon
      3644673707559412914##
      8728320531909697975##
      $trModule
      $tcHasBaseF2
      0#
      $tcHasBaseF1



[ 8 of 20] Compiling Mul.Eval         ( src/Mul/Eval.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Mul/Eval.o ) [Base.Type changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 128, types: 432, coercions: 1,042, joins: 0/0}

-- RHS size: {terms: 7, types: 17, coercions: 12, joins: 0/0}
lvl
  :: forall a b.
     Const (First Int) a -> Const (First Int) b -> First Int
lvl
  = \ (@ a)
      (@ b)
      (ds :: Const (First Int) a)
      (ds1 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds `cast` <Co:6>) (ds1 `cast` <Co:6>)

-- RHS size: {terms: 9, types: 22, coercions: 12, joins: 0/0}
lvl1
  :: forall a b c.
     (a -> b -> c)
     -> Const (First Int) a -> Const (First Int) b -> First Int
lvl1
  = \ (@ a)
      (@ b)
      (@ c)
      _
      (ds1 :: Const (First Int) a)
      (ds2 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds1 `cast` <Co:6>) (ds2 `cast` <Co:6>)

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl2 :: forall a. a -> Maybe Int
lvl2 = \ (@ a) _ -> Nothing

-- RHS size: {terms: 9, types: 12, coercions: 136, joins: 0/0}
$s$fApplicativeConst :: Applicative (Const (First Int))
$s$fApplicativeConst
  = C:Applicative
      $fFunctorConst
      (lvl2 `cast` <Co:18>)
      ((\ (@ a) (@ b) -> $fMonoidFirst_$cmappend) `cast` <Co:30>)
      (lvl1 `cast` <Co:34>)
      (lvl `cast` <Co:27>)
      (lvl `cast` <Co:27>)

-- RHS size: {terms: 10, types: 27, coercions: 48, joins: 0/0}
evalRules2
  :: forall (f :: (* -> *) -> * -> *) a.
     BaseF (Term f) a -> Const (First Int) (BaseF (Term f) a)
evalRules2
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (x :: BaseF (Term f) a) ->
      case x of {
        TmLit y1 -> (Just y1) `cast` <Co:34>;
        TmAdd ipv ipv1 -> Nothing `cast` <Co:14>
      }

-- RHS size: {terms: 4, types: 25, coercions: 0, joins: 0/0}
evalRules3
  :: forall (f :: (* -> *) -> * -> *) a.
     Applicative (Const (First (Term f a, Term f a)))
evalRules3
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) ->
      $fApplicativeConst $fMonoidFirst

-- RHS size: {terms: 53, types: 128, coercions: 806, joins: 0/0}
evalRules1
  :: forall (f :: (* -> *) -> * -> *) a.
     (HasBaseF f, HasMulF f) =>
     forall r.
     (Term f a -> Term f a)
     -> (Term f a -> r) -> (Term f a -> r) -> Term f a -> r
evalRules1
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF f)
      ($dHasMulF :: HasMulF f)
      (@ r)
      (e :: Term f a -> Term f a)
      (good :: Term f a -> r)
      (bad :: Term f a -> r)
      (tm :: Term f a) ->
      case (_Mul
              $dHasMulF $fChoice(->) evalRules3 (Just `cast` <Co:45>) tm)
           `cast` <Co:32>
      of {
        Nothing -> bad tm;
        Just x ->
          case x of { (tm1, tm2) ->
          case (($dHasBaseF `cast` <Co:2>)
                  $fChoice(->)
                  $s$fApplicativeConst
                  evalRules2
                  ((e tm1) `cast` <Co:26>))
               `cast` <Co:48>
          of {
            Nothing -> bad tm;
            Just x1 ->
              case (($dHasBaseF `cast` <Co:2>)
                      $fChoice(->)
                      $s$fApplicativeConst
                      evalRules2
                      ((e tm2) `cast` <Co:26>))
                   `cast` <Co:48>
              of {
                Nothing -> bad tm;
                Just x2 ->
                  good
                    ((($dHasBaseF `cast` <Co:2>)
                        $fChoiceTagged
                        $fApplicativeIdentity
                        ((TmLit ($fNumInt_$c* x1 x2)) `cast` <Co:45>))
                     `cast` <Co:530>)
              }
          }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 23, joins: 0/0}
mulRule
  :: forall (f :: (* -> *) -> * -> *) a.
     (HasBaseF f, HasMulF f) =>
     EvalRule (Term f a)
mulRule = evalRules1 `cast` <Co:23>

-- RHS size: {terms: 9, types: 24, coercions: 5, joins: 0/0}
evalRules
  :: forall (f :: (* -> *) -> * -> *) a.
     (HasBaseF f, HasMulF f) =>
     [EvalRule (Term f a)]
evalRules
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF f)
      ($dHasMulF :: HasMulF f) ->
      : ((evalRules1 $dHasBaseF $dHasMulF) `cast` <Co:5>) []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1


------ Local rules for imported ids --------
"SPEC/Mul.Eval $fApplicativeConst @ (First Int)"
    forall (v :: Monoid (First Int)).
      $fApplicativeConst v
      = $s$fApplicativeConst


[ 9 of 20] Compiling Example.Term.BaseMul.Type ( src/Example/Term/BaseMul/Type.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/BaseMul/Type.o )

==================== Simplified expression ====================
makePrisms
  (mkNameG_tc
     (unpackCString# "initial-0.1.0.0-inplace"#)
     (unpackCString# "Example.Term.BaseMul.Type"#)
     (unpackCString# "TermF"#))



==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 576, types: 1,502, coercions: 385, joins: 0/6}

-- RHS size: {terms: 12, types: 122, coercions: 174, joins: 0/0}
$fGenericTermF_$cto
  :: forall (f :: * -> *) a x. Rep (TermF f a) x -> TermF f a
$fGenericTermF_$cto
  = \ (@ (f :: * -> *)) (@ a) (@ x) (ds :: Rep (TermF f a) x) ->
      case ds `cast` <Co:68> of {
        L1 ds1 -> BMBase (ds1 `cast` <Co:53>);
        R1 ds1 -> BMMul (ds1 `cast` <Co:53>)
      }

-- RHS size: {terms: 12, types: 125, coercions: 112, joins: 0/0}
$fGenericTermF1
  :: forall (f :: * -> *) a x.
     TermF f a
     -> (:+:)
          (M1
             C
             ('MetaCons "BMBase" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                (K1 R (BaseF f a))))
          (M1
             C
             ('MetaCons "BMMul" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                (K1 R (MulF f a))))
          x
$fGenericTermF1
  = \ (@ (f :: * -> *)) (@ a) (@ x) (x1 :: TermF f a) ->
      case x1 of {
        BMBase g1 -> L1 (g1 `cast` <Co:56>);
        BMMul g1 -> R1 (g1 `cast` <Co:56>)
      }

-- RHS size: {terms: 5, types: 13, coercions: 76, joins: 0/0}
$fGenericTermF :: forall (f :: * -> *) a. Generic (TermF f a)
$fGenericTermF
  = \ (@ (f :: * -> *)) (@ a) ->
      C:Generic ($fGenericTermF1 `cast` <Co:76>) $fGenericTermF_$cto

-- RHS size: {terms: 14, types: 25, coercions: 0, joins: 0/0}
$fNFDataTermF_$crnf
  :: forall (f :: * -> *) a. NFData (f a) => TermF f a -> ()
$fNFDataTermF_$crnf
  = \ (@ (f :: * -> *))
      (@ a)
      ($dNFData :: NFData (f a))
      (eta :: TermF f a) ->
      case eta of {
        BMBase g1 -> $fNFDataBaseF_$crnf $dNFData g1;
        BMMul g1 -> $fNFDataMulF_$crnf $dNFData g1
      }

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
$fNFDataTermF
  :: forall (f :: * -> *) a. NFData (f a) => NFData (TermF f a)
$fNFDataTermF = $fNFDataTermF_$crnf `cast` <Co:17>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowTermF5 :: Addr#
$fShowTermF5 = "BMBase "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTermF4 :: [Char]
$fShowTermF4 = unpackCString# $fShowTermF5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowTermF3 :: Addr#
$fShowTermF3 = "BMMul "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTermF2 :: [Char]
$fShowTermF2 = unpackCString# $fShowTermF3

-- RHS size: {terms: 65, types: 53, coercions: 0, joins: 0/2}
$w$cshowsPrec
  :: forall (f :: * -> *) a. Show (f a) => Int# -> TermF f a -> ShowS
$w$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (ww :: Int#)
      (w1 :: TermF f a) ->
      case w1 of {
        BMBase b1 ->
          let {
            g :: String -> String
            g = $w$cshowsPrec w 11# b1 } in
          case tagToEnum# (>=# ww 11#) of {
            False -> \ (x :: String) -> ++ $fShowTermF4 (g x);
            True ->
              \ (x :: String) ->
                : $fShow(,)4 (++ $fShowTermF4 (g (: $fShow(,)2 x)))
          };
        BMMul b1 ->
          let {
            g :: String -> String
            g = case b1 of { TmMul ww3 ww4 ->
                $w$cshowsPrec w 11# ww3 ww4
                } } in
          case tagToEnum# (>=# ww 11#) of {
            False -> \ (x :: String) -> ++ $fShowTermF2 (g x);
            True ->
              \ (x :: String) ->
                : $fShow(,)4 (++ $fShowTermF2 (g (: $fShow(,)2 x)))
          }
      }

-- RHS size: {terms: 12, types: 17, coercions: 0, joins: 0/0}
$fShowTermF_$cshowsPrec
  :: forall (f :: * -> *) a. Show (f a) => Int -> TermF f a -> ShowS
$fShowTermF_$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (w1 :: Int)
      (w2 :: TermF f a) ->
      case w1 of { I# ww1 -> $w$cshowsPrec w ww1 w2 }

-- RHS size: {terms: 26, types: 36, coercions: 0, joins: 0/0}
$fShowTermF_$cshow
  :: forall (f :: * -> *) a. Show (f a) => TermF f a -> String
$fShowTermF_$cshow
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (x :: TermF f a) ->
      case x of {
        BMBase b1 -> ++ $fShowTermF4 ($w$cshowsPrec $dShow 11# b1 []);
        BMMul b1 ->
          ++
            $fShowTermF2
            (case b1 of { TmMul ww3 ww4 ->
             $w$cshowsPrec $dShow 11# ww3 ww4 []
             })
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTermF1 :: Int
$fShowTermF1 = I# 0#

-- RHS size: {terms: 13, types: 22, coercions: 0, joins: 0/0}
$fShowTermF_$cshowList
  :: forall (f :: * -> *) a. Show (f a) => [TermF f a] -> ShowS
$fShowTermF_$cshowList
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (eta :: [TermF f a])
      (eta1 :: String) ->
      showList__
        (\ (w :: TermF f a) -> $w$cshowsPrec $dShow 0# w) eta eta1

-- RHS size: {terms: 10, types: 18, coercions: 0, joins: 0/0}
$fShowTermF
  :: forall (f :: * -> *) a. Show (f a) => Show (TermF f a)
$fShowTermF
  = \ (@ (f :: * -> *)) (@ a) ($dShow :: Show (f a)) ->
      C:Show
        ($fShowTermF_$cshowsPrec $dShow)
        ($fShowTermF_$cshow $dShow)
        ($fShowTermF_$cshowList $dShow)

-- RHS size: {terms: 27, types: 46, coercions: 0, joins: 0/0}
$fOrdTermF_$c<
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> Bool
$fOrdTermF_$c<
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: TermF f a)
      (b :: TermF f a) ->
      case a1 of {
        BMBase a2 ->
          case b of {
            BMBase b1 -> $fOrdBaseF_$c< $dOrd a2 b1;
            BMMul ipv -> True
          };
        BMMul a2 ->
          case b of {
            BMBase ipv -> False;
            BMMul b1 -> $fOrdMulF_$c< $dOrd a2 b1
          }
      }

-- RHS size: {terms: 27, types: 46, coercions: 0, joins: 0/0}
$fOrdTermF_$ccompare
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> Ordering
$fOrdTermF_$ccompare
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: TermF f a)
      (b :: TermF f a) ->
      case a1 of {
        BMBase a2 ->
          case b of {
            BMBase b1 -> $fOrdBaseF_$ccompare $dOrd a2 b1;
            BMMul ipv -> LT
          };
        BMMul a2 ->
          case b of {
            BMBase ipv -> GT;
            BMMul b1 -> $fOrdMulF_$ccompare $dOrd a2 b1
          }
      }

-- RHS size: {terms: 27, types: 46, coercions: 0, joins: 0/0}
$fEqTermF_$c==
  :: forall (f :: * -> *) a.
     Eq (f a) =>
     TermF f a -> TermF f a -> Bool
$fEqTermF_$c==
  = \ (@ (f :: * -> *))
      (@ a)
      ($dEq :: Eq (f a))
      (ds :: TermF f a)
      (ds1 :: TermF f a) ->
      case ds of {
        BMBase a1 ->
          case ds1 of {
            BMBase b1 -> $fEqBaseF_$c== $dEq a1 b1;
            BMMul ipv -> False
          };
        BMMul a1 ->
          case ds1 of {
            BMBase ipv -> False;
            BMMul b1 -> $fEqMulF_$c== $dEq a1 b1
          }
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fEqTermF_$c/=
  :: forall (f :: * -> *) a.
     Eq (f a) =>
     TermF f a -> TermF f a -> Bool
$fEqTermF_$c/=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dEq :: Eq (f a))
      (a1 :: TermF f a)
      (b :: TermF f a) ->
      case $fEqTermF_$c== $dEq a1 b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 8, types: 16, coercions: 0, joins: 0/0}
$fEqTermF :: forall (f :: * -> *) a. Eq (f a) => Eq (TermF f a)
$fEqTermF
  = \ (@ (f :: * -> *)) (@ a) ($dEq :: Eq (f a)) ->
      C:Eq ($fEqTermF_$c== $dEq) ($fEqTermF_$c/= $dEq)

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
$fOrdTermF_$cp1Ord
  :: forall (f :: * -> *) a. Ord (f a) => Eq (TermF f a)
$fOrdTermF_$cp1Ord
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      $fEqTermF ($p1Ord $dOrd)

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdTermF_$c<=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> Bool
$fOrdTermF_$c<=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: TermF f a)
      (b :: TermF f a) ->
      case $fOrdTermF_$c< $dOrd b a1 of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdTermF_$cmax
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> TermF f a
$fOrdTermF_$cmax
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (x :: TermF f a)
      (y :: TermF f a) ->
      case $fOrdTermF_$c< $dOrd y x of {
        False -> y;
        True -> x
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdTermF_$c>=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> Bool
$fOrdTermF_$c>=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: TermF f a)
      (b :: TermF f a) ->
      case $fOrdTermF_$c< $dOrd a1 b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdTermF_$cmin
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> TermF f a
$fOrdTermF_$cmin
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (x :: TermF f a)
      (y :: TermF f a) ->
      case $fOrdTermF_$c< $dOrd y x of {
        False -> x;
        True -> y
      }

-- RHS size: {terms: 24, types: 34, coercions: 0, joins: 0/0}
$fOrdTermF :: forall (f :: * -> *) a. Ord (f a) => Ord (TermF f a)
$fOrdTermF
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      C:Ord
        ($fOrdTermF_$cp1Ord $dOrd)
        ($fOrdTermF_$ccompare $dOrd)
        ($fOrdTermF_$c< $dOrd)
        ($fOrdTermF_$c<= $dOrd)
        (\ (a1 :: TermF f a) (b :: TermF f a) -> $fOrdTermF_$c< $dOrd b a1)
        ($fOrdTermF_$c>= $dOrd)
        ($fOrdTermF_$cmax $dOrd)
        ($fOrdTermF_$cmin $dOrd)

-- RHS size: {terms: 11, types: 30, coercions: 0, joins: 0/0}
_BMBase1
  :: forall (f :: * -> *) a.
     TermF f a -> Either (TermF f a) (BaseF f a)
_BMBase1
  = \ (@ (f :: * -> *)) (@ a) (x :: TermF f a) ->
      case x of wild {
        BMBase y1 -> Right y1;
        BMMul ipv -> Left wild
      }

-- RHS size: {terms: 31, types: 134, coercions: 0, joins: 0/2}
_BMBase :: forall (f :: * -> *) a. Prism' (TermF f a) (BaseF f a)
_BMBase
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f1) ->
      let {
        f2
          :: p (Either (TermF f a) (BaseF f a)) (Either
                                                   (TermF f a) (f1 (BaseF f a)))
             -> p (TermF f a) (f1 (TermF f a))
        f2
          = dimap
              ($p1Choice $dChoice)
              _BMBase1
              (let {
                 ds :: f1 (BaseF f a) -> f1 (TermF f a)
                 ds = fmap ($p1Applicative $dApplicative) BMBase } in
               \ (ds1 :: Either (TermF f a) (f1 (BaseF f a))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (BaseF f a) (f1 (BaseF f a))) -> f2 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fHasBaseFTermF :: HasBaseF TermF
$fHasBaseFTermF = _BMBase `cast` <Co:3>

-- RHS size: {terms: 11, types: 30, coercions: 0, joins: 0/0}
_BMMul1
  :: forall (f :: * -> *) a.
     TermF f a -> Either (TermF f a) (MulF f a)
_BMMul1
  = \ (@ (f :: * -> *)) (@ a) (x :: TermF f a) ->
      case x of wild {
        BMBase ipv -> Left wild;
        BMMul y1 -> Right y1
      }

-- RHS size: {terms: 31, types: 134, coercions: 0, joins: 0/2}
_BMMul :: forall (f :: * -> *) a. Prism' (TermF f a) (MulF f a)
_BMMul
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f1) ->
      let {
        f2
          :: p (Either (TermF f a) (MulF f a)) (Either
                                                  (TermF f a) (f1 (MulF f a)))
             -> p (TermF f a) (f1 (TermF f a))
        f2
          = dimap
              ($p1Choice $dChoice)
              _BMMul1
              (let {
                 ds :: f1 (MulF f a) -> f1 (TermF f a)
                 ds = fmap ($p1Applicative $dApplicative) BMMul } in
               \ (ds1 :: Either (TermF f a) (f1 (MulF f a))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (MulF f a) (f1 (MulF f a))) -> f2 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fHasMulFTermF :: HasMulF TermF
$fHasMulFTermF = _BMMul `cast` <Co:3>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.BaseMul.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcTermF1 :: KindRep
$tcTermF1 = KindRepFun krep$*Arr* krep$*Arr*

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepVar 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep2 :: [KindRep]
$krep2 = : $krep []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3 :: [KindRep]
$krep3 = : $krep1 $krep2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepTyConApp $tcBaseF $krep3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepTyConApp $tcMulF $krep3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcTermF3 :: Addr#
$tcTermF3 = "TermF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcTermF2 :: TrName
$tcTermF2 = TrNameS $tcTermF3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcTermF :: TyCon
$tcTermF
  = TyCon
      3926542919675209495##
      15495442658314935867##
      $trModule
      $tcTermF2
      0#
      $tcTermF1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepTyConApp $tcTermF $krep3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'BMBase1 :: KindRep
$tc'BMBase1 = KindRepFun $krep4 $krep6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'BMBase3 :: Addr#
$tc'BMBase3 = "'BMBase"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'BMBase2 :: TrName
$tc'BMBase2 = TrNameS $tc'BMBase3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'BMBase :: TyCon
$tc'BMBase
  = TyCon
      6418924972322557299##
      4094132794458399817##
      $trModule
      $tc'BMBase2
      2#
      $tc'BMBase1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'BMMul1 :: KindRep
$tc'BMMul1 = KindRepFun $krep5 $krep6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'BMMul3 :: Addr#
$tc'BMMul3 = "'BMMul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'BMMul2 :: TrName
$tc'BMMul2 = TrNameS $tc'BMMul3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'BMMul :: TyCon
$tc'BMMul
  = TyCon
      6924412029024001015##
      14813373258268439940##
      $trModule
      $tc'BMMul2
      2#
      $tc'BMMul1



[10 of 20] Compiling Example.Term.Base.Type ( src/Example/Term/Base/Type.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/Base/Type.o ) [Base.Type changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.Base.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[11 of 20] Compiling Base.Print       ( src/Base/Print.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Base/Print.o ) [Base.Type changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 154, types: 509, coercions: 504, joins: 0/0}

-- RHS size: {terms: 7, types: 17, coercions: 12, joins: 0/0}
lvl
  :: forall a b.
     Const (First Int) a -> Const (First Int) b -> First Int
lvl
  = \ (@ a)
      (@ b)
      (ds :: Const (First Int) a)
      (ds1 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds `cast` <Co:6>) (ds1 `cast` <Co:6>)

-- RHS size: {terms: 9, types: 22, coercions: 12, joins: 0/0}
lvl1
  :: forall a b c.
     (a -> b -> c)
     -> Const (First Int) a -> Const (First Int) b -> First Int
lvl1
  = \ (@ a)
      (@ b)
      (@ c)
      _
      (ds1 :: Const (First Int) a)
      (ds2 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds1 `cast` <Co:6>) (ds2 `cast` <Co:6>)

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl2 :: forall a. a -> Maybe Int
lvl2 = \ (@ a) _ -> Nothing

-- RHS size: {terms: 9, types: 12, coercions: 136, joins: 0/0}
$s$fApplicativeConst :: Applicative (Const (First Int))
$s$fApplicativeConst
  = C:Applicative
      $fFunctorConst
      (lvl2 `cast` <Co:18>)
      ((\ (@ a) (@ b) -> $fMonoidFirst_$cmappend) `cast` <Co:30>)
      (lvl1 `cast` <Co:34>)
      (lvl `cast` <Co:27>)
      (lvl `cast` <Co:27>)

-- RHS size: {terms: 10, types: 27, coercions: 48, joins: 0/0}
printRules7
  :: forall (f :: (* -> *) -> * -> *) a.
     BaseF (Term f) a -> Const (First Int) (BaseF (Term f) a)
printRules7
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (x :: BaseF (Term f) a) ->
      case x of {
        TmLit y1 -> (Just y1) `cast` <Co:34>;
        TmAdd ipv ipv1 -> Nothing `cast` <Co:14>
      }

-- RHS size: {terms: 4, types: 25, coercions: 0, joins: 0/0}
printRules6
  :: forall (f :: (* -> *) -> * -> *) a.
     Applicative (Const (First (Term f a, Term f a)))
printRules6
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) ->
      $fApplicativeConst $fMonoidFirst

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules4 :: Addr#
printRules4 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules3 :: Addr#
printRules3 = " + "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules2 :: Addr#
printRules2 = ")"#

-- RHS size: {terms: 12, types: 45, coercions: 108, joins: 0/0}
printRules5
  :: forall (f :: (* -> *) -> * -> *) a.
     BaseF (Term f) a
     -> Const (First (Term f a, Term f a)) (BaseF (Term f) a)
printRules5
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (x :: BaseF (Term f) a) ->
      case x of {
        TmLit y1 -> Nothing `cast` <Co:26>;
        TmAdd y1 y2 -> (Just (y1, y2)) `cast` <Co:82>
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
printRules1 :: [Char]
printRules1 = unpackCString# printRules2

-- RHS size: {terms: 58, types: 141, coercions: 188, joins: 0/0}
$wprintRules
  :: forall (f :: (* -> *) -> * -> *) a.
     HasBaseF f =>
     (# PrintRule (Term f a), [PrintRule (Term f a)] #)
$wprintRules
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (w :: HasBaseF f) ->
      (# PrintRule
           (\ _ (tm :: Term f a) ->
              case ((w `cast` <Co:2>)
                      $fChoice(->) $s$fApplicativeConst printRules7 (tm `cast` <Co:26>))
                   `cast` <Co:48>
              of {
                Nothing -> Nothing;
                Just x -> Just ($fShowInt_$cshow x)
              }),
         : (PrintRule
              (\ (pr :: Term f a -> Maybe [Char]) (tm :: Term f a) ->
                 case ((w `cast` <Co:2>)
                         $fChoice(->) printRules6 printRules5 (tm `cast` <Co:38>))
                      `cast` <Co:72>
                 of {
                   Nothing -> Nothing;
                   Just x ->
                     case x of { (tm1, tm2) ->
                     case pr tm1 of {
                       Nothing -> Nothing;
                       Just x1 ->
                         case pr tm2 of {
                           Nothing -> Nothing;
                           Just x2 ->
                             Just
                               (unpackAppendCString#
                                  printRules4
                                  (++ x1 (unpackAppendCString# printRules3 (++ x2 printRules1))))
                         }
                     }
                     }
                 }))
           [] #)

-- RHS size: {terms: 10, types: 39, coercions: 0, joins: 0/0}
printRules
  :: forall (f :: (* -> *) -> * -> *) a.
     HasBaseF f =>
     [PrintRule (Term f a)]
printRules
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (w :: HasBaseF f) ->
      case $wprintRules w of { (# ww1, ww2 #) -> : ww1 ww2 }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1


------ Local rules for imported ids --------
"SPEC/Base.Print $fApplicativeConst @ (First Int)"
    forall (v :: Monoid (First Int)).
      $fApplicativeConst v
      = $s$fApplicativeConst


[12 of 20] Compiling Base.Eval        ( src/Base/Eval.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Base/Eval.o ) [Base.Type changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 137, types: 492, coercions: 1,182, joins: 0/0}

-- RHS size: {terms: 7, types: 17, coercions: 12, joins: 0/0}
lvl
  :: forall a b.
     Const (First Int) a -> Const (First Int) b -> First Int
lvl
  = \ (@ a)
      (@ b)
      (ds :: Const (First Int) a)
      (ds1 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds `cast` <Co:6>) (ds1 `cast` <Co:6>)

-- RHS size: {terms: 9, types: 22, coercions: 12, joins: 0/0}
lvl1
  :: forall a b c.
     (a -> b -> c)
     -> Const (First Int) a -> Const (First Int) b -> First Int
lvl1
  = \ (@ a)
      (@ b)
      (@ c)
      _
      (ds1 :: Const (First Int) a)
      (ds2 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds1 `cast` <Co:6>) (ds2 `cast` <Co:6>)

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl2 :: forall a. a -> Maybe Int
lvl2 = \ (@ a) _ -> Nothing

-- RHS size: {terms: 9, types: 12, coercions: 136, joins: 0/0}
$s$fApplicativeConst :: Applicative (Const (First Int))
$s$fApplicativeConst
  = C:Applicative
      $fFunctorConst
      (lvl2 `cast` <Co:18>)
      ((\ (@ a) (@ b) -> $fMonoidFirst_$cmappend) `cast` <Co:30>)
      (lvl1 `cast` <Co:34>)
      (lvl `cast` <Co:27>)
      (lvl `cast` <Co:27>)

-- RHS size: {terms: 10, types: 27, coercions: 48, joins: 0/0}
addRule2
  :: forall (f :: (* -> *) -> * -> *) a.
     BaseF (Term f) a -> Const (First Int) (BaseF (Term f) a)
addRule2
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (x :: BaseF (Term f) a) ->
      case x of {
        TmLit y1 -> (Just y1) `cast` <Co:34>;
        TmAdd ipv ipv1 -> Nothing `cast` <Co:14>
      }

-- RHS size: {terms: 4, types: 25, coercions: 0, joins: 0/0}
addRule4
  :: forall (f :: (* -> *) -> * -> *) a.
     Applicative (Const (First (Term f a, Term f a)))
addRule4
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) ->
      $fApplicativeConst $fMonoidFirst

-- RHS size: {terms: 12, types: 45, coercions: 108, joins: 0/0}
addRule3
  :: forall (f :: (* -> *) -> * -> *) a.
     BaseF (Term f) a
     -> Const (First (Term f a, Term f a)) (BaseF (Term f) a)
addRule3
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (x :: BaseF (Term f) a) ->
      case x of {
        TmLit y1 -> Nothing `cast` <Co:26>;
        TmAdd y1 y2 -> (Just (y1, y2)) `cast` <Co:82>
      }

-- RHS size: {terms: 51, types: 122, coercions: 841, joins: 0/0}
addRule1
  :: forall (f :: (* -> *) -> * -> *) a.
     HasBaseF f =>
     forall r.
     (Term f a -> Term f a)
     -> (Term f a -> r) -> (Term f a -> r) -> Term f a -> r
addRule1
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF f)
      (@ r)
      (e :: Term f a -> Term f a)
      (good :: Term f a -> r)
      (bad :: Term f a -> r)
      (tm :: Term f a) ->
      case (($dHasBaseF `cast` <Co:2>)
              $fChoice(->) addRule4 addRule3 (tm `cast` <Co:38>))
           `cast` <Co:72>
      of {
        Nothing -> bad tm;
        Just x ->
          case x of { (tm1, tm2) ->
          case (($dHasBaseF `cast` <Co:2>)
                  $fChoice(->)
                  $s$fApplicativeConst
                  addRule2
                  ((e tm1) `cast` <Co:26>))
               `cast` <Co:48>
          of {
            Nothing -> bad tm;
            Just x1 ->
              case (($dHasBaseF `cast` <Co:2>)
                      $fChoice(->)
                      $s$fApplicativeConst
                      addRule2
                      ((e tm2) `cast` <Co:26>))
                   `cast` <Co:48>
              of {
                Nothing -> bad tm;
                Just x2 ->
                  good
                    ((($dHasBaseF `cast` <Co:2>)
                        $fChoiceTagged
                        $fApplicativeIdentity
                        ((TmLit ($fNumInt_$c+ x1 x2)) `cast` <Co:45>))
                     `cast` <Co:530>)
              }
          }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 20, joins: 0/0}
addRule
  :: forall (f :: (* -> *) -> * -> *) a.
     HasBaseF f =>
     EvalRule (Term f a)
addRule = addRule1 `cast` <Co:20>

-- RHS size: {terms: 7, types: 22, coercions: 5, joins: 0/0}
evalRules
  :: forall (f :: (* -> *) -> * -> *) a.
     HasBaseF f =>
     [EvalRule (Term f a)]
evalRules
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF f) ->
      : ((addRule1 $dHasBaseF) `cast` <Co:5>) []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1


------ Local rules for imported ids --------
"SPEC/Base.Eval $fApplicativeConst @ (First Int)"
    forall (v :: Monoid (First Int)).
      $fApplicativeConst v
      = $s$fApplicativeConst


[13 of 20] Compiling Base             ( src/Base.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Base.o ) [Base.Type changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 38, types: 146, coercions: 754, joins: 0/0}

-- RHS size: {terms: 7, types: 18, coercions: 0, joins: 0/0}
lit1
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Tagged Int (Identity Int)
     -> Tagged (Term tm a) (Identity (Term tm a))
lit1
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm) ->
      _Lit $dHasBaseF $fChoiceTagged $fApplicativeIdentity

-- RHS size: {terms: 1, types: 0, coercions: 76, joins: 0/0}
lit
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Int -> Term tm a
lit = lit1 `cast` <Co:76>

-- RHS size: {terms: 11, types: 28, coercions: 77, joins: 0/0}
add1
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Term tm a
     -> Term tm a -> Tagged (tm (Term tm) a) (Identity (tm (Term tm) a))
add1
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm)
      (tm1 :: Term tm a)
      (tm2 :: Term tm a) ->
      ($dHasBaseF `cast` <Co:2>)
        $fChoiceTagged
        $fApplicativeIdentity
        ((TmAdd tm1 tm2) `cast` <Co:75>)

-- RHS size: {terms: 1, types: 0, coercions: 601, joins: 0/0}
add
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Term tm a -> Term tm a -> Term tm a
add = add1 `cast` <Co:601>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[14 of 20] Compiling Initial.Bench    ( src/Initial/Bench.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Initial/Bench.o ) [Base changed]

src/Initial/Bench.hs:15:1: warning: [-Worphans]
    Orphan instance: instance NFData (Term TermF a)
    To avoid this
        move the instance declaration to the module of the class or of the type, or
        wrap the type with a newtype and declare the instance on the new type.
   |
15 | instance NFData (Term TermF a)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 249, types: 536, coercions: 13,429, joins: 0/0}

Rec {
-- RHS size: {terms: 29, types: 46, coercions: 3, joins: 0/0}
$fNFDataTerm_$crnf :: forall a. Term TermF a -> ()
$fNFDataTerm_$crnf
  = \ (@ a) (x :: Term TermF a) ->
      case x `cast` <Co:3> of {
        BMBase g1 ->
          case g1 of {
            TmLit g2 -> case g2 of { I# ipv -> () };
            TmAdd g2 g3 ->
              case $fNFDataTerm_$crnf g2 of { () -> $fNFDataTerm_$crnf g3 }
          };
        BMMul g1 ->
          case g1 of { TmMul g2 g3 ->
          case $fNFDataTerm_$crnf g2 of { () -> $fNFDataTerm_$crnf g3 }
          }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
$fNFDataTerm :: forall a. NFData (Term TermF a)
$fNFDataTerm = $fNFDataTerm_$crnf `cast` <Co:8>

Rec {
-- RHS size: {terms: 82, types: 154, coercions: 549, joins: 0/0}
evalTerm :: forall a. Term TermF a -> Term TermF a
evalTerm
  = \ (@ a) (tm1 :: Term TermF a) ->
      case tm1 `cast` <Co:38> of wild {
        BMBase y1 ->
          case y1 of {
            TmLit y2 -> wild `cast` <Co:37>;
            TmAdd y2 y3 ->
              case (evalTerm y2) `cast` <Co:26> of {
                BMBase y4 ->
                  case y4 of {
                    TmLit y5 ->
                      case (evalTerm y3) `cast` <Co:26> of {
                        BMBase y6 ->
                          case y6 of {
                            TmLit y7 ->
                              (BMBase
                                 (TmLit
                                    (case y5 of { I# x -> case y7 of { I# y -> I# (+# x y) } })))
                              `cast` <Co:37>;
                            TmAdd ipv ipv1 -> wild `cast` <Co:37>
                          };
                        BMMul ipv -> wild `cast` <Co:37>
                      };
                    TmAdd ipv ipv1 -> wild `cast` <Co:37>
                  };
                BMMul ipv -> wild `cast` <Co:37>
              }
          };
        BMMul ipv ->
          case ipv of { TmMul x1 x2 ->
          case (evalTerm x1) `cast` <Co:26> of {
            BMBase y1 ->
              case y1 of {
                TmLit y2 ->
                  case (evalTerm x2) `cast` <Co:26> of {
                    BMBase y3 ->
                      case y3 of {
                        TmLit y4 ->
                          (BMBase
                             (TmLit
                                (case y2 of { I# x -> case y4 of { I# y -> I# (*# x y) } })))
                          `cast` <Co:37>;
                        TmAdd ipv1 ipv2 -> wild `cast` <Co:37>
                      };
                    BMMul ipv1 -> wild `cast` <Co:37>
                  };
                TmAdd ipv1 ipv2 -> wild `cast` <Co:37>
              };
            BMMul ipv1 -> wild `cast` <Co:37>
          }
          }
      }
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lit4 :: Int
lit4 = I# 2#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lit3 :: forall a. BaseF (Term TermF) a
lit3 = \ (@ a) -> TmLit lit4

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
lit1 :: forall a. TermF (Term TermF) a
lit1 = \ (@ a) -> BMBase lit3

-- RHS size: {terms: 1, types: 0, coercions: 594, joins: 0/0}
lit2 :: forall a. Term TermF a
lit2 = lit1 `cast` <Co:594>

-- RHS size: {terms: 8, types: 17, coercions: 563, joins: 0/0}
evalAddSmall
  :: forall a.
     (Term TermF a -> Term TermF a) -> Term TermF a -> Term TermF a
evalAddSmall
  = \ (@ a)
      (eval :: Term TermF a -> Term TermF a)
      (tm :: Term TermF a) ->
      eval ((BMBase (TmAdd tm tm)) `cast` <Co:563>)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddBig6 :: Int
evalAddBig6 = I# 3#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
evalAddBig5 :: forall a. BaseF (Term TermF) a
evalAddBig5 = \ (@ a) -> TmLit evalAddBig6

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
evalAddBig4 :: forall a. TermF (Term TermF) a
evalAddBig4 = \ (@ a) -> BMBase evalAddBig5

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddBig3 :: Int
evalAddBig3 = I# 5#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
evalAddBig2 :: forall a. BaseF (Term TermF) a
evalAddBig2 = \ (@ a) -> TmLit evalAddBig3

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
evalAddBig1 :: forall a. TermF (Term TermF) a
evalAddBig1 = \ (@ a) -> BMBase evalAddBig2

-- RHS size: {terms: 11, types: 25, coercions: 2,384, joins: 0/0}
evalAddMulSmall
  :: forall a.
     (Term TermF a -> Term TermF a) -> Term TermF a -> Term TermF a
evalAddMulSmall
  = \ (@ a)
      (eval :: Term TermF a -> Term TermF a)
      (tm :: Term TermF a) ->
      eval
        ((BMBase
            (TmAdd
               ((BMMul (TmMul tm (evalAddBig4 `cast` <Co:591>))) `cast` <Co:639>)
               (evalAddBig1 `cast` <Co:591>)))
         `cast` <Co:563>)

-- RHS size: {terms: 14, types: 31, coercions: 2,871, joins: 0/0}
evalAddBig
  :: forall a.
     (Term TermF a -> Term TermF a) -> Term TermF a -> Term TermF a
evalAddBig
  = \ (@ a)
      (eval :: Term TermF a -> Term TermF a)
      (tm :: Term TermF a) ->
      eval
        ((BMBase
            (TmAdd
               ((BMBase (TmAdd tm (evalAddBig4 `cast` <Co:591>))) `cast` <Co:563>)
               ((BMBase (TmAdd tm (evalAddBig1 `cast` <Co:591>)))
                `cast` <Co:563>)))
         `cast` <Co:563>)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddMulBig6 :: Int
evalAddMulBig6 = I# 7#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
evalAddMulBig5 :: forall a. BaseF (Term TermF) a
evalAddMulBig5 = \ (@ a) -> TmLit evalAddMulBig6

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
evalAddMulBig4 :: forall a. TermF (Term TermF) a
evalAddMulBig4 = \ (@ a) -> BMBase evalAddMulBig5

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddMulBig3 :: Int
evalAddMulBig3 = I# 11#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
evalAddMulBig2 :: forall a. BaseF (Term TermF) a
evalAddMulBig2 = \ (@ a) -> TmLit evalAddMulBig3

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
evalAddMulBig1 :: forall a. TermF (Term TermF) a
evalAddMulBig1 = \ (@ a) -> BMBase evalAddMulBig2

-- RHS size: {terms: 26, types: 57, coercions: 6,457, joins: 0/0}
evalAddMulBig
  :: forall a.
     (Term TermF a -> Term TermF a) -> Term TermF a -> Term TermF a
evalAddMulBig
  = \ (@ a)
      (eval :: Term TermF a -> Term TermF a)
      (tm :: Term TermF a) ->
      eval
        ((BMBase
            (TmAdd
               ((BMMul
                   (TmMul
                      ((BMBase (TmAdd tm (evalAddBig4 `cast` <Co:591>))) `cast` <Co:563>)
                      ((BMBase (TmAdd tm (evalAddBig1 `cast` <Co:591>)))
                       `cast` <Co:563>)))
                `cast` <Co:639>)
               ((BMMul
                   (TmMul
                      ((BMBase (TmAdd tm (evalAddMulBig4 `cast` <Co:591>)))
                       `cast` <Co:563>)
                      ((BMBase (TmAdd tm (evalAddMulBig1 `cast` <Co:591>)))
                       `cast` <Co:563>)))
                `cast` <Co:639>)))
         `cast` <Co:563>)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Initial.Bench"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[15 of 20] Compiling Example.Base     ( src/Example/Base.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Base.o ) [Base changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 64, types: 187, coercions: 3,056, joins: 0/0}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term8 :: Int
term8 = I# 8#

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
term7 :: forall a (tm :: (* -> *) -> * -> *). BaseF (Term tm) a
term7 = \ (@ a) (@ (tm :: (* -> *) -> * -> *)) -> TmLit term8

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term6 :: Int
term6 = I# 1#

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
term5 :: forall a (tm :: (* -> *) -> * -> *). BaseF (Term tm) a
term5 = \ (@ a) (@ (tm :: (* -> *) -> * -> *)) -> TmLit term6

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term4 :: Int
term4 = I# 2#

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
term3 :: forall a (tm :: (* -> *) -> * -> *). BaseF (Term tm) a
term3 = \ (@ a) (@ (tm :: (* -> *) -> * -> *)) -> TmLit term4

-- RHS size: {terms: 23, types: 59, coercions: 2,463, joins: 0/0}
term2
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Tagged (tm (Term tm) a) (Identity (tm (Term tm) a))
term2
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm) ->
      ($dHasBaseF `cast` <Co:2>)
        $fChoiceTagged
        $fApplicativeIdentity
        ((TmAdd
            ((($dHasBaseF `cast` <Co:2>)
                $fChoiceTagged $fApplicativeIdentity (term7 `cast` <Co:45>))
             `cast` <Co:530>)
            ((($dHasBaseF `cast` <Co:2>)
                $fChoiceTagged
                $fApplicativeIdentity
                ((TmAdd
                    ((($dHasBaseF `cast` <Co:2>)
                        $fChoiceTagged $fApplicativeIdentity (term5 `cast` <Co:45>))
                     `cast` <Co:530>)
                    ((($dHasBaseF `cast` <Co:2>)
                        $fChoiceTagged $fApplicativeIdentity (term3 `cast` <Co:45>))
                     `cast` <Co:530>))
                 `cast` <Co:75>))
             `cast` <Co:578>))
         `cast` <Co:75>)

-- RHS size: {terms: 1, types: 0, coercions: 593, joins: 0/0}
term1
  :: forall (tm :: (* -> *) -> * -> *) a. HasBaseF tm => Term tm a
term1 = term2 `cast` <Co:593>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[16 of 20] Compiling Example.Term.Base.Print ( src/Example/Term/Base/Print.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/Base/Print.o ) [Base.Print changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 39, types: 98, coercions: 4,013, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.Base.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 8, types: 29, coercions: 3, joins: 0/0}
print4 :: forall a. [PrintRule (Term TermF a)]
print4
  = \ (@ a) ->
      case $wprintRules ($fHasBaseFBaseF_$c_BaseF `cast` <Co:3>) of
      { (# ww1, ww2 #) ->
      : ww1 ww2
      }

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
printTerm :: forall a. Term TermF a -> Maybe String
printTerm = \ (@ a) -> mkPrint print4

-- RHS size: {terms: 3, types: 13, coercions: 1,500, joins: 0/0}
print3 :: BaseF (Term TermF) Any
print3 = TmAdd (term5 `cast` <Co:750>) (term3 `cast` <Co:750>)

-- RHS size: {terms: 3, types: 9, coercions: 1,630, joins: 0/0}
print2 :: BaseF (Term TermF) Any
print2 = TmAdd (term7 `cast` <Co:750>) (print3 `cast` <Co:880>)

-- RHS size: {terms: 3, types: 8, coercions: 880, joins: 0/0}
print1 :: Maybe String
print1 = mkPrint print4 (print2 `cast` <Co:880>)



[17 of 20] Compiling Example.Term.Base.Eval ( src/Example/Term/Base/Eval.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/Base/Eval.o ) [Base.Eval changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 59, types: 98, coercions: 3,274, joins: 0/0}

Rec {
-- RHS size: {terms: 30, types: 47, coercions: 238, joins: 0/0}
evalTerm :: forall a. Term TermF a -> Term TermF a
evalTerm
  = \ (@ a) (tm1 :: Term TermF a) ->
      case tm1 `cast` <Co:38> of wild {
        TmLit y1 -> wild `cast` <Co:37>;
        TmAdd y1 y2 ->
          case (evalTerm y1) `cast` <Co:26> of {
            TmLit y4 ->
              case (evalTerm y2) `cast` <Co:26> of {
                TmLit y5 ->
                  (TmLit (case y4 of { I# x -> case y5 of { I# y -> I# (+# x y) } }))
                  `cast` <Co:37>;
                TmAdd ipv ipv1 -> wild `cast` <Co:37>
              };
            TmAdd ipv ipv1 -> wild `cast` <Co:37>
          }
      }
end Rec }

-- RHS size: {terms: 4, types: 9, coercions: 1,152, joins: 0/0}
eval3 :: forall a. BaseF (Term TermF) a
eval3
  = \ (@ a) -> TmAdd (term5 `cast` <Co:576>) (term3 `cast` <Co:576>)

-- RHS size: {terms: 4, types: 8, coercions: 1,230, joins: 0/0}
eval2 :: forall a. BaseF (Term TermF) a
eval2
  = \ (@ a) -> TmAdd (term7 `cast` <Co:576>) (eval3 `cast` <Co:654>)

-- RHS size: {terms: 3, types: 4, coercions: 654, joins: 0/0}
eval1 :: forall a. Term TermF a
eval1 = \ (@ a) -> evalTerm (eval2 `cast` <Co:654>)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.Base.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[18 of 20] Compiling Example.Mul      ( src/Example/Mul.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Mul.o ) [Base changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 84, types: 273, coercions: 4,023, joins: 0/0}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term10 :: Int
term10 = I# 7#

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
term9 :: forall a (tm :: (* -> *) -> * -> *). BaseF (Term tm) a
term9 = \ (@ a) (@ (tm :: (* -> *) -> * -> *)) -> TmLit term10

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term8 :: Int
term8 = I# 1#

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
term7 :: forall a (tm :: (* -> *) -> * -> *). BaseF (Term tm) a
term7 = \ (@ a) (@ (tm :: (* -> *) -> * -> *)) -> TmLit term8

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term6 :: Int
term6 = I# 2#

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
term5 :: forall a (tm :: (* -> *) -> * -> *). BaseF (Term tm) a
term5 = \ (@ a) (@ (tm :: (* -> *) -> * -> *)) -> TmLit term6

-- RHS size: {terms: 25, types: 63, coercions: 2,031, joins: 0/0}
term1
  :: forall (tm :: (* -> *) -> * -> *) a.
     (HasBaseF tm, HasMulF tm) =>
     Tagged (tm (Term tm) a) (Identity (tm (Term tm) a))
term1
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm)
      ($dHasMulF :: HasMulF tm) ->
      ($dHasBaseF `cast` <Co:2>)
        $fChoiceTagged
        $fApplicativeIdentity
        ((TmAdd
            ((($dHasBaseF `cast` <Co:2>)
                $fChoiceTagged $fApplicativeIdentity (term9 `cast` <Co:45>))
             `cast` <Co:530>)
            ((_Mul
                $dHasMulF
                $fChoiceTagged
                $fApplicativeIdentity
                (((($dHasBaseF `cast` <Co:2>)
                     $fChoiceTagged $fApplicativeIdentity (term7 `cast` <Co:45>))
                  `cast` <Co:530>,
                  (($dHasBaseF `cast` <Co:2>)
                     $fChoiceTagged $fApplicativeIdentity (term5 `cast` <Co:45>))
                  `cast` <Co:530>)
                 `cast` <Co:113>))
             `cast` <Co:110>))
         `cast` <Co:75>)

-- RHS size: {terms: 1, types: 0, coercions: 596, joins: 0/0}
term2
  :: forall (tm :: (* -> *) -> * -> *) a.
     (HasBaseF tm, HasMulF tm) =>
     Term tm a
term2 = term1 `cast` <Co:596>

-- RHS size: {terms: 15, types: 37, coercions: 1,268, joins: 0/0}
term11
  :: forall (tm :: (* -> *) -> * -> *) a.
     (HasBaseF tm, HasMulF tm) =>
     Tagged (Term tm a) (Identity (Term tm a))
term11
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm)
      ($dHasMulF :: HasMulF tm) ->
      _Mul
        $dHasMulF
        $fChoiceTagged
        $fApplicativeIdentity
        (((($dHasBaseF `cast` <Co:2>)
             $fChoiceTagged $fApplicativeIdentity (term9 `cast` <Co:45>))
          `cast` <Co:530>,
          (term2 $dHasBaseF) `cast` <Co:578>)
         `cast` <Co:113>)

-- RHS size: {terms: 1, types: 0, coercions: 128, joins: 0/0}
term3
  :: forall (tm :: (* -> *) -> * -> *) a.
     (HasBaseF tm, HasMulF tm) =>
     Term tm a
term3 = term11 `cast` <Co:128>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[19 of 20] Compiling Example.Term.BaseMul.Print ( src/Example/Term/BaseMul/Print.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/BaseMul/Print.o ) [Base.Print changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 103, types: 325, coercions: 9,483, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.BaseMul.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 8, types: 29, coercions: 3, joins: 0/0}
print12 :: forall a. [PrintRule (Term TermF a)]
print12
  = \ (@ a) ->
      case $wprintRules (_BMMul `cast` <Co:3>) of { (# ww1, ww2 #) ->
      : ww1 ww2
      }

-- RHS size: {terms: 10, types: 34, coercions: 3, joins: 0/0}
print11 :: forall a. [PrintRule (Term TermF a)]
print11
  = \ (@ a) ->
      case $wprintRules (_BMBase `cast` <Co:3>) of { (# ww1, ww2 #) ->
      ++ (: ww1 ww2) print12
      }

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
printTerm :: forall a. Term TermF a -> Maybe String
printTerm = \ (@ a) -> mkPrint print11

-- RHS size: {terms: 2, types: 9, coercions: 0, joins: 0/0}
print10 :: TermF (Term TermF) Any
print10 = BMBase term7

-- RHS size: {terms: 2, types: 9, coercions: 0, joins: 0/0}
print9 :: TermF (Term TermF) Any
print9 = BMBase term5

-- RHS size: {terms: 2, types: 9, coercions: 0, joins: 0/0}
print8 :: TermF (Term TermF) Any
print8 = BMBase term3

-- RHS size: {terms: 3, types: 5, coercions: 1,354, joins: 0/0}
print7 :: BaseF (Term TermF) Any
print7 = TmAdd (print9 `cast` <Co:677>) (print8 `cast` <Co:677>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print6 :: TermF (Term TermF) Any
print6 = BMBase print7

-- RHS size: {terms: 3, types: 5, coercions: 1,434, joins: 0/0}
print5 :: BaseF (Term TermF) Any
print5 = TmAdd (print10 `cast` <Co:677>) (print6 `cast` <Co:757>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print4 :: TermF (Term TermF) Any
print4 = BMBase print5

-- RHS size: {terms: 3, types: 8, coercions: 757, joins: 0/0}
print1 :: Maybe String
print1 = mkPrint print11 (print4 `cast` <Co:757>)

-- RHS size: {terms: 2, types: 9, coercions: 0, joins: 0/0}
print19 :: TermF (Term TermF) Any
print19 = BMBase term9

-- RHS size: {terms: 2, types: 9, coercions: 0, joins: 0/0}
print18 :: TermF (Term TermF) Any
print18 = BMBase term7

-- RHS size: {terms: 2, types: 9, coercions: 0, joins: 0/0}
print17 :: TermF (Term TermF) Any
print17 = BMBase term5

-- RHS size: {terms: 3, types: 5, coercions: 1,354, joins: 0/0}
print16 :: MulF (Term TermF) Any
print16 = TmMul (print18 `cast` <Co:677>) (print17 `cast` <Co:677>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print15 :: TermF (Term TermF) Any
print15 = BMMul print16

-- RHS size: {terms: 3, types: 5, coercions: 1,532, joins: 0/0}
print14 :: BaseF (Term TermF) Any
print14 = TmAdd (print19 `cast` <Co:677>) (print15 `cast` <Co:855>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print13 :: TermF (Term TermF) Any
print13 = BMBase print14

-- RHS size: {terms: 3, types: 8, coercions: 757, joins: 0/0}
print2 :: Maybe String
print2 = mkPrint print11 (print13 `cast` <Co:757>)

-- RHS size: {terms: 3, types: 5, coercions: 1,434, joins: 0/0}
print21 :: MulF (Term TermF) Any
print21 = TmMul (print19 `cast` <Co:677>) (print4 `cast` <Co:757>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print20 :: TermF (Term TermF) Any
print20 = BMMul print21

-- RHS size: {terms: 3, types: 8, coercions: 855, joins: 0/0}
print3 :: Maybe String
print3 = mkPrint print11 (print20 `cast` <Co:855>)



[20 of 20] Compiling Example.Term.BaseMul.Eval ( src/Example/Term/BaseMul/Eval.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/BaseMul/Eval.o ) [Base.Eval changed]

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 178, types: 397, coercions: 7,684, joins: 0/0}

Rec {
-- RHS size: {terms: 82, types: 154, coercions: 549, joins: 0/0}
evalTerm :: forall a. Term TermF a -> Term TermF a
evalTerm
  = \ (@ a) (tm1 :: Term TermF a) ->
      case tm1 `cast` <Co:38> of wild {
        BMBase y1 ->
          case y1 of {
            TmLit y2 -> wild `cast` <Co:37>;
            TmAdd y2 y3 ->
              case (evalTerm y2) `cast` <Co:26> of {
                BMBase y4 ->
                  case y4 of {
                    TmLit y5 ->
                      case (evalTerm y3) `cast` <Co:26> of {
                        BMBase y6 ->
                          case y6 of {
                            TmLit y7 ->
                              (BMBase
                                 (TmLit
                                    (case y5 of { I# x -> case y7 of { I# y -> I# (+# x y) } })))
                              `cast` <Co:37>;
                            TmAdd ipv ipv1 -> wild `cast` <Co:37>
                          };
                        BMMul ipv -> wild `cast` <Co:37>
                      };
                    TmAdd ipv ipv1 -> wild `cast` <Co:37>
                  };
                BMMul ipv -> wild `cast` <Co:37>
              }
          };
        BMMul ipv ->
          case ipv of { TmMul x1 x2 ->
          case (evalTerm x1) `cast` <Co:26> of {
            BMBase y1 ->
              case y1 of {
                TmLit y2 ->
                  case (evalTerm x2) `cast` <Co:26> of {
                    BMBase y3 ->
                      case y3 of {
                        TmLit y4 ->
                          (BMBase
                             (TmLit
                                (case y2 of { I# x -> case y4 of { I# y -> I# (*# x y) } })))
                          `cast` <Co:37>;
                        TmAdd ipv1 ipv2 -> wild `cast` <Co:37>
                      };
                    BMMul ipv1 -> wild `cast` <Co:37>
                  };
                TmAdd ipv1 ipv2 -> wild `cast` <Co:37>
              };
            BMMul ipv1 -> wild `cast` <Co:37>
          }
          }
      }
end Rec }

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
eval10 :: forall a. TermF (Term TermF) a
eval10 = \ (@ a) -> BMBase term7

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
eval9 :: forall a. TermF (Term TermF) a
eval9 = \ (@ a) -> BMBase term5

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
eval8 :: forall a. TermF (Term TermF) a
eval8 = \ (@ a) -> BMBase term3

-- RHS size: {terms: 4, types: 7, coercions: 1,030, joins: 0/0}
eval7 :: forall a. BaseF (Term TermF) a
eval7
  = \ (@ a) -> TmAdd (eval9 `cast` <Co:515>) (eval8 `cast` <Co:515>)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval6 :: forall a. TermF (Term TermF) a
eval6 = \ (@ a) -> BMBase eval7

-- RHS size: {terms: 4, types: 7, coercions: 1,078, joins: 0/0}
eval5 :: forall a. BaseF (Term TermF) a
eval5
  = \ (@ a) -> TmAdd (eval10 `cast` <Co:515>) (eval6 `cast` <Co:563>)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval4 :: forall a. TermF (Term TermF) a
eval4 = \ (@ a) -> BMBase eval5

-- RHS size: {terms: 3, types: 4, coercions: 563, joins: 0/0}
eval1 :: forall a. Term TermF a
eval1 = \ (@ a) -> evalTerm (eval4 `cast` <Co:563>)

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
eval17 :: forall a. TermF (Term TermF) a
eval17 = \ (@ a) -> BMBase term9

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
eval16 :: forall a. TermF (Term TermF) a
eval16 = \ (@ a) -> BMBase term7

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
eval15 :: forall a. TermF (Term TermF) a
eval15 = \ (@ a) -> BMBase term5

-- RHS size: {terms: 4, types: 7, coercions: 1,030, joins: 0/0}
eval14 :: forall a. MulF (Term TermF) a
eval14
  = \ (@ a) ->
      TmMul (eval16 `cast` <Co:515>) (eval15 `cast` <Co:515>)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval13 :: forall a. TermF (Term TermF) a
eval13 = \ (@ a) -> BMMul eval14

-- RHS size: {terms: 4, types: 7, coercions: 1,154, joins: 0/0}
eval12 :: forall a. BaseF (Term TermF) a
eval12
  = \ (@ a) ->
      TmAdd (eval17 `cast` <Co:515>) (eval13 `cast` <Co:639>)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval11 :: forall a. TermF (Term TermF) a
eval11 = \ (@ a) -> BMBase eval12

-- RHS size: {terms: 3, types: 4, coercions: 563, joins: 0/0}
eval2 :: forall a. Term TermF a
eval2 = \ (@ a) -> evalTerm (eval11 `cast` <Co:563>)

-- RHS size: {terms: 4, types: 7, coercions: 1,078, joins: 0/0}
eval19 :: forall a. MulF (Term TermF) a
eval19
  = \ (@ a) -> TmMul (eval17 `cast` <Co:515>) (eval4 `cast` <Co:563>)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval18 :: forall a. TermF (Term TermF) a
eval18 = \ (@ a) -> BMMul eval19

-- RHS size: {terms: 3, types: 4, coercions: 639, joins: 0/0}
eval3 :: forall a. Term TermF a
eval3 = \ (@ a) -> evalTerm (eval18 `cast` <Co:639>)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.BaseMul.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Preprocessing executable 'bench' for initial-final-bench-0.1.0.0..
Building executable 'bench' for initial-final-bench-0.1.0.0..
[1 of 1] Compiling Main             ( Main.hs, /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-final-bench-0.1.0.0/c/bench/build/bench/bench-tmp/Main.o ) [Initial.Bench changed]
Linking /home/dave/work/github.com/dalaing/backpack/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-final-bench-0.1.0.0/c/bench/build/bench/bench ...
