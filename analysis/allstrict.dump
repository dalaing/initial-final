Resolving dependencies...
In order, the following will be built (use -v for more details):
 - final-0.1.0.0 (lib) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-eval) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-print) +dump (first run)
 - final-bp-0.1.0.0 (lib:repr) +dump (first run)
 - initial-0.1.0.0 (lib) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-eval) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base-mul) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-print) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-term) +dump (first run)
 - vanilla-0.1.0.0 (lib) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-mul-eval) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-base-eval) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-mul-print) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-base-print) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-mul) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-base) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul-sig) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-sig) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-mul with Mul=final-bp-0.1.0.0-inplace-final-bp-mul-eval:Mul, Repr=final-bp-0.1.0.0-inplace-final-bp-eval:Repr) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-example-base) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-base with Base=final-bp-0.1.0.0-inplace-final-bp-base-eval:Base, Repr=final-bp-0.1.0.0-inplace-final-bp-eval:Repr) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul-print) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul-eval) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-print) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-eval) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-example-mul) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-example-base with Base=final-bp-0.1.0.0-inplace-final-bp-base-print:Base, Repr=final-bp-0.1.0.0-inplace-final-bp-print:Repr) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-example-base with Base=final-bp-0.1.0.0-inplace-final-bp-base-eval:Base, Repr=final-bp-0.1.0.0-inplace-final-bp-eval:Repr) +dump (first run)
 - final-bp-0.1.0.0 (lib) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul-print with Mul.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-mul-eval with Base.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type, Mul.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-print with Base.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-print with Base.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-eval with Base.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-base-eval with Base.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type, Term.Type=initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-base) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-example-mul with Base=final-bp-0.1.0.0-inplace-final-bp-base-print:Base, Mul=final-bp-0.1.0.0-inplace-final-bp-mul-print:Mul, Repr=final-bp-0.1.0.0-inplace-final-bp-print:Repr) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-example-mul with Base=final-bp-0.1.0.0-inplace-final-bp-base-eval:Base, Mul=final-bp-0.1.0.0-inplace-final-bp-mul-eval:Mul, Repr=final-bp-0.1.0.0-inplace-final-bp-eval:Repr) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base-print) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base-mul-print) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base-eval) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-term-base-mul-eval) +dump (first run)
 - initial-bp-0.1.0.0 (lib) +dump (first run)
 - initial-bp-0.1.0.0 (lib:initial-bp-example-mul) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-example-print) +dump (first run)
 - final-bp-0.1.0.0 (lib:final-bp-example-eval) +dump (first run)
 - initial-final-bench-0.1.0.0 (exe:bench) (first run)
Configuring library for final-0.1.0.0..
Configuring library 'final-bp-eval' for final-bp-0.1.0.0..
Configuring library 'final-bp-print' for final-bp-0.1.0.0..
Configuring library for initial-0.1.0.0..
Configuring library 'repr' for final-bp-0.1.0.0..
Configuring library 'initial-bp-eval' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-example-term-base' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-example-term-base-mul' for initial-bp-0.1.0.0..
Preprocessing library for final-0.1.0.0..
Building library for final-0.1.0.0..
Preprocessing library 'final-bp-print' for final-bp-0.1.0.0..
Building library 'final-bp-print' for final-bp-0.1.0.0..
Preprocessing library 'final-bp-eval' for final-bp-0.1.0.0..
Building library 'final-bp-eval' for final-bp-0.1.0.0..
Preprocessing library for initial-0.1.0.0..
Building library for initial-0.1.0.0..
Preprocessing library 'repr' for final-bp-0.1.0.0..
Building library 'repr' instantiated with Repr = <Repr>
for final-bp-0.1.0.0..
Preprocessing library 'initial-bp-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-eval' for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-example-term-base' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base' for initial-bp-0.1.0.0..
[1 of 1] Compiling Repr             ( final-bp-print/Repr.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-print/build/final-bp-print/Repr.o )
[ 1 of 11] Compiling Base             ( src/Base.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Base.o )
[1 of 1] Compiling Repr             ( final-bp-eval/Repr.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-eval/build/final-bp-eval/Repr.o )
[1 of 1] Compiling Repr[sig]        ( repr/Repr.hsig, nothing )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 97, types: 62, coercions: 0, joins: 0/0}

-- RHS size: {terms: 6, types: 11, coercions: 0, joins: 0/0}
lit :: forall repr. ExpBase repr => Int -> repr
lit
  = \ (@ repr) (v :: ExpBase repr) ->
      case v of v { C:ExpBase v v -> v }

-- RHS size: {terms: 6, types: 11, coercions: 0, joins: 0/0}
add :: forall repr. ExpBase repr => repr -> repr -> repr
add
  = \ (@ repr) (v :: ExpBase repr) ->
      case v of v { C:ExpBase v v -> v }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1
[1 of 1] Compiling Interpret.Eval   ( initial-bp-eval/Interpret/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-eval/build/initial-bp-eval/Interpret/Eval.o )

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepTyConApp $tcConstraint []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcExpBase1 :: KindRep
$tcExpBase1 = KindRepFun krep$* $krep1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepFun $krep2 $krep2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepFun $krep2 $krep3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepFun $krep $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcExpBase3 :: Addr#
$tcExpBase3 = "ExpBase"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcExpBase2 :: TrName
$tcExpBase2 = TrNameS $tcExpBase3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcExpBase :: TyCon
$tcExpBase
  = TyCon
      8755670527849511401##
      5419305586342230353##
      $trModule
      $tcExpBase2
      0#
      $tcExpBase1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep6 :: [KindRep]
$krep6 = : $krep2 []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7 :: KindRep
$krep7 = KindRepTyConApp $tcExpBase $krep6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8 :: KindRep
$krep8 = KindRepFun $krep4 $krep7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'C:ExpBase1 :: KindRep
$tc'C:ExpBase1 = KindRepFun $krep5 $krep8

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'C:ExpBase3 :: Addr#
$tc'C:ExpBase3 = "'C:ExpBase"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'C:ExpBase2 :: TrName
$tc'C:ExpBase2 = TrNameS $tc'C:ExpBase3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'C:ExpBase :: TyCon
$tc'C:ExpBase
  = TyCon
      1869223079848627608##
      10514222822274484468##
      $trModule
      $tc'C:ExpBase2
      1#
      $tc'C:ExpBase1




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-bp-0.1.0.0-inplace-final-bp-print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Repr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[ 1 of 20] Compiling Interpret.Eval   ( src/Interpret/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Interpret/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-bp-0.1.0.0-inplace-final-bp-eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Repr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 67, types: 80, coercions: 18, joins: 0/2}

-- RHS size: {terms: 14, types: 16, coercions: 4, joins: 0/0}
composeEvalRule1
  :: forall tm.
     EvalRule tm
     -> EvalRule tm
     -> forall r. (tm -> tm) -> (tm -> r) -> (tm -> r) -> tm -> r
composeEvalRule1
  = \ (@ tm)
      (ds :: EvalRule tm)
      (ds1 :: EvalRule tm)
      (@ r)
      (e :: tm -> tm)
      (good :: tm -> r)
      (bad :: tm -> r) ->
      (ds `cast` <Co:2>) e good ((ds1 `cast` <Co:2>) e good bad)

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
composeEvalRule
  :: forall tm. EvalRule tm -> EvalRule tm -> EvalRule tm
composeEvalRule = composeEvalRule1 `cast` <Co:12>

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
mkEval1 :: forall tm. tm -> Maybe tm
mkEval1 = \ (@ tm) _ -> Nothing

-- RHS size: {terms: 18, types: 17, coercions: 2, joins: 0/2}
mkEval :: forall tm. EvalRule tm -> tm -> tm
mkEval
  = \ (@ tm) (ds :: EvalRule tm) ->
      letrec {
        step :: tm -> Maybe tm
        step = (ds `cast` <Co:2>) eval Just mkEval1;
        eval :: tm -> tm
        eval
          = \ (tm1 :: tm) ->
              case step tm1 of {
                Nothing -> tm1;
                Just tm' -> eval tm'
              }; } in
      eval

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-bp-0.1.0.0-inplace-initial-bp-eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Interpret.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcEvalRule2 :: Addr#
$tcEvalRule2 = "EvalRule"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcEvalRule1 :: TrName
$tcEvalRule1 = TrNameS $tcEvalRule2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcEvalRule :: TyCon
$tcEvalRule
  = TyCon
      9472438337276186837##
      497777784813275738##
      $trModule
      $tcEvalRule1
      0#
      krep$*Arr*



Preprocessing library 'initial-bp-example-term-base-mul' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base-mul' for initial-bp-0.1.0.0..

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 67, types: 80, coercions: 18, joins: 0/2}

-- RHS size: {terms: 14, types: 16, coercions: 4, joins: 0/0}
composeEvalRule1
  :: forall tm.
     EvalRule tm
     -> EvalRule tm
     -> forall r. (tm -> tm) -> (tm -> r) -> (tm -> r) -> tm -> r
composeEvalRule1
  = \ (@ tm)
      (ds :: EvalRule tm)
      (ds1 :: EvalRule tm)
      (@ r)
      (e :: tm -> tm)
      (good :: tm -> r)
      (bad :: tm -> r) ->
      (ds `cast` <Co:2>) e good ((ds1 `cast` <Co:2>) e good bad)

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
composeEvalRule
  :: forall tm. EvalRule tm -> EvalRule tm -> EvalRule tm
composeEvalRule = composeEvalRule1 `cast` <Co:12>

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
mkEval1 :: forall tm. tm -> Maybe tm
mkEval1 = \ (@ tm) _ -> Nothing

-- RHS size: {terms: 18, types: 17, coercions: 2, joins: 0/2}
mkEval :: forall tm. EvalRule tm -> tm -> tm
mkEval
  = \ (@ tm) (ds :: EvalRule tm) ->
      letrec {
        step :: tm -> Maybe tm
        step = (ds `cast` <Co:2>) eval Just mkEval1;
        eval :: tm -> tm
        eval
          = \ (tm1 :: tm) ->
              case step tm1 of {
                Nothing -> tm1;
                Just tm' -> eval tm'
              }; } in
      eval

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Interpret.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcEvalRule2 :: Addr#
$tcEvalRule2 = "EvalRule"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcEvalRule1 :: TrName
$tcEvalRule1 = TrNameS $tcEvalRule2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcEvalRule :: TyCon
$tcEvalRule
  = TyCon
      10994308217929540355##
      14081087777498451726##
      $trModule
      $tcEvalRule1
      0#
      krep$*Arr*



[ 2 of 11] Compiling Example.Base     ( src/Example/Base.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Example/Base.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 39, types: 22, coercions: 0, joins: 0/0}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term4 :: Int
term4 = I# 8#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term3 :: Int
term3 = I# 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term2 :: Int
term2 = I# 2#

-- RHS size: {terms: 15, types: 9, coercions: 0, joins: 0/0}
term1 :: forall repr. ExpBase repr => repr
term1
  = \ (@ repr) ($dExpBase :: ExpBase repr) ->
      add
        $dExpBase
        (lit $dExpBase term4)
        (add $dExpBase (lit $dExpBase term3) (lit $dExpBase term2))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[ 2 of 20] Compiling Interpret.Print  ( src/Interpret/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Interpret/Print.o )
[1 of 2] Compiling Term.Type        ( initial-bp-example-term-base/Term/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base/build/initial-bp-example-term-base/Term/Type.o )
[ 3 of 11] Compiling Mul              ( src/Mul.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Mul.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 75, types: 34, coercions: 2, joins: 0/0}

-- RHS size: {terms: 3, types: 4, coercions: 2, joins: 0/0}
mul :: forall repr. ExpMul repr => repr -> repr -> repr
mul = \ (@ repr) (v :: ExpMul repr) -> v `cast` <Co:2>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcConstraint []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcExpMul1 :: KindRep
$tcExpMul1 = KindRepFun krep$* $krep

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepFun $krep1 $krep1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepFun $krep1 $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcExpMul3 :: Addr#
$tcExpMul3 = "ExpMul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcExpMul2 :: TrName
$tcExpMul2 = TrNameS $tcExpMul3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcExpMul :: TyCon
$tcExpMul
  = TyCon
      9374537577504056060##
      5530055685242691772##
      $trModule
      $tcExpMul2
      0#
      $tcExpMul1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep4 :: [KindRep]
$krep4 = : $krep1 []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepTyConApp $tcExpMul $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'C:ExpMul1 :: KindRep
$tc'C:ExpMul1 = KindRepFun $krep3 $krep5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'C:ExpMul3 :: Addr#
$tc'C:ExpMul3 = "'C:ExpMul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'C:ExpMul2 :: TrName
$tc'C:ExpMul2 = TrNameS $tc'C:ExpMul3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'C:ExpMul :: TyCon
$tc'C:ExpMul
  = TyCon
      12046460716746065670##
      1356137612035434625##
      $trModule
      $tc'C:ExpMul2
      1#
      $tc'C:ExpMul1



[ 4 of 11] Compiling Interpret.Print  ( src/Interpret/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Interpret/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 112, types: 78, coercions: 0, joins: 1/2}

-- RHS size: {terms: 28, types: 38, coercions: 0, joins: 1/2}
mkPrint :: forall tm. [PrintRule tm] -> tm -> Maybe String
mkPrint
  = \ (@ tm) (rules :: [PrintRule tm]) (eta :: tm) ->
      letrec {
        pr :: tm -> Maybe String
        pr
          = \ (tm1 :: tm) ->
              joinrec {
                go :: [PrintRule tm] -> Maybe String
                go (ds :: [PrintRule tm])
                  = case ds of {
                      [] -> Nothing;
                      : y ys ->
                        case y of { PrintRule f ->
                        case f pr tm1 of wild2 {
                          Nothing -> jump go ys;
                          Just ipv -> wild2
                        }
                        }
                    }; } in
              jump go rules; } in
      pr eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Interpret.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcChar []

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1 :: [KindRep]
$krep1 = : $krep []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepTyConApp $tc[] $krep1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep3 :: [KindRep]
$krep3 = : $krep2 []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepTyConApp $tcMaybe $krep3

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepFun $krep5 $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7 :: KindRep
$krep7 = KindRepFun $krep6 $krep6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcPrintRule2 :: Addr#
$tcPrintRule2 = "PrintRule"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcPrintRule1 :: TrName
$tcPrintRule1 = TrNameS $tcPrintRule2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcPrintRule :: TyCon
$tcPrintRule
  = TyCon
      10958941186998107431##
      2343640925495199680##
      $trModule
      $tcPrintRule1
      0#
      krep$*Arr*

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep8 :: [KindRep]
$krep8 = : $krep5 []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9 :: KindRep
$krep9 = KindRepTyConApp $tcPrintRule $krep8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule1 :: KindRep
$tc'PrintRule1 = KindRepFun $krep7 $krep9

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule3 :: Addr#
$tc'PrintRule3 = "'PrintRule"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule2 :: TrName
$tc'PrintRule2 = TrNameS $tc'PrintRule3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule :: TyCon
$tc'PrintRule
  = TyCon
      13532533845655252715##
      5022127262841619329##
      $trModule
      $tc'PrintRule2
      1#
      $tc'PrintRule1



[ 3 of 20] Compiling Term             ( src/Term.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Term.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 214, types: 110, coercions: 95, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fExpBasePrint5 :: Addr#
$fExpBasePrint5 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fExpBasePrint4 :: Addr#
$fExpBasePrint4 = ") + ("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fExpBasePrint3 :: Addr#
$fExpBasePrint3 = ")"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fExpBasePrint2 :: [Char]
$fExpBasePrint2 = unpackCString# $fExpBasePrint3

-- RHS size: {terms: 11, types: 4, coercions: 2, joins: 0/0}
$fExpBasePrint1 :: Print -> Print -> [Char]
$fExpBasePrint1
  = \ (ds :: Print) (ds1 :: Print) ->
      unpackAppendCString#
        $fExpBasePrint5
        (++
           (ds `cast` <Co:1>)
           (unpackAppendCString#
              $fExpBasePrint4 (++ (ds1 `cast` <Co:1>) $fExpBasePrint2)))

-- RHS size: {terms: 3, types: 1, coercions: 10, joins: 0/0}
$fExpBasePrint :: ExpBase Print
$fExpBasePrint
  = C:ExpBase
      ($fShowInt_$cshow `cast` <Co:4>) ($fExpBasePrint1 `cast` <Co:6>)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fExpMulPrint2 :: Addr#
$fExpMulPrint2 = ") * ("#

-- RHS size: {terms: 11, types: 4, coercions: 2, joins: 0/0}
$fExpMulPrint1 :: Print -> Print -> [Char]
$fExpMulPrint1
  = \ (ds :: Print) (ds1 :: Print) ->
      unpackAppendCString#
        $fExpBasePrint5
        (++
           (ds `cast` <Co:1>)
           (unpackAppendCString#
              $fExpMulPrint2 (++ (ds1 `cast` <Co:1>) $fExpBasePrint2)))

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
$fExpMulPrint :: ExpMul Print
$fExpMulPrint = $fExpMulPrint1 `cast` <Co:10>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowPrint5 :: Addr#
$fShowPrint5 = "Print {"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowPrint4 :: [Char]
$fShowPrint4 = unpackCString# $fShowPrint5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowPrint3 :: Addr#
$fShowPrint3 = "runPrint = "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowPrint2 :: Addr#
$fShowPrint2 = "}"#

-- RHS size: {terms: 40, types: 13, coercions: 2, joins: 0/0}
$w$cshowsPrec :: Int# -> Print -> String -> String
$w$cshowsPrec
  = \ (ww :: Int#) (w :: Print) (w1 :: String) ->
      case tagToEnum# (>=# ww 11#) of {
        False ->
          ++
            $fShowPrint4
            (unpackAppendCString#
               $fShowPrint3
               (: $fShow(,)3
                  (showLitString
                     (w `cast` <Co:1>)
                     (: $fShow(,)3 (unpackAppendCString# $fShowPrint2 w1)))));
        True ->
          : $fShow(,)4
            (++
               $fShowPrint4
               (unpackAppendCString#
                  $fShowPrint3
                  (: $fShow(,)3
                     (showLitString
                        (w `cast` <Co:1>)
                        (: $fShow(,)3
                           (unpackAppendCString# $fShowPrint2 (: $fShow(,)2 w1)))))))
      }

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
$fShowPrint_$cshowsPrec :: Int -> Print -> ShowS
$fShowPrint_$cshowsPrec
  = \ (w :: Int) (w1 :: Print) (w2 :: String) ->
      case w of { I# ww1 -> $w$cshowsPrec ww1 w1 w2 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowPrint7 :: [Char]
$fShowPrint7 = unpackCString# $fShowPrint2

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$fShowPrint6 :: [Char]
$fShowPrint6 = : $fShow(,)3 $fShowPrint7

-- RHS size: {terms: 10, types: 3, coercions: 1, joins: 0/0}
$fShowPrint_$cshow :: Print -> String
$fShowPrint_$cshow
  = \ (x :: Print) ->
      ++
        $fShowPrint4
        (unpackAppendCString#
           $fShowPrint3
           (: $fShow(,)3 (showLitString (x `cast` <Co:1>) $fShowPrint6)))

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
$fShowPrint1 :: Print -> ShowS
$fShowPrint1
  = \ (w :: Print) (w1 :: String) -> $w$cshowsPrec 0# w w1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$fShowPrint_$cshowList :: [Print] -> ShowS
$fShowPrint_$cshowList = showList__ $fShowPrint1

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$fShowPrint :: Show Print
$fShowPrint
  = C:Show
      $fShowPrint_$cshowsPrec $fShowPrint_$cshow $fShowPrint_$cshowList

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
$fEqPrint :: Eq Print
$fEqPrint
  = C:Eq (eqString `cast` <Co:7>) ($fEq[]_$s$c/=1 `cast` <Co:7>)

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
$fOrdPrint :: Ord Print
$fOrdPrint
  = C:Ord
      $fEqPrint
      ($fOrd[]_$s$ccompare1 `cast` <Co:7>)
      ($fOrd[]_$s$c<1 `cast` <Co:7>)
      ($fOrd[]_$s$c<=1 `cast` <Co:7>)
      ($fOrd[]_$s$c>1 `cast` <Co:7>)
      ($fOrd[]_$s$c>=1 `cast` <Co:7>)
      ($fOrd[]_$s$cmax1 `cast` <Co:8>)
      ($fOrd[]_$s$cmin1 `cast` <Co:8>)

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
runPrint1 :: Print -> Print
runPrint1 = \ (ds :: Print) -> ds

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
runPrint :: Print -> String
runPrint = runPrint1 `cast` <Co:3>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Interpret.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcChar []

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1 :: [KindRep]
$krep1 = : $krep []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepTyConApp $tc[] $krep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcPrint2 :: Addr#
$tcPrint2 = "Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcPrint1 :: TrName
$tcPrint1 = TrNameS $tcPrint2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcPrint :: TyCon
$tcPrint
  = TyCon
      1075507527058703562##
      16482393331656468136##
      $trModule
      $tcPrint1
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepTyConApp $tcPrint []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Print1 :: KindRep
$tc'Print1 = KindRepFun $krep2 $krep3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Print3 :: Addr#
$tc'Print3 = "'Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Print2 :: TrName
$tc'Print2 = TrNameS $tc'Print3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Print :: TyCon
$tc'Print
  = TyCon
      178913704857179844##
      2891051689275283674##
      $trModule
      $tc'Print2
      0#
      $tc'Print1



[1 of 3] Compiling Term.Type        ( initial-bp-example-term-base-mul/Term/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-mul/build/initial-bp-example-term-base-mul/Term/Type.o )
[ 5 of 11] Compiling Example.Base.Print ( src/Example/Base/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Example/Base/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 72, types: 59, coercions: 2, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Base.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
print9 :: [Char]
print9
  = case $wshowSignedInt 0# 2# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) $fExpBasePrint2
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print8 :: [Char]
print8 = unpackAppendCString# $fExpBasePrint4 print9

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
print7 :: [Char]
print7
  = case $wshowSignedInt 0# 1# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) print8
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print6 :: [Char]
print6 = unpackAppendCString# $fExpBasePrint5 print7

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
print5 :: [Char]
print5 = ++ print6 $fExpBasePrint2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print4 :: [Char]
print4 = unpackAppendCString# $fExpBasePrint4 print5

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
print3 :: [Char]
print3
  = case $wshowSignedInt 0# 8# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) print4
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print2 :: [Char]
print2 = unpackAppendCString# $fExpBasePrint5 print3

-- RHS size: {terms: 1, types: 0, coercions: 2, joins: 0/0}
print1 :: Print
print1 = print2 `cast` <Co:2>



[ 6 of 11] Compiling Interpret.Eval   ( src/Interpret/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Interpret/Eval.o )

==================== Simplified expression ====================
makePrisms
  (mkNameG_tc
     (unpackCString#
        "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base"#)
     (unpackCString# "Term.Type"#)
     (unpackCString# "Term"#))


Configuring library 'initial-bp-print' for initial-bp-0.1.0.0..

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 204, types: 135, coercions: 303, joins: 0/0}

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$fExpBaseEval1 :: Int -> Int
$fExpBaseEval1 = \ (v :: Int) -> v

-- RHS size: {terms: 3, types: 1, coercions: 18, joins: 0/0}
$fExpBaseEval :: ExpBase Eval
$fExpBaseEval
  = C:ExpBase
      ($fExpBaseEval1 `cast` <Co:4>) ($fNumInt_$c+ `cast` <Co:14>)

-- RHS size: {terms: 1, types: 0, coercions: 18, joins: 0/0}
$fExpMulEval :: ExpMul Eval
$fExpMulEval = $fNumInt_$c* `cast` <Co:18>

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
$fGenericEval1 :: forall x. Rep Eval x -> Rep Eval x
$fGenericEval1 = \ (@ x) (ds :: Rep Eval x) -> ds

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$fGenericEval2 :: forall x. Eval -> Eval
$fGenericEval2 = \ (@ x) (x1 :: Eval) -> x1

-- RHS size: {terms: 3, types: 1, coercions: 192, joins: 0/0}
$fGenericEval :: Generic Eval
$fGenericEval
  = C:Generic
      ($fGenericEval2 `cast` <Co:97>) ($fGenericEval1 `cast` <Co:95>)

-- RHS size: {terms: 5, types: 3, coercions: 1, joins: 0/0}
$fNFDataEval_$crnf :: Eval -> ()
$fNFDataEval_$crnf
  = \ (x :: Eval) -> case x `cast` <Co:1> of { I# ipv -> () }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fNFDataEval :: NFData Eval
$fNFDataEval = $fNFDataEval_$crnf `cast` <Co:3>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowEval4 :: Addr#
$fShowEval4 = "Eval {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowEval3 :: Addr#
$fShowEval3 = "runEval = "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowEval2 :: Addr#
$fShowEval2 = "}"#

-- RHS size: {terms: 50, types: 31, coercions: 2, joins: 0/0}
$w$cshowsPrec :: Int# -> Eval -> String -> String
$w$cshowsPrec
  = \ (ww :: Int#) (w :: Eval) (w1 :: String) ->
      case tagToEnum# (>=# ww 11#) of {
        False ->
          unpackAppendCString#
            $fShowEval4
            (unpackAppendCString#
               $fShowEval3
               (case w `cast` <Co:1> of { I# ww3 ->
                case $wshowSignedInt 0# ww3 (unpackAppendCString# $fShowEval2 w1)
                of
                { (# ww5, ww6 #) ->
                : ww5 ww6
                }
                }));
        True ->
          : $fShow(,)4
            (unpackAppendCString#
               $fShowEval4
               (unpackAppendCString#
                  $fShowEval3
                  (case w `cast` <Co:1> of { I# ww3 ->
                   case $wshowSignedInt
                          0# ww3 (unpackAppendCString# $fShowEval2 (: $fShow(,)2 w1))
                   of
                   { (# ww5, ww6 #) ->
                   : ww5 ww6
                   }
                   })))
      }

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
$fShowEval_$cshowsPrec :: Int -> Eval -> ShowS
$fShowEval_$cshowsPrec
  = \ (w :: Int) (w1 :: Eval) (w2 :: String) ->
      case w of { I# ww1 -> $w$cshowsPrec ww1 w1 w2 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowEval5 :: [Char]
$fShowEval5 = unpackCString# $fShowEval2

-- RHS size: {terms: 17, types: 13, coercions: 1, joins: 0/0}
$fShowEval_$cshow :: Eval -> String
$fShowEval_$cshow
  = \ (x :: Eval) ->
      unpackAppendCString#
        $fShowEval4
        (unpackAppendCString#
           $fShowEval3
           (case x `cast` <Co:1> of { I# ww3 ->
            case $wshowSignedInt 0# ww3 $fShowEval5 of { (# ww5, ww6 #) ->
            : ww5 ww6
            }
            }))

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
$fShowEval1 :: Eval -> ShowS
$fShowEval1 = \ (w :: Eval) (w1 :: String) -> $w$cshowsPrec 0# w w1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$fShowEval_$cshowList :: [Eval] -> ShowS
$fShowEval_$cshowList = showList__ $fShowEval1

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$fShowEval :: Show Eval
$fShowEval
  = C:Show
      $fShowEval_$cshowsPrec $fShowEval_$cshow $fShowEval_$cshowList

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
$fEqEval :: Eq Eval
$fEqEval = C:Eq (eqInt `cast` <Co:7>) (neInt `cast` <Co:7>)

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
$fOrdEval :: Ord Eval
$fOrdEval
  = C:Ord
      $fEqEval
      (compareInt `cast` <Co:7>)
      (ltInt `cast` <Co:7>)
      (leInt `cast` <Co:7>)
      (gtInt `cast` <Co:7>)
      (geInt `cast` <Co:7>)
      ($fOrdInt_$cmax `cast` <Co:8>)
      ($fOrdInt_$cmin `cast` <Co:8>)

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
runEval1 :: Eval -> Eval
runEval1 = \ (ds :: Eval) -> ds

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
runEval :: Eval -> Int
runEval = runEval1 `cast` <Co:3>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Interpret.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcEval2 :: Addr#
$tcEval2 = "Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcEval1 :: TrName
$tcEval1 = TrNameS $tcEval2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcEval :: TyCon
$tcEval
  = TyCon
      15824382824028947385##
      9663270948317796019##
      $trModule
      $tcEval1
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepTyConApp $tcEval []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Eval1 :: KindRep
$tc'Eval1 = KindRepFun $krep $krep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Eval3 :: Addr#
$tc'Eval3 = "'Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Eval2 :: TrName
$tc'Eval2 = TrNameS $tc'Eval3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Eval :: TyCon
$tc'Eval
  = TyCon
      15938321307258681068##
      4983853947647050196##
      $trModule
      $tc'Eval2
      0#
      $tc'Eval1



[ 7 of 11] Compiling Example.Base.Eval ( src/Example/Base/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Example/Base/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 19, types: 7, coercions: 16, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Base.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
eval2 :: Int
eval2 = I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
eval1 :: Eval
eval1 = eval2 `cast` <Co:16>



[ 8 of 11] Compiling Final.Bench      ( src/Final/Bench.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Final/Bench.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 77, types: 33, coercions: 135, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Final.Bench"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 20, types: 3, coercions: 12, joins: 0/0}
evalAddMulBig1 :: Eval -> Int
evalAddMulBig1
  = \ (tm :: Eval) ->
      case tm `cast` <Co:12> of { I# x ->
      I# (+# (*# (+# x 3#) (+# x 5#)) (*# (+# x 7#) (+# x 11#)))
      }

-- RHS size: {terms: 1, types: 0, coercions: 18, joins: 0/0}
evalAddMulBig :: Eval -> Eval
evalAddMulBig = evalAddMulBig1 `cast` <Co:18>

-- RHS size: {terms: 12, types: 3, coercions: 12, joins: 0/0}
evalAddBig1 :: Eval -> Int
evalAddBig1
  = \ (tm :: Eval) ->
      case tm `cast` <Co:12> of { I# x -> I# (+# (+# x 3#) (+# x 5#)) }

-- RHS size: {terms: 1, types: 0, coercions: 18, joins: 0/0}
evalAddBig :: Eval -> Eval
evalAddBig = evalAddBig1 `cast` <Co:18>

-- RHS size: {terms: 10, types: 3, coercions: 12, joins: 0/0}
evalAddMulSmall1 :: Eval -> Int
evalAddMulSmall1
  = \ (tm :: Eval) ->
      case tm `cast` <Co:12> of { I# x -> I# (+# (*# x 3#) 5#) }

-- RHS size: {terms: 1, types: 0, coercions: 18, joins: 0/0}
evalAddMulSmall :: Eval -> Eval
evalAddMulSmall = evalAddMulSmall1 `cast` <Co:18>

-- RHS size: {terms: 4, types: 1, coercions: 25, joins: 0/0}
evalAddSmall1 :: Eval -> Int
evalAddSmall1
  = \ (tm :: Eval) ->
      $fNumInt_$c+ (tm `cast` <Co:12>) (tm `cast` <Co:13>)

-- RHS size: {terms: 1, types: 0, coercions: 18, joins: 0/0}
evalAddSmall :: Eval -> Eval
evalAddSmall = evalAddSmall1 `cast` <Co:18>

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lit1 :: Int
lit1 = I# 2#

-- RHS size: {terms: 1, types: 0, coercions: 2, joins: 0/0}
lit2 :: Eval
lit2 = lit1 `cast` <Co:2>




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 451, types: 403, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Addr#
lvl = "Add "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1 :: Addr#
lvl1 = "Lit "#

Rec {
-- RHS size: {terms: 79, types: 41, coercions: 0, joins: 0/0}
$w$cshowsPrec :: Int# -> Term -> String -> String
$w$cshowsPrec
  = \ (ww :: Int#) (w :: Term) (w1 :: String) ->
      case w of {
        Lit b1 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl1
                (case b1 of { I# ww3 ->
                 case $wshowSignedInt 11# ww3 w1 of { (# ww5, ww6 #) -> : ww5 ww6 }
                 });
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl1
                   (case b1 of { I# ww3 ->
                    case $wshowSignedInt 11# ww3 (: $fShow(,)2 w1) of
                    { (# ww5, ww6 #) ->
                    : ww5 ww6
                    }
                    }))
          };
        Add b1 b2 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl
                ($w$cshowsPrec 11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 w1)));
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl
                   ($w$cshowsPrec
                      11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 (: $fShow(,)2 w1)))))
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
$fShowTerm_$cshowsPrec :: Int -> Term -> ShowS
$fShowTerm_$cshowsPrec
  = \ (w :: Int) (w1 :: Term) (w2 :: String) ->
      case w of { I# ww1 -> $w$cshowsPrec ww1 w1 w2 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTerm2 :: Int
$fShowTerm2 = I# 0#

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$fShowTerm_$cshow :: Term -> String
$fShowTerm_$cshow = \ (x :: Term) -> $w$cshowsPrec 0# x []

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
$fShowTerm1 :: Term -> ShowS
$fShowTerm1 = \ (w :: Term) (w1 :: String) -> $w$cshowsPrec 0# w w1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$fShowTerm_$cshowList :: [Term] -> ShowS
$fShowTerm_$cshowList = showList__ $fShowTerm1

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$fShowTerm :: Show Term
$fShowTerm
  = C:Show
      $fShowTerm_$cshowsPrec $fShowTerm_$cshow $fShowTerm_$cshowList

Rec {
-- RHS size: {terms: 29, types: 15, coercions: 0, joins: 0/0}
$fEqTerm_$c== :: Term -> Term -> Bool
$fEqTerm_$c==
  = \ (ds :: Term) (ds1 :: Term) ->
      case ds of {
        Lit a1 ->
          case ds1 of {
            Lit b1 -> eqInt a1 b1;
            Add ipv ipv1 -> False
          };
        Add a1 a2 ->
          case ds1 of {
            Lit ipv -> False;
            Add b1 b2 ->
              case $fEqTerm_$c== a1 b1 of {
                False -> False;
                True -> $fEqTerm_$c== a2 b2
              }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fEqTerm_$c/= :: Term -> Term -> Bool
$fEqTerm_$c/=
  = \ (a :: Term) (b :: Term) ->
      case $fEqTerm_$c== a b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$fEqTerm :: Eq Term
$fEqTerm = C:Eq $fEqTerm_$c== $fEqTerm_$c/=

Rec {
-- RHS size: {terms: 31, types: 15, coercions: 0, joins: 0/0}
$fOrdTerm_$ccompare :: Term -> Term -> Ordering
$fOrdTerm_$ccompare
  = \ (a :: Term) (b :: Term) ->
      case a of {
        Lit a1 ->
          case b of {
            Lit b1 -> compareInt a1 b1;
            Add ipv ipv1 -> LT
          };
        Add a1 a2 ->
          case b of {
            Lit ipv -> GT;
            Add b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> LT;
                EQ -> $fOrdTerm_$ccompare a2 b2;
                GT -> GT
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 31, types: 15, coercions: 0, joins: 0/0}
$fOrdTerm_$c< :: Term -> Term -> Bool
$fOrdTerm_$c<
  = \ (a :: Term) (b :: Term) ->
      case a of {
        Lit a1 ->
          case b of {
            Lit b1 -> ltInt a1 b1;
            Add ipv ipv1 -> True
          };
        Add a1 a2 ->
          case b of {
            Lit ipv -> False;
            Add b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> True;
                EQ -> $fOrdTerm_$c< a2 b2;
                GT -> False
              }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$c<= :: Term -> Term -> Bool
$fOrdTerm_$c<=
  = \ (a :: Term) (b :: Term) ->
      case $fOrdTerm_$c< b a of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$cmax :: Term -> Term -> Term
$fOrdTerm_$cmax
  = \ (x :: Term) (y :: Term) ->
      case $fOrdTerm_$c< y x of {
        False -> y;
        True -> x
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$fOrdTerm_$c> :: Term -> Term -> Bool
$fOrdTerm_$c> = \ (a :: Term) (b :: Term) -> $fOrdTerm_$c< b a

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$c>= :: Term -> Term -> Bool
$fOrdTerm_$c>=
  = \ (a :: Term) (b :: Term) ->
      case $fOrdTerm_$c< a b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$cmin :: Term -> Term -> Term
$fOrdTerm_$cmin
  = \ (x :: Term) (y :: Term) ->
      case $fOrdTerm_$c< y x of {
        False -> x;
        True -> y
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
$fOrdTerm :: Ord Term
$fOrdTerm
  = C:Ord
      $fEqTerm
      $fOrdTerm_$ccompare
      $fOrdTerm_$c<
      $fOrdTerm_$c<=
      $fOrdTerm_$c>
      $fOrdTerm_$c>=
      $fOrdTerm_$cmax
      $fOrdTerm_$cmin

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
_Lit1 :: Term -> Either Term Int
_Lit1
  = \ (x :: Term) ->
      case x of wild {
        Lit y1 -> Right y1;
        Add ipv ipv1 -> Left wild
      }

-- RHS size: {terms: 29, types: 68, coercions: 0, joins: 0/2}
_Lit :: Prism' Term Int
_Lit
  = \ (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1 :: p (Either Term Int) (Either Term (f Int)) -> p Term (f Term)
        f1
          = dimap
              ($p1Choice $dChoice)
              _Lit1
              (let {
                 ds :: f Int -> f Term
                 ds = fmap ($p1Applicative $dApplicative) Lit } in
               \ (ds1 :: Either Term (f Int)) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p Int (f Int)) -> f1 (right' $dChoice x)

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/0}
_Add2 :: Term -> Either Term (Term, Term)
_Add2
  = \ (x :: Term) ->
      case x of wild {
        Lit ipv -> Left wild;
        Add y1 y2 -> Right (y1, y2)
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
_Add1 :: (Term, Term) -> Term
_Add1
  = \ (ds :: (Term, Term)) -> case ds of { (x1, x2) -> Add x1 x2 }

-- RHS size: {terms: 29, types: 94, coercions: 0, joins: 0/2}
_Add :: Prism' Term (Term, Term)
_Add
  = \ (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1
          :: p (Either Term (Term, Term)) (Either Term (f (Term, Term)))
             -> p Term (f Term)
        f1
          = dimap
              ($p1Choice $dChoice)
              _Add2
              (let {
                 ds :: f (Term, Term) -> f Term
                 ds = fmap ($p1Applicative $dApplicative) _Add1 } in
               \ (ds1 :: Either Term (f (Term, Term))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Term, Term) (f (Term, Term))) -> f1 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcTerm2 :: Addr#
$tcTerm2 = "Term"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcTerm1 :: TrName
$tcTerm1 = TrNameS $tcTerm2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcTerm :: TyCon
$tcTerm
  = TyCon
      13125389909717632925##
      158444914085072705##
      $trModule
      $tcTerm1
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepTyConApp $tcTerm []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Lit1 :: KindRep
$tc'Lit1 = KindRepFun $krep $krep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Lit3 :: Addr#
$tc'Lit3 = "'Lit"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Lit2 :: TrName
$tc'Lit2 = TrNameS $tc'Lit3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Lit :: TyCon
$tc'Lit
  = TyCon
      2127915294760195072##
      6083989906909856787##
      $trModule
      $tc'Lit2
      0#
      $tc'Lit1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepFun $krep1 $krep1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Add1 :: KindRep
$tc'Add1 = KindRepFun $krep1 $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Add3 :: Addr#
$tc'Add3 = "'Add"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Add2 :: TrName
$tc'Add2 = TrNameS $tc'Add3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Add :: TyCon
$tc'Add
  = TyCon
      3340925227475816255##
      17560363796720736399##
      $trModule
      $tc'Add2
      0#
      $tc'Add1



[ 9 of 11] Compiling Example.Mul      ( src/Example/Mul.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Example/Mul.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 49, types: 40, coercions: 4, joins: 0/0}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term6 :: Int
term6 = I# 7#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term5 :: Int
term5 = I# 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term1 :: Int
term1 = I# 2#

-- RHS size: {terms: 15, types: 10, coercions: 2, joins: 0/0}
term2 :: forall repr. (ExpBase repr, ExpMul repr) => repr
term2
  = \ (@ repr)
      ($dExpBase :: ExpBase repr)
      ($dExpMul :: ExpMul repr) ->
      add
        $dExpBase
        (lit $dExpBase term6)
        (($dExpMul `cast` <Co:2>)
           (lit $dExpBase term5) (lit $dExpBase term1))

-- RHS size: {terms: 9, types: 8, coercions: 2, joins: 0/0}
term3 :: forall repr. (ExpBase repr, ExpMul repr) => repr
term3
  = \ (@ repr)
      ($dExpBase :: ExpBase repr)
      ($dExpMul :: ExpMul repr) ->
      ($dExpMul `cast` <Co:2>) (lit $dExpBase term6) (term1 $dExpBase)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Simplified expression ====================
makeWrapped
  (mkNameG_tc
     (unpackCString# "initial-0.1.0.0-inplace"#)
     (unpackCString# "Term"#)
     (unpackCString# "Term"#))


[10 of 11] Compiling Example.Mul.Print ( src/Example/Mul/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Example/Mul/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 144, types: 121, coercions: 6, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Mul.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
print11 :: [Char]
print11
  = case $wshowSignedInt 0# 2# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) $fExpBasePrint2
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print10 :: [Char]
print10 = unpackAppendCString# $fExpBasePrint4 print11

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
print9 :: [Char]
print9
  = case $wshowSignedInt 0# 1# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) print10
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print8 :: [Char]
print8 = unpackAppendCString# $fExpBasePrint5 print9

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
print7 :: [Char]
print7 = ++ print8 $fExpBasePrint2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print6 :: [Char]
print6 = unpackAppendCString# $fExpBasePrint4 print7

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
print5 :: [Char]
print5
  = case $wshowSignedInt 0# 8# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) print6
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print4 :: [Char]
print4 = unpackAppendCString# $fExpBasePrint5 print5

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
print22 :: [Char]
print22 = ++ print4 $fExpBasePrint2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print21 :: [Char]
print21 = unpackAppendCString# $fExpMulPrint2 print22

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
print20 :: [Char]
print20
  = case $wshowSignedInt 0# 7# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) print21
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print19 :: [Char]
print19 = unpackAppendCString# $fExpBasePrint5 print20

-- RHS size: {terms: 1, types: 0, coercions: 2, joins: 0/0}
print3 :: Print
print3 = print19 `cast` <Co:2>

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print18 :: [Char]
print18 = unpackAppendCString# $fExpMulPrint2 print11

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
print17 :: [Char]
print17
  = case $wshowSignedInt 0# 1# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) print18
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print16 :: [Char]
print16 = unpackAppendCString# $fExpBasePrint5 print17

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
print15 :: [Char]
print15 = ++ print16 $fExpBasePrint2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print14 :: [Char]
print14 = unpackAppendCString# $fExpBasePrint4 print15

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
print13 :: [Char]
print13
  = case $wshowSignedInt 0# 7# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) print14
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
print12 :: [Char]
print12 = unpackAppendCString# $fExpBasePrint5 print13

-- RHS size: {terms: 1, types: 0, coercions: 2, joins: 0/0}
print2 :: Print
print2 = print12 `cast` <Co:2>

-- RHS size: {terms: 1, types: 0, coercions: 2, joins: 0/0}
print1 :: Print
print1 = print4 `cast` <Co:2>



[2 of 2] Compiling Base.Type        ( initial-bp-example-term-base/Base/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base/build/initial-bp-example-term-base/Base/Type.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Simplified expression ====================
makePrisms
  (mkNameG_tc
     (unpackCString#
        "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul"#)
     (unpackCString# "Term.Type"#)
     (unpackCString# "Term"#))


[11 of 11] Compiling Example.Mul.Eval ( src/Example/Mul/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-0.1.0.0/build/Example/Mul/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 29, types: 11, coercions: 48, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Mul.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
eval6 :: Int
eval6 = I# 77#

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
eval3 :: Eval
eval3 = eval6 `cast` <Co:16>

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
eval5 :: Int
eval5 = I# 9#

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
eval2 :: Eval
eval2 = eval5 `cast` <Co:16>

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
eval4 :: Int
eval4 = I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
eval1 :: Eval
eval1 = eval4 `cast` <Co:16>



Configuring library 'initial-bp-term' for initial-bp-0.1.0.0..
Configuring library for vanilla-0.1.0.0..

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 146, types: 474, coercions: 399, joins: 0/0}

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
$fRewrappedTermt4
  :: forall (f :: (* -> *) -> * -> *) a. Term f a -> Term f a
$fRewrappedTermt4
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (ds :: Term f a) -> ds

-- RHS size: {terms: 4, types: 14, coercions: 0, joins: 0/0}
$fRewrappedTermt3
  :: forall (f :: (* -> *) -> * -> *) a. f (Term f) a -> f (Term f) a
$fRewrappedTermt3
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (v :: f (Term f) a) -> v

-- RHS size: {terms: 12, types: 53, coercions: 16, joins: 0/0}
$fRewrappedTermt2
  :: forall (f1 :: (* -> *) -> * -> *) a (p :: * -> * -> *) (f2 :: *
                                                                   -> *).
     (Profunctor p, Functor f2) =>
     p (f1 (Term f1) a) (f2 (f1 (Term f1) a))
     -> p (Term f1 a) (f2 (Term f1 a))
$fRewrappedTermt2
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      ($dProfunctor :: Profunctor p)
      ($dFunctor :: Functor f1) ->
      dimap
        $dProfunctor
        ($fRewrappedTermt4 `cast` <Co:7>)
        (fmap $dFunctor ($fRewrappedTermt3 `cast` <Co:9>))

-- RHS size: {terms: 1, types: 0, coercions: 55, joins: 0/0}
$fWrappedTerm
  :: forall (f :: (* -> *) -> * -> *) a. Wrapped (Term f a)
$fWrappedTerm = $fRewrappedTermt2 `cast` <Co:55>

-- RHS size: {terms: 17, types: 64, coercions: 26, joins: 0/0}
$fRewrappedTermt1
  :: forall (f1 :: (* -> *) -> * -> *) a1 t (f2 :: (* -> *)
                                                   -> * -> *) a2.
     (Term f1 a1 :: *) ~ (t :: *) =>
     forall (p :: * -> * -> *) (f3 :: * -> *).
     (Profunctor p, Functor f3) =>
     p (Unwrapped (Term f2 a2)) (f3 (Unwrapped (Term f2 a2)))
     -> p (Term f2 a2) (f3 (Term f2 a2))
$fRewrappedTermt1
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      (@ t)
      (@ (f1 :: (* -> *) -> * -> *))
      (@ a1)
      ($d~ :: (Term f a :: *) ~ (t :: *))
      (@ (p :: * -> * -> *))
      (@ (f2 :: * -> *))
      (eta :: Profunctor p)
      (eta1 :: Functor f2) ->
      case HEq_sc ($d~ `cast` <Co:7>) of cobox { __DEFAULT ->
      ($fRewrappedTermt2 eta eta1) `cast` <Co:19>
      }

-- RHS size: {terms: 1, types: 0, coercions: 55, joins: 0/0}
$fRewrappedTermt
  :: forall (f1 :: (* -> *) -> * -> *) a1 t (f2 :: (* -> *)
                                                   -> * -> *) a2.
     (Term f1 a1 :: *) ~ (t :: *) =>
     Rewrapped (Term f2 a2) t
$fRewrappedTermt = $fRewrappedTermt1 `cast` <Co:55>

-- RHS size: {terms: 5, types: 16, coercions: 0, joins: 0/0}
$fGenericTerm1
  :: forall (f :: (* -> *) -> * -> *) a x.
     Rep (Term f a) x -> Rep (Term f a) x
$fGenericTerm1
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      (@ x)
      (ds :: Rep (Term f a) x) ->
      ds

-- RHS size: {terms: 5, types: 14, coercions: 0, joins: 0/0}
$fGenericTerm2
  :: forall (f :: (* -> *) -> * -> *) a x. Term f a -> Term f a
$fGenericTerm2
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (@ x) (x1 :: Term f a) ->
      x1

-- RHS size: {terms: 5, types: 17, coercions: 228, joins: 0/0}
$fGenericTerm
  :: forall (f :: (* -> *) -> * -> *) a. Generic (Term f a)
$fGenericTerm
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) ->
      C:Generic
        ($fGenericTerm2 `cast` <Co:115>) ($fGenericTerm1 `cast` <Co:113>)

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
unTerm
  :: forall (f :: (* -> *) -> * -> *) a. Term f a -> f (Term f) a
unTerm = $fRewrappedTermt4 `cast` <Co:19>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepFun krep$*Arr* krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcTerm1 :: KindRep
$tcTerm1 = KindRepFun $krep krep$*Arr*

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepVar 0#

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcTerm :: TyCon
$tcTerm
  = TyCon
      15756675435763705103##
      1974243616314611459##
      $trModule
      $trModule1
      0#
      $tcTerm1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep3 :: [KindRep]
$krep3 = : $krep2 []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepTyConApp $tcTerm $krep3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepApp $krep2 $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepApp $krep5 $krep1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep7 :: [KindRep]
$krep7 = : $krep1 []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep8 :: [KindRep]
$krep8 = : $krep2 $krep7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9 :: KindRep
$krep9 = KindRepTyConApp $tcTerm $krep8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Term1 :: KindRep
$tc'Term1 = KindRepFun $krep6 $krep9

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Term3 :: Addr#
$tc'Term3 = "'Term"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Term2 :: TrName
$tc'Term2 = TrNameS $tc'Term3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Term :: TyCon
$tc'Term
  = TyCon
      16382515239660425439##
      10304933754316970846##
      $trModule
      $tc'Term2
      2#
      $tc'Term1



[ 4 of 20] Compiling Mul.Type         ( src/Mul/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Mul/Type.o )

==================== Simplified expression ====================
makePrisms
  (mkNameG_tc
     (unpackCString# "initial-0.1.0.0-inplace"#)
     (unpackCString# "Mul.Type"#)
     (unpackCString# "MulF"#))



==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 706, types: 1,815, coercions: 716, joins: 0/6}

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
$WLit :: Int -> Term
$WLit = \ (dt :: Int) -> case dt of { I# dt -> Lit dt }

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
$WAdd :: Term -> Term -> Term
$WAdd
  = \ (dt :: Term) (dt :: Term) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> Add dt dt }
      }

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
$WMul :: Term -> Term -> Term
$WMul
  = \ (dt :: Term) (dt :: Term) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> Mul dt dt }
      }

-- RHS size: {terms: 24, types: 528, coercions: 347, joins: 0/0}
$fGenericTerm_$cto :: forall x. Rep Term x -> Term
$fGenericTerm_$cto
  = \ (@ x) (ds :: Rep Term x) ->
      case ds `cast` <Co:124> of {
        L1 ds1 -> $WLit (ds1 `cast` <Co:47>);
        R1 ds1 ->
          case ds1 of {
            L1 ds2 ->
              case ds2 `cast` <Co:42> of { :*: ds3 ds4 ->
              $WAdd (ds3 `cast` <Co:23>) (ds4 `cast` <Co:23>)
              };
            R1 ds2 ->
              case ds2 `cast` <Co:42> of { :*: ds3 ds4 ->
              $WMul (ds3 `cast` <Co:23>) (ds4 `cast` <Co:23>)
              }
          }
      }

-- RHS size: {terms: 20, types: 577, coercions: 236, joins: 0/0}
$fGenericTerm1
  :: forall x.
     Term
     -> (:+:)
          (M1
             C
             ('MetaCons "Lit" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedUnpack)
                (K1 R Int)))
          (M1
             C
             ('MetaCons "Add" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                (K1 R Term)
              :*: M1
                    S
                    ('MetaSel
                       'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                    (K1 R Term))
           :+: M1
                 C
                 ('MetaCons "Mul" 'PrefixI 'False)
                 (M1
                    S
                    ('MetaSel
                       'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                    (K1 R Term)
                  :*: M1
                        S
                        ('MetaSel
                           'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                        (K1 R Term)))
          x
$fGenericTerm1
  = \ (@ x) (x1 :: Term) ->
      case x1 of {
        Lit dt -> L1 ((I# dt) `cast` <Co:50>);
        Add g1 g2 ->
          R1
            (L1
               ((:*: (g1 `cast` <Co:25>) (g2 `cast` <Co:25>)) `cast` <Co:43>));
        Mul g1 g2 ->
          R1
            (R1 ((:*: (g1 `cast` <Co:25>) (g2 `cast` <Co:25>)) `cast` <Co:43>))
      }

-- RHS size: {terms: 3, types: 1, coercions: 130, joins: 0/0}
$fGenericTerm :: Generic Term
$fGenericTerm
  = C:Generic ($fGenericTerm1 `cast` <Co:130>) $fGenericTerm_$cto

Rec {
-- RHS size: {terms: 19, types: 9, coercions: 0, joins: 0/0}
$fNFDataTerm_$crnf :: Term -> ()
$fNFDataTerm_$crnf
  = \ (x :: Term) ->
      case x of {
        Lit dt -> ();
        Add g1 g2 ->
          case $fNFDataTerm_$crnf g1 of { () -> $fNFDataTerm_$crnf g2 };
        Mul g1 g2 ->
          case $fNFDataTerm_$crnf g1 of { () -> $fNFDataTerm_$crnf g2 }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fNFDataTerm :: NFData Term
$fNFDataTerm = $fNFDataTerm_$crnf `cast` <Co:3>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Addr#
lvl = "Mul "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1 :: Addr#
lvl1 = "Add "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2 :: Addr#
lvl2 = "Lit "#

Rec {
-- RHS size: {terms: 107, types: 45, coercions: 0, joins: 0/0}
$w$cshowsPrec :: Int# -> Term -> String -> String
$w$cshowsPrec
  = \ (ww :: Int#) (w :: Term) (w1 :: String) ->
      case w of {
        Lit dt ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl2
                (case $wshowSignedInt 11# dt w1 of { (# ww5, ww6 #) ->
                 : ww5 ww6
                 });
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl2
                   (case $wshowSignedInt 11# dt (: $fShow(,)2 w1) of
                    { (# ww5, ww6 #) ->
                    : ww5 ww6
                    }))
          };
        Add b1 b2 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl1
                ($w$cshowsPrec 11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 w1)));
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl1
                   ($w$cshowsPrec
                      11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 (: $fShow(,)2 w1)))))
          };
        Mul b1 b2 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl
                ($w$cshowsPrec 11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 w1)));
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl
                   ($w$cshowsPrec
                      11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 (: $fShow(,)2 w1)))))
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
$fShowTerm_$cshowsPrec :: Int -> Term -> ShowS
$fShowTerm_$cshowsPrec
  = \ (w :: Int) (w1 :: Term) (w2 :: String) ->
      case w of { I# ww1 -> $w$cshowsPrec ww1 w1 w2 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTerm2 :: Int
$fShowTerm2 = I# 0#

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$fShowTerm_$cshow :: Term -> String
$fShowTerm_$cshow = \ (x :: Term) -> $w$cshowsPrec 0# x []

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
$fShowTerm1 :: Term -> ShowS
$fShowTerm1 = \ (w :: Term) (w1 :: String) -> $w$cshowsPrec 0# w w1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$fShowTerm_$cshowList :: [Term] -> ShowS
$fShowTerm_$cshowList = showList__ $fShowTerm1

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$fShowTerm :: Show Term
$fShowTerm
  = C:Show
      $fShowTerm_$cshowsPrec $fShowTerm_$cshow $fShowTerm_$cshowList

Rec {
-- RHS size: {terms: 46, types: 19, coercions: 0, joins: 0/0}
$fEqTerm_$c== :: Term -> Term -> Bool
$fEqTerm_$c==
  = \ (ds :: Term) (ds1 :: Term) ->
      case ds of {
        Lit dt ->
          case ds1 of {
            __DEFAULT -> False;
            Lit dt1 -> tagToEnum# (==# dt dt1)
          };
        Add a1 a2 ->
          case ds1 of {
            __DEFAULT -> False;
            Add b1 b2 ->
              case $fEqTerm_$c== a1 b1 of {
                False -> False;
                True -> $fEqTerm_$c== a2 b2
              }
          };
        Mul a1 a2 ->
          case ds1 of {
            __DEFAULT -> False;
            Mul b1 b2 ->
              case $fEqTerm_$c== a1 b1 of {
                False -> False;
                True -> $fEqTerm_$c== a2 b2
              }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fEqTerm_$c/= :: Term -> Term -> Bool
$fEqTerm_$c/=
  = \ (a :: Term) (b :: Term) ->
      case $fEqTerm_$c== a b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$fEqTerm :: Eq Term
$fEqTerm = C:Eq $fEqTerm_$c== $fEqTerm_$c/=

Rec {
-- RHS size: {terms: 51, types: 21, coercions: 0, joins: 0/0}
$fOrdTerm_$ccompare :: Term -> Term -> Ordering
$fOrdTerm_$ccompare
  = \ (a :: Term) (b :: Term) ->
      case a of {
        Lit dt ->
          case b of {
            __DEFAULT -> LT;
            Lit dt1 -> compareInt# dt dt1
          };
        Add a1 a2 ->
          case b of {
            Lit dt -> GT;
            Add b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> LT;
                EQ -> $fOrdTerm_$ccompare a2 b2;
                GT -> GT
              };
            Mul ipv ipv1 -> LT
          };
        Mul a1 a2 ->
          case b of {
            __DEFAULT -> GT;
            Mul b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> LT;
                EQ -> $fOrdTerm_$ccompare a2 b2;
                GT -> GT
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 52, types: 22, coercions: 0, joins: 0/0}
$fOrdTerm_$c< :: Term -> Term -> Bool
$fOrdTerm_$c<
  = \ (a :: Term) (b :: Term) ->
      case a of {
        Lit dt ->
          case b of {
            __DEFAULT -> True;
            Lit dt1 -> tagToEnum# (<# dt dt1)
          };
        Add a1 a2 ->
          case b of {
            Lit dt -> False;
            Add b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> True;
                EQ -> $fOrdTerm_$c< a2 b2;
                GT -> False
              };
            Mul ipv ipv1 -> True
          };
        Mul a1 a2 ->
          case b of {
            __DEFAULT -> False;
            Mul b1 b2 ->
              case $fOrdTerm_$ccompare a1 b1 of {
                LT -> True;
                EQ -> $fOrdTerm_$c< a2 b2;
                GT -> False
              }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$c<= :: Term -> Term -> Bool
$fOrdTerm_$c<=
  = \ (a :: Term) (b :: Term) ->
      case $fOrdTerm_$c< b a of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$cmax :: Term -> Term -> Term
$fOrdTerm_$cmax
  = \ (x :: Term) (y :: Term) ->
      case $fOrdTerm_$c< y x of {
        False -> y;
        True -> x
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$fOrdTerm_$c> :: Term -> Term -> Bool
$fOrdTerm_$c> = \ (a :: Term) (b :: Term) -> $fOrdTerm_$c< b a

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$c>= :: Term -> Term -> Bool
$fOrdTerm_$c>=
  = \ (a :: Term) (b :: Term) ->
      case $fOrdTerm_$c< a b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fOrdTerm_$cmin :: Term -> Term -> Term
$fOrdTerm_$cmin
  = \ (x :: Term) (y :: Term) ->
      case $fOrdTerm_$c< y x of {
        False -> x;
        True -> y
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
$fOrdTerm :: Ord Term
$fOrdTerm
  = C:Ord
      $fEqTerm
      $fOrdTerm_$ccompare
      $fOrdTerm_$c<
      $fOrdTerm_$c<=
      $fOrdTerm_$c>
      $fOrdTerm_$c>=
      $fOrdTerm_$cmax
      $fOrdTerm_$cmin

-- RHS size: {terms: 10, types: 7, coercions: 0, joins: 0/0}
_Lit1 :: Term -> Either Term Int
_Lit1
  = \ (x :: Term) ->
      case x of wild {
        __DEFAULT -> Left wild;
        Lit dt -> Right (I# dt)
      }

-- RHS size: {terms: 29, types: 68, coercions: 0, joins: 0/2}
_Lit :: Prism' Term Int
_Lit
  = \ (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1 :: p (Either Term Int) (Either Term (f Int)) -> p Term (f Term)
        f1
          = dimap
              ($p1Choice $dChoice)
              _Lit1
              (let {
                 ds :: f Int -> f Term
                 ds = fmap ($p1Applicative $dApplicative) $WLit } in
               \ (ds1 :: Either Term (f Int)) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p Int (f Int)) -> f1 (right' $dChoice x)

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
_Add2 :: Term -> Either Term (Term, Term)
_Add2
  = \ (x :: Term) ->
      case x of wild {
        __DEFAULT -> Left wild;
        Add y1 y2 -> Right (y1, y2)
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
_Add1 :: (Term, Term) -> Term
_Add1
  = \ (ds :: (Term, Term)) -> case ds of { (x1, x2) -> $WAdd x1 x2 }

-- RHS size: {terms: 29, types: 94, coercions: 0, joins: 0/2}
_Add :: Prism' Term (Term, Term)
_Add
  = \ (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1
          :: p (Either Term (Term, Term)) (Either Term (f (Term, Term)))
             -> p Term (f Term)
        f1
          = dimap
              ($p1Choice $dChoice)
              _Add2
              (let {
                 ds :: f (Term, Term) -> f Term
                 ds = fmap ($p1Applicative $dApplicative) _Add1 } in
               \ (ds1 :: Either Term (f (Term, Term))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Term, Term) (f (Term, Term))) -> f1 (right' $dChoice x)

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
_Mul2 :: Term -> Either Term (Term, Term)
_Mul2
  = \ (x :: Term) ->
      case x of wild {
        __DEFAULT -> Left wild;
        Mul y1 y2 -> Right (y1, y2)
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
_Mul1 :: (Term, Term) -> Term
_Mul1
  = \ (ds :: (Term, Term)) -> case ds of { (x1, x2) -> $WMul x1 x2 }

-- RHS size: {terms: 29, types: 94, coercions: 0, joins: 0/2}
_Mul :: Prism' Term (Term, Term)
_Mul
  = \ (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1
          :: p (Either Term (Term, Term)) (Either Term (f (Term, Term)))
             -> p Term (f Term)
        f1
          = dimap
              ($p1Choice $dChoice)
              _Mul2
              (let {
                 ds :: f (Term, Term) -> f Term
                 ds = fmap ($p1Applicative $dApplicative) _Mul1 } in
               \ (ds1 :: Either Term (f (Term, Term))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Term, Term) (f (Term, Term))) -> f1 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcTerm2 :: Addr#
$tcTerm2 = "Term"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcTerm1 :: TrName
$tcTerm1 = TrNameS $tcTerm2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcTerm :: TyCon
$tcTerm
  = TyCon
      2630348280895690721##
      15105938534310112005##
      $trModule
      $tcTerm1
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepTyConApp $tcTerm []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Lit1 :: KindRep
$tc'Lit1 = KindRepFun $krep $krep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Lit3 :: Addr#
$tc'Lit3 = "'Lit"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Lit2 :: TrName
$tc'Lit2 = TrNameS $tc'Lit3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Lit :: TyCon
$tc'Lit
  = TyCon
      7433755091468295160##
      2253289015062990466##
      $trModule
      $tc'Lit2
      0#
      $tc'Lit1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepFun $krep1 $krep1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Add1 :: KindRep
$tc'Add1 = KindRepFun $krep1 $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Add3 :: Addr#
$tc'Add3 = "'Add"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Add2 :: TrName
$tc'Add2 = TrNameS $tc'Add3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Add :: TyCon
$tc'Add
  = TyCon
      13550697149459958477##
      17169862476243244848##
      $trModule
      $tc'Add2
      0#
      $tc'Add1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Mul2 :: Addr#
$tc'Mul2 = "'Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Mul1 :: TrName
$tc'Mul1 = TrNameS $tc'Mul2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Mul :: TyCon
$tc'Mul
  = TyCon
      6038886010926779136##
      14959456524522162931##
      $trModule
      $tc'Mul1
      0#
      $tc'Add1



Configuring library 'final-bp-mul' for final-bp-0.1.0.0..
[2 of 3] Compiling Mul.Type         ( initial-bp-example-term-base-mul/Mul/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-mul/build/initial-bp-example-term-base-mul/Mul/Type.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[3 of 3] Compiling Base.Type        ( initial-bp-example-term-base-mul/Base/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-mul/build/initial-bp-example-term-base-mul/Base/Type.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 659, types: 1,620, coercions: 728, joins: 0/7}

-- RHS size: {terms: 3, types: 10, coercions: 2, joins: 0/0}
_MulF
  :: forall (tm :: (* -> *) -> * -> *).
     HasMulF tm =>
     forall (f :: * -> *) a. Prism' (tm f a) (MulF f a)
_MulF
  = \ (@ (tm :: (* -> *) -> * -> *)) (v :: HasMulF tm) ->
      v `cast` <Co:2>

-- RHS size: {terms: 13, types: 16, coercions: 0, joins: 0/0}
$WTmMul :: forall (f :: * -> *) a. f a -> f a -> MulF f a
$WTmMul
  = \ (@ (f :: * -> *))
      (@ a)
      (dt :: f[sk:1] a[sk:1])
      (dt :: f[sk:1] a[sk:1]) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> TmMul dt dt }
      }

-- RHS size: {terms: 7, types: 28, coercions: 0, joins: 0/0}
$fHasMulFMulF_$c_MulF
  :: forall (f :: * -> *) a. Prism' (MulF f a) (MulF f a)
$fHasMulFMulF_$c_MulF
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      _
      _ ->
      id

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fHasMulFMulF :: HasMulF MulF
$fHasMulFMulF = $fHasMulFMulF_$c_MulF `cast` <Co:3>

-- RHS size: {terms: 10, types: 84, coercions: 152, joins: 0/0}
$fGenericMulF_$cto
  :: forall (f :: * -> *) a x. Rep (MulF f a) x -> MulF f a
$fGenericMulF_$cto
  = \ (@ (f :: * -> *)) (@ a) (@ x) (ds :: Rep (MulF f a) x) ->
      case ds `cast` <Co:102> of { :*: ds1 ds2 ->
      $WTmMul (ds1 `cast` <Co:25>) (ds2 `cast` <Co:25>)
      }

-- RHS size: {terms: 10, types: 52, coercions: 99, joins: 0/0}
$fGenericMulF1
  :: forall (f :: * -> *) a x.
     MulF f a
     -> M1
          C
          ('MetaCons "TmMul" 'PrefixI 'False)
          (M1
             S
             ('MetaSel
                'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
             (K1 R (f a))
           :*: M1
                 S
                 ('MetaSel
                    'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                 (K1 R (f a)))
          x
$fGenericMulF1
  = \ (@ (f :: * -> *)) (@ a) (@ x) (x1 :: MulF f a) ->
      case x1 of { TmMul g1 g2 ->
      (:*: (g1 `cast` <Co:27>) (g2 `cast` <Co:27>)) `cast` <Co:45>
      }

-- RHS size: {terms: 5, types: 13, coercions: 66, joins: 0/0}
$fGenericMulF :: forall (f :: * -> *) a. Generic (MulF f a)
$fGenericMulF
  = \ (@ (f :: * -> *)) (@ a) ->
      C:Generic ($fGenericMulF1 `cast` <Co:66>) $fGenericMulF_$cto

-- RHS size: {terms: 13, types: 20, coercions: 6, joins: 0/0}
$fNFDataMulF_$crnf
  :: forall (f :: * -> *) a. NFData (f a) => MulF f a -> ()
$fNFDataMulF_$crnf
  = \ (@ (f :: * -> *))
      (@ a)
      ($dNFData :: NFData (f a))
      (eta :: MulF f a) ->
      case eta of { TmMul g1 g2 ->
      case ($dNFData `cast` <Co:3>) g1 of { () ->
      ($dNFData `cast` <Co:3>) g2
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
$fNFDataMulF
  :: forall (f :: * -> *) a. NFData (f a) => NFData (MulF f a)
$fNFDataMulF = $fNFDataMulF_$crnf `cast` <Co:17>

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowMulF3 :: Int
$fShowMulF3 = I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowMulF2 :: Addr#
$fShowMulF2 = "TmMul "#

-- RHS size: {terms: 43, types: 30, coercions: 0, joins: 0/2}
$w$cshowsPrec
  :: forall (f :: * -> *) a.
     Show (f a) =>
     Int# -> f a -> f a -> ShowS
$w$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (ww :: Int#)
      (ww1
         :: f a
         Unf=OtherCon [])
      (ww2
         :: f a
         Unf=OtherCon []) ->
      let {
        f1 :: String -> String
        f1 = showsPrec w $fShowMulF3 ww1 } in
      let {
        g :: String -> String
        g = showsPrec w $fShowMulF3 ww2 } in
      case tagToEnum# (>=# ww 11#) of {
        False ->
          \ (x :: String) ->
            unpackAppendCString# $fShowMulF2 (f1 (: showSpace1 (g x)));
        True ->
          \ (x :: String) ->
            : $fShow(,)4
              (unpackAppendCString#
                 $fShowMulF2 (f1 (: showSpace1 (g (: $fShow(,)2 x)))))
      }

-- RHS size: {terms: 16, types: 24, coercions: 0, joins: 0/0}
$fShowMulF_$cshowsPrec
  :: forall (f :: * -> *) a. Show (f a) => Int -> MulF f a -> ShowS
$fShowMulF_$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (w1 :: Int)
      (w2 :: MulF f a) ->
      case w1 of { I# ww1 ->
      case w2 of { TmMul ww3 ww4 -> $w$cshowsPrec w ww1 ww3 ww4 }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowMulF1 :: Int
$fShowMulF1 = I# 0#

-- RHS size: {terms: 13, types: 22, coercions: 0, joins: 0/0}
$fShowMulF_$cshow
  :: forall (f :: * -> *) a. Show (f a) => MulF f a -> String
$fShowMulF_$cshow
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (x :: MulF f a) ->
      case x of { TmMul ww1 ww2 -> $w$cshowsPrec $dShow 0# ww1 ww2 [] }

-- RHS size: {terms: 17, types: 29, coercions: 0, joins: 0/0}
$fShowMulF_$cshowList
  :: forall (f :: * -> *) a. Show (f a) => [MulF f a] -> ShowS
$fShowMulF_$cshowList
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (eta :: [MulF f a])
      (eta1 :: String) ->
      showList__
        (\ (w :: MulF f a) ->
           case w of { TmMul ww1 ww2 -> $w$cshowsPrec $dShow 0# ww1 ww2 })
        eta
        eta1

-- RHS size: {terms: 10, types: 18, coercions: 0, joins: 0/0}
$fShowMulF :: forall (f :: * -> *) a. Show (f a) => Show (MulF f a)
$fShowMulF
  = \ (@ (f :: * -> *)) (@ a) ($dShow :: Show (f a)) ->
      C:Show
        ($fShowMulF_$cshowsPrec $dShow)
        ($fShowMulF_$cshow $dShow)
        ($fShowMulF_$cshowList $dShow)

-- RHS size: {terms: 25, types: 34, coercions: 0, joins: 0/0}
$fOrdMulF_$c<
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> Bool
$fOrdMulF_$c<
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of { TmMul ww1 ww2 ->
      case w2 of { TmMul ww4 ww5 ->
      case compare w ww1 ww4 of {
        LT -> True;
        EQ -> < w ww2 ww5;
        GT -> False
      }
      }
      }

-- RHS size: {terms: 25, types: 34, coercions: 0, joins: 0/0}
$fOrdMulF_$ccompare
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> Ordering
$fOrdMulF_$ccompare
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of { TmMul ww1 ww2 ->
      case w2 of { TmMul ww4 ww5 ->
      case compare w ww1 ww4 of {
        LT -> LT;
        EQ -> compare w ww2 ww5;
        GT -> GT
      }
      }
      }

-- RHS size: {terms: 23, types: 34, coercions: 0, joins: 0/0}
$fEqMulF_$c==
  :: forall (f :: * -> *) a. Eq (f a) => MulF f a -> MulF f a -> Bool
$fEqMulF_$c==
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Eq (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of { TmMul ww1 ww2 ->
      case w2 of { TmMul ww4 ww5 ->
      case == w ww1 ww4 of {
        False -> False;
        True -> == w ww2 ww5
      }
      }
      }

-- RHS size: {terms: 28, types: 35, coercions: 0, joins: 0/0}
$fEqMulF_$c/=
  :: forall (f :: * -> *) a. Eq (f a) => MulF f a -> MulF f a -> Bool
$fEqMulF_$c/=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dEq :: Eq (f a))
      (a1 :: MulF f a)
      (b :: MulF f a) ->
      case a1 of { TmMul ww1 ww2 ->
      case b of { TmMul ww4 ww5 ->
      case == $dEq ww1 ww4 of {
        False -> True;
        True ->
          case == $dEq ww2 ww5 of {
            False -> True;
            True -> False
          }
      }
      }
      }

-- RHS size: {terms: 8, types: 16, coercions: 0, joins: 0/0}
$fEqMulF :: forall (f :: * -> *) a. Eq (f a) => Eq (MulF f a)
$fEqMulF
  = \ (@ (f :: * -> *)) (@ a) ($dEq :: Eq (f a)) ->
      C:Eq ($fEqMulF_$c== $dEq) ($fEqMulF_$c/= $dEq)

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
$fOrdMulF_$cp1Ord
  :: forall (f :: * -> *) a. Ord (f a) => Eq (MulF f a)
$fOrdMulF_$cp1Ord
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      $fEqMulF ($p1Ord $dOrd)

-- RHS size: {terms: 26, types: 23, coercions: 0, joins: 0/0}
$w$c<=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     f a -> f a -> f a -> f a -> Bool
$w$c<=
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (ww
         :: f a
         Unf=OtherCon [])
      (ww1
         :: f a
         Unf=OtherCon [])
      (ww2
         :: f a
         Unf=OtherCon [])
      (ww3
         :: f a
         Unf=OtherCon []) ->
      case compare w ww2 ww of {
        LT -> False;
        EQ ->
          case < w ww3 ww1 of {
            False -> True;
            True -> False
          };
        GT -> True
      }

-- RHS size: {terms: 17, types: 31, coercions: 0, joins: 0/0}
$fOrdMulF_$c<=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> Bool
$fOrdMulF_$c<=
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of { TmMul ww1 ww2 ->
      case w2 of { TmMul ww4 ww5 -> $w$c<= w ww1 ww2 ww4 ww5 }
      }

-- RHS size: {terms: 30, types: 35, coercions: 0, joins: 0/0}
$fOrdMulF_$cmax
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> MulF f a
$fOrdMulF_$cmax
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of ww { TmMul ww1 ww2 ->
      case w2 of ww3 { TmMul ww4 ww5 ->
      case compare w ww4 ww1 of {
        LT -> ww;
        EQ ->
          case < w ww5 ww2 of {
            False -> ww3;
            True -> ww
          };
        GT -> ww3
      }
      }
      }

-- RHS size: {terms: 26, types: 23, coercions: 0, joins: 0/0}
$w$c>=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     f a -> f a -> f a -> f a -> Bool
$w$c>=
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (ww
         :: f a
         Unf=OtherCon [])
      (ww1
         :: f a
         Unf=OtherCon [])
      (ww2
         :: f a
         Unf=OtherCon [])
      (ww3
         :: f a
         Unf=OtherCon []) ->
      case compare w ww ww2 of {
        LT -> False;
        EQ ->
          case < w ww1 ww3 of {
            False -> True;
            True -> False
          };
        GT -> True
      }

-- RHS size: {terms: 17, types: 31, coercions: 0, joins: 0/0}
$fOrdMulF_$c>=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> Bool
$fOrdMulF_$c>=
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of { TmMul ww1 ww2 ->
      case w2 of { TmMul ww4 ww5 -> $w$c>= w ww1 ww2 ww4 ww5 }
      }

-- RHS size: {terms: 30, types: 35, coercions: 0, joins: 0/0}
$fOrdMulF_$cmin
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     MulF f a -> MulF f a -> MulF f a
$fOrdMulF_$cmin
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Ord (f a))
      (w1 :: MulF f a)
      (w2 :: MulF f a) ->
      case w1 of ww { TmMul ww1 ww2 ->
      case w2 of ww3 { TmMul ww4 ww5 ->
      case compare w ww4 ww1 of {
        LT -> ww3;
        EQ ->
          case < w ww5 ww2 of {
            False -> ww;
            True -> ww3
          };
        GT -> ww
      }
      }
      }

-- RHS size: {terms: 24, types: 34, coercions: 0, joins: 0/0}
$fOrdMulF :: forall (f :: * -> *) a. Ord (f a) => Ord (MulF f a)
$fOrdMulF
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      C:Ord
        ($fOrdMulF_$cp1Ord $dOrd)
        ($fOrdMulF_$ccompare $dOrd)
        ($fOrdMulF_$c< $dOrd)
        ($fOrdMulF_$c<= $dOrd)
        (\ (a1 :: MulF f a) (b :: MulF f a) -> $fOrdMulF_$c< $dOrd b a1)
        ($fOrdMulF_$c>= $dOrd)
        ($fOrdMulF_$cmax $dOrd)
        ($fOrdMulF_$cmin $dOrd)

-- RHS size: {terms: 9, types: 20, coercions: 0, joins: 0/0}
_Mul2 :: forall (f :: * -> *) a. MulF f a -> (f a, f a)
_Mul2
  = \ (@ (f :: * -> *)) (@ a) (ds :: MulF f a) ->
      case ds of { TmMul x1 x2 -> (x1, x2) }

-- RHS size: {terms: 9, types: 22, coercions: 0, joins: 0/0}
_Mul1 :: forall (f :: * -> *) a. (f a, f a) -> MulF f a
_Mul1
  = \ (@ (f :: * -> *)) (@ a) (ds :: (f a, f a)) ->
      case ds of { (x1, x2) -> $WTmMul x1 x2 }

-- RHS size: {terms: 14, types: 58, coercions: 0, joins: 0/0}
_TmMul
  :: forall (f1 :: * -> *) a1 (f2 :: * -> *) a2.
     Iso (MulF f2 a2) (MulF f1 a1) (f2 a2, f2 a2) (f1 a1, f1 a1)
_TmMul
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (f1 :: * -> *))
      (@ a1)
      (@ (p :: * -> * -> *))
      (@ (f2 :: * -> *))
      ($dProfunctor :: Profunctor p)
      ($dFunctor :: Functor f2) ->
      dimap $dProfunctor _Mul2 (fmap $dFunctor _Mul1)

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
_Mul4
  :: forall (tm :: (* -> *) -> * -> *) a. Term tm a -> Term tm a
_Mul4
  = \ (@ (tm :: (* -> *) -> * -> *)) (@ a) (x :: Term tm a) -> x

-- RHS size: {terms: 4, types: 14, coercions: 0, joins: 0/0}
_Mul3
  :: forall (tm :: (* -> *) -> * -> *) a.
     Unwrapped (Term tm a) -> Unwrapped (Term tm a)
_Mul3
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      (x :: Unwrapped (Term tm a)) ->
      x

-- RHS size: {terms: 36, types: 189, coercions: 383, joins: 0/5}
_Mul
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasMulF tm =>
     Prism' (Term tm a) (Term tm a, Term tm a)
_Mul
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasMulF :: HasMulF tm)
      (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        $dProfunctor :: Profunctor p
        $dProfunctor = $p1Choice $dChoice } in
      let {
        $dFunctor :: Functor f
        $dFunctor = $p1Applicative $dApplicative } in
      let {
        f1
          :: p (Unwrapped (Term tm a)) (f (Unwrapped (Term tm a)))
             -> p (Term tm a) (f (Term tm a))
        f1
          = dimap
              $dProfunctor
              (_Mul4 `cast` <Co:13>)
              (fmap $dFunctor (_Mul3 `cast` <Co:358>)) } in
      let {
        f2
          :: p (MulF (Term tm) a) (f (MulF (Term tm) a))
             -> p (tm (Term tm) a) (f (tm (Term tm) a))
        f2 = ($dHasMulF `cast` <Co:2>) $dChoice $dApplicative } in
      let {
        g :: p (Term tm a, Term tm a) (f (Term tm a, Term tm a))
             -> p (MulF (Term tm) a) (f (MulF (Term tm) a))
        g = dimap $dProfunctor _Mul2 (fmap $dFunctor _Mul1) } in
      \ (x :: p (Term tm a, Term tm a) (f (Term tm a, Term tm a))) ->
        f1 ((f2 (g x)) `cast` <Co:10>)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcConstraint []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcMulF1 :: KindRep
$tcMulF1 = KindRepFun krep$*Arr* krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcHasMulF1 :: KindRep
$tcHasMulF1 = KindRepFun $tcMulF1 $krep

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepApp $krep2 $krep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcMulF3 :: Addr#
$tcMulF3 = "MulF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcMulF2 :: TrName
$tcMulF2 = TrNameS $tcMulF3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcMulF :: TyCon
$tcMulF
  = TyCon
      4149507353333929091##
      1246214443398506002##
      $trModule
      $tcMulF2
      0#
      $tcMulF1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep4 :: [KindRep]
$krep4 = : $krep1 []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep5 :: [KindRep]
$krep5 = : $krep2 $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepTyConApp $tcMulF $krep5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7 :: KindRep
$krep7 = KindRepFun $krep3 $krep6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'TmMul1 :: KindRep
$tc'TmMul1 = KindRepFun $krep3 $krep7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'TmMul3 :: Addr#
$tc'TmMul3 = "'TmMul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'TmMul2 :: TrName
$tc'TmMul2 = TrNameS $tc'TmMul3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'TmMul :: TyCon
$tc'TmMul
  = TyCon
      14380589956823869737##
      11960804867761406589##
      $trModule
      $tc'TmMul2
      2#
      $tc'TmMul1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcHasMulF3 :: Addr#
$tcHasMulF3 = "HasMulF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcHasMulF2 :: TrName
$tcHasMulF2 = TrNameS $tcHasMulF3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcHasMulF :: TyCon
$tcHasMulF
  = TyCon
      12787519524745627131##
      12586991464795375984##
      $trModule
      $tcHasMulF2
      0#
      $tcHasMulF1



[ 5 of 20] Compiling Mul.Print        ( src/Mul/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Mul/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 85, types: 291, coercions: 77, joins: 0/1}

-- RHS size: {terms: 4, types: 25, coercions: 0, joins: 0/0}
printRules5
  :: forall (f :: (* -> *) -> * -> *) a.
     Applicative (Const (First (Term f a, Term f a)))
printRules5
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) ->
      $fApplicativeConst $fMonoidFirst

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules4 :: Addr#
printRules4 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules3 :: Addr#
printRules3 = " * "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules2 :: Addr#
printRules2 = ")"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
printRules1 :: [Char]
printRules1 = unpackCString# printRules2

-- RHS size: {terms: 45, types: 154, coercions: 77, joins: 0/1}
$wprintRules
  :: forall (f :: (* -> *) -> * -> *) a.
     HasMulF f =>
     (# PrintRule (Term f a), [PrintRule (Term f a)] #)
$wprintRules
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (w :: HasMulF f) ->
      let {
        lvl
          :: ((Term f a, Term f a)
              -> Const (First (Term f a, Term f a)) (Term f a, Term f a))
             -> Term f a -> Const (First (Term f a, Term f a)) (Term f a)
        lvl = _Mul w $fChoice(->) printRules5 } in
      (# PrintRule
           (\ (p :: Term f a -> Maybe [Char]) (tm :: Term f a) ->
              case (lvl (Just `cast` <Co:45>) tm) `cast` <Co:32> of {
                Nothing -> Nothing;
                Just x ->
                  case x of { (tm1, tm2) ->
                  case p tm1 of {
                    Nothing -> Nothing;
                    Just x1 ->
                      case p tm2 of {
                        Nothing -> Nothing;
                        Just x2 ->
                          Just
                            (unpackAppendCString#
                               printRules4
                               (++ x1 (unpackAppendCString# printRules3 (++ x2 printRules1))))
                      }
                  }
                  }
              }),
         [] #)

-- RHS size: {terms: 10, types: 39, coercions: 0, joins: 0/0}
printRules
  :: forall (f :: (* -> *) -> * -> *) a.
     HasMulF f =>
     [PrintRule (Term f a)]
printRules
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (w :: HasMulF f) ->
      case $wprintRules w of { (# ww1, ww2 #) -> : ww1 ww2 }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[ 6 of 20] Compiling Mul              ( src/Mul.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Mul.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 29, types: 84, coercions: 246, joins: 0/0}

-- RHS size: {terms: 12, types: 30, coercions: 113, joins: 0/0}
mul1
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasMulF tm =>
     Term tm a -> Term tm a -> Tagged (Term tm a) (Identity (Term tm a))
mul1
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasMulF :: HasMulF tm)
      (tm1 :: Term tm a)
      (tm2 :: Term tm a) ->
      _Mul
        $dHasMulF
        $fChoiceTagged
        $fApplicativeIdentity
        ((tm1, tm2) `cast` <Co:113>)

-- RHS size: {terms: 1, types: 0, coercions: 133, joins: 0/0}
mul
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasMulF tm =>
     Term tm a -> Term tm a -> Term tm a
mul = mul1 `cast` <Co:133>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[ 7 of 20] Compiling Base.Type        ( src/Base/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Base/Type.o )
Configuring library 'final-bp-base' for final-bp-0.1.0.0..

==================== Simplified expression ====================
makePrisms
  (mkNameG_tc
     (unpackCString# "initial-0.1.0.0-inplace"#)
     (unpackCString# "Base.Type"#)
     (unpackCString# "BaseF"#))



==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 753, types: 2,242, coercions: 1,260, joins: 0/12}

-- RHS size: {terms: 3, types: 10, coercions: 2, joins: 0/0}
_BaseF
  :: forall (tm :: (* -> *) -> * -> *).
     HasBaseF tm =>
     forall (f :: * -> *) a. Prism' (tm f a) (BaseF f a)
_BaseF
  = \ (@ (tm :: (* -> *) -> * -> *)) (v :: HasBaseF tm) ->
      v `cast` <Co:2>

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
$WTmLit :: forall (f :: * -> *) a. Int -> BaseF f a
$WTmLit
  = \ (@ (f :: * -> *)) (@ a) (dt :: Int) ->
      case dt of { I# dt -> TmLit dt }

-- RHS size: {terms: 13, types: 16, coercions: 0, joins: 0/0}
$WTmAdd :: forall (f :: * -> *) a. f a -> f a -> BaseF f a
$WTmAdd
  = \ (@ (f :: * -> *))
      (@ a)
      (dt :: f[sk:1] a[sk:1])
      (dt :: f[sk:1] a[sk:1]) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> TmAdd dt dt }
      }

-- RHS size: {terms: 7, types: 28, coercions: 0, joins: 0/0}
$fHasBaseFBaseF_$c_BaseF
  :: forall (f :: * -> *) a. Prism' (BaseF f a) (BaseF f a)
$fHasBaseFBaseF_$c_BaseF
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      _
      _ ->
      id

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fHasBaseFBaseF :: HasBaseF BaseF
$fHasBaseFBaseF = $fHasBaseFBaseF_$c_BaseF `cast` <Co:3>

-- RHS size: {terms: 16, types: 224, coercions: 225, joins: 0/0}
$fGenericBaseF_$cto
  :: forall (f :: * -> *) a x. Rep (BaseF f a) x -> BaseF f a
$fGenericBaseF_$cto
  = \ (@ (f :: * -> *)) (@ a) (@ x) (ds :: Rep (BaseF f a) x) ->
      case ds `cast` <Co:84> of {
        L1 ds1 -> $WTmLit (ds1 `cast` <Co:47>);
        R1 ds1 ->
          case ds1 `cast` <Co:44> of { :*: ds2 ds3 ->
          $WTmAdd (ds2 `cast` <Co:25>) (ds3 `cast` <Co:25>)
          }
      }

-- RHS size: {terms: 15, types: 191, coercions: 149, joins: 0/0}
$fGenericBaseF1
  :: forall (f :: * -> *) a x.
     BaseF f a
     -> (:+:)
          (M1
             C
             ('MetaCons "TmLit" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedUnpack)
                (K1 R Int)))
          (M1
             C
             ('MetaCons "TmAdd" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                (K1 R (f a))
              :*: M1
                    S
                    ('MetaSel
                       'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                    (K1 R (f a))))
          x
$fGenericBaseF1
  = \ (@ (f :: * -> *)) (@ a) (@ x) (x1 :: BaseF f a) ->
      case x1 of {
        TmLit dt -> L1 ((I# dt) `cast` <Co:50>);
        TmAdd g1 g2 ->
          R1 ((:*: (g1 `cast` <Co:27>) (g2 `cast` <Co:27>)) `cast` <Co:45>)
      }

-- RHS size: {terms: 5, types: 13, coercions: 92, joins: 0/0}
$fGenericBaseF :: forall (f :: * -> *) a. Generic (BaseF f a)
$fGenericBaseF
  = \ (@ (f :: * -> *)) (@ a) ->
      C:Generic ($fGenericBaseF1 `cast` <Co:92>) $fGenericBaseF_$cto

-- RHS size: {terms: 15, types: 21, coercions: 6, joins: 0/0}
$fNFDataBaseF_$crnf
  :: forall (f :: * -> *) a. NFData (f a) => BaseF f a -> ()
$fNFDataBaseF_$crnf
  = \ (@ (f :: * -> *))
      (@ a)
      ($dNFData :: NFData (f a))
      (eta :: BaseF f a) ->
      case eta of {
        TmLit dt -> ();
        TmAdd g1 g2 ->
          case ($dNFData `cast` <Co:3>) g1 of { () ->
          ($dNFData `cast` <Co:3>) g2
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
$fNFDataBaseF
  :: forall (f :: * -> *) a. NFData (f a) => NFData (BaseF f a)
$fNFDataBaseF = $fNFDataBaseF_$crnf `cast` <Co:17>

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowBaseF3 :: Int
$fShowBaseF3 = I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowBaseF4 :: Addr#
$fShowBaseF4 = "TmLit "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowBaseF2 :: Addr#
$fShowBaseF2 = "TmAdd "#

-- RHS size: {terms: 81, types: 63, coercions: 0, joins: 0/2}
$w$cshowsPrec
  :: forall (f :: * -> *) a. Show (f a) => Int# -> BaseF f a -> ShowS
$w$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (ww :: Int#)
      (w1 :: BaseF f a) ->
      case w1 of {
        TmLit dt ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              \ (x :: String) ->
                unpackAppendCString#
                  $fShowBaseF4
                  (case $wshowSignedInt 11# dt x of { (# ww5, ww6 #) -> : ww5 ww6 });
            True ->
              \ (x :: String) ->
                : $fShow(,)4
                  (unpackAppendCString#
                     $fShowBaseF4
                     (case $wshowSignedInt 11# dt (: $fShow(,)2 x) of
                      { (# ww5, ww6 #) ->
                      : ww5 ww6
                      }))
          };
        TmAdd b1 b2 ->
          let {
            f1 :: String -> String
            f1 = showsPrec w $fShowBaseF3 b1 } in
          let {
            g :: String -> String
            g = showsPrec w $fShowBaseF3 b2 } in
          case tagToEnum# (>=# ww 11#) of {
            False ->
              \ (x :: String) ->
                unpackAppendCString# $fShowBaseF2 (f1 (: showSpace1 (g x)));
            True ->
              \ (x :: String) ->
                : $fShow(,)4
                  (unpackAppendCString#
                     $fShowBaseF2 (f1 (: showSpace1 (g (: $fShow(,)2 x)))))
          }
      }

-- RHS size: {terms: 12, types: 17, coercions: 0, joins: 0/0}
$fShowBaseF_$cshowsPrec
  :: forall (f :: * -> *) a. Show (f a) => Int -> BaseF f a -> ShowS
$fShowBaseF_$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (w1 :: Int)
      (w2 :: BaseF f a) ->
      case w1 of { I# ww1 -> $w$cshowsPrec w ww1 w2 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowBaseF1 :: Int
$fShowBaseF1 = I# 0#

-- RHS size: {terms: 9, types: 15, coercions: 0, joins: 0/0}
$fShowBaseF_$cshow
  :: forall (f :: * -> *) a. Show (f a) => BaseF f a -> String
$fShowBaseF_$cshow
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (x :: BaseF f a) ->
      $w$cshowsPrec $dShow 0# x []

-- RHS size: {terms: 13, types: 22, coercions: 0, joins: 0/0}
$fShowBaseF_$cshowList
  :: forall (f :: * -> *) a. Show (f a) => [BaseF f a] -> ShowS
$fShowBaseF_$cshowList
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (eta :: [BaseF f a])
      (eta1 :: String) ->
      showList__
        (\ (w :: BaseF f a) -> $w$cshowsPrec $dShow 0# w) eta eta1

-- RHS size: {terms: 10, types: 18, coercions: 0, joins: 0/0}
$fShowBaseF
  :: forall (f :: * -> *) a. Show (f a) => Show (BaseF f a)
$fShowBaseF
  = \ (@ (f :: * -> *)) (@ a) ($dShow :: Show (f a)) ->
      C:Show
        ($fShowBaseF_$cshowsPrec $dShow)
        ($fShowBaseF_$cshow $dShow)
        ($fShowBaseF_$cshowList $dShow)

-- RHS size: {terms: 37, types: 45, coercions: 0, joins: 0/0}
$fOrdBaseF_$c<
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> Bool
$fOrdBaseF_$c<
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: BaseF f a)
      (b :: BaseF f a) ->
      case a1 of {
        TmLit dt ->
          case b of {
            TmLit dt1 -> tagToEnum# (<# dt dt1);
            TmAdd ipv ipv1 -> True
          };
        TmAdd a2 a3 ->
          case b of {
            TmLit ipv -> False;
            TmAdd b1 b2 ->
              case compare $dOrd a2 b1 of {
                LT -> True;
                EQ -> < $dOrd a3 b2;
                GT -> False
              }
          }
      }

-- RHS size: {terms: 36, types: 44, coercions: 0, joins: 0/0}
$fOrdBaseF_$ccompare
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> Ordering
$fOrdBaseF_$ccompare
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: BaseF f a)
      (b :: BaseF f a) ->
      case a1 of {
        TmLit dt ->
          case b of {
            TmLit dt1 -> compareInt# dt dt1;
            TmAdd ipv ipv1 -> LT
          };
        TmAdd a2 a3 ->
          case b of {
            TmLit ipv -> GT;
            TmAdd b1 b2 ->
              case compare $dOrd a2 b1 of {
                LT -> LT;
                EQ -> compare $dOrd a3 b2;
                GT -> GT
              }
          }
      }

-- RHS size: {terms: 35, types: 45, coercions: 0, joins: 0/0}
$fEqBaseF_$c==
  :: forall (f :: * -> *) a.
     Eq (f a) =>
     BaseF f a -> BaseF f a -> Bool
$fEqBaseF_$c==
  = \ (@ (f :: * -> *))
      (@ a)
      ($dEq :: Eq (f a))
      (ds :: BaseF f a)
      (ds1 :: BaseF f a) ->
      case ds of {
        TmLit dt ->
          case ds1 of {
            TmLit dt1 -> tagToEnum# (==# dt dt1);
            TmAdd ipv ipv1 -> False
          };
        TmAdd a1 a2 ->
          case ds1 of {
            TmLit ipv -> False;
            TmAdd b1 b2 ->
              case == $dEq a1 b1 of {
                False -> False;
                True -> == $dEq a2 b2
              }
          }
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fEqBaseF_$c/=
  :: forall (f :: * -> *) a.
     Eq (f a) =>
     BaseF f a -> BaseF f a -> Bool
$fEqBaseF_$c/=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dEq :: Eq (f a))
      (a1 :: BaseF f a)
      (b :: BaseF f a) ->
      case $fEqBaseF_$c== $dEq a1 b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 8, types: 16, coercions: 0, joins: 0/0}
$fEqBaseF :: forall (f :: * -> *) a. Eq (f a) => Eq (BaseF f a)
$fEqBaseF
  = \ (@ (f :: * -> *)) (@ a) ($dEq :: Eq (f a)) ->
      C:Eq ($fEqBaseF_$c== $dEq) ($fEqBaseF_$c/= $dEq)

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
$fOrdBaseF_$cp1Ord
  :: forall (f :: * -> *) a. Ord (f a) => Eq (BaseF f a)
$fOrdBaseF_$cp1Ord
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      $fEqBaseF ($p1Ord $dOrd)

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdBaseF_$c<=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> Bool
$fOrdBaseF_$c<=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: BaseF f a)
      (b :: BaseF f a) ->
      case $fOrdBaseF_$c< $dOrd b a1 of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdBaseF_$cmax
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> BaseF f a
$fOrdBaseF_$cmax
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (x :: BaseF f a)
      (y :: BaseF f a) ->
      case $fOrdBaseF_$c< $dOrd y x of {
        False -> y;
        True -> x
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdBaseF_$c>=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> Bool
$fOrdBaseF_$c>=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: BaseF f a)
      (b :: BaseF f a) ->
      case $fOrdBaseF_$c< $dOrd a1 b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdBaseF_$cmin
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     BaseF f a -> BaseF f a -> BaseF f a
$fOrdBaseF_$cmin
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (x :: BaseF f a)
      (y :: BaseF f a) ->
      case $fOrdBaseF_$c< $dOrd y x of {
        False -> x;
        True -> y
      }

-- RHS size: {terms: 24, types: 34, coercions: 0, joins: 0/0}
$fOrdBaseF :: forall (f :: * -> *) a. Ord (f a) => Ord (BaseF f a)
$fOrdBaseF
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      C:Ord
        ($fOrdBaseF_$cp1Ord $dOrd)
        ($fOrdBaseF_$ccompare $dOrd)
        ($fOrdBaseF_$c< $dOrd)
        ($fOrdBaseF_$c<= $dOrd)
        (\ (a1 :: BaseF f a) (b :: BaseF f a) -> $fOrdBaseF_$c< $dOrd b a1)
        ($fOrdBaseF_$c>= $dOrd)
        ($fOrdBaseF_$cmax $dOrd)
        ($fOrdBaseF_$cmin $dOrd)

-- RHS size: {terms: 12, types: 25, coercions: 0, joins: 0/0}
_TmLit1
  :: forall (f :: * -> *) a. BaseF f a -> Either (BaseF f a) Int
_TmLit1
  = \ (@ (f :: * -> *)) (@ a) (x :: BaseF f a) ->
      case x of wild {
        TmLit dt -> Right (I# dt);
        TmAdd ipv ipv1 -> Left wild
      }

-- RHS size: {terms: 31, types: 108, coercions: 0, joins: 0/2}
_TmLit :: forall (f :: * -> *) a. Prism' (BaseF f a) Int
_TmLit
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f1) ->
      let {
        f2
          :: p (Either (BaseF f a) Int) (Either (BaseF f a) (f1 Int))
             -> p (BaseF f a) (f1 (BaseF f a))
        f2
          = dimap
              ($p1Choice $dChoice)
              _TmLit1
              (let {
                 ds :: f1 Int -> f1 (BaseF f a)
                 ds = fmap ($p1Applicative $dApplicative) $WTmLit } in
               \ (ds1 :: Either (BaseF f a) (f1 Int)) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p Int (f1 Int)) -> f2 (right' $dChoice x)

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
_Add2
  :: forall (tm :: (* -> *) -> * -> *) a. Term tm a -> Term tm a
_Add2
  = \ (@ (tm :: (* -> *) -> * -> *)) (@ a) (x :: Term tm a) -> x

-- RHS size: {terms: 4, types: 14, coercions: 0, joins: 0/0}
_Add1
  :: forall (tm :: (* -> *) -> * -> *) a.
     Unwrapped (Term tm a) -> Unwrapped (Term tm a)
_Add1
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      (x :: Unwrapped (Term tm a)) ->
      x

-- RHS size: {terms: 29, types: 123, coercions: 383, joins: 0/3}
_Lit
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Prism' (Term tm a) Int
_Lit
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm)
      (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1
          :: p (Unwrapped (Term tm a)) (f (Unwrapped (Term tm a)))
             -> p (Term tm a) (f (Term tm a))
        f1
          = dimap
              ($p1Choice $dChoice)
              (_Add2 `cast` <Co:13>)
              (fmap ($p1Applicative $dApplicative) (_Add1 `cast` <Co:358>)) } in
      let {
        f2
          :: p (BaseF (Term tm) a) (f (BaseF (Term tm) a))
             -> p (tm (Term tm) a) (f (tm (Term tm) a))
        f2 = ($dHasBaseF `cast` <Co:2>) $dChoice $dApplicative } in
      let {
        g :: p Int (f Int) -> p (BaseF (Term tm) a) (f (BaseF (Term tm) a))
        g = _TmLit $dChoice $dApplicative } in
      \ (x :: p Int (f Int)) -> f1 ((f2 (g x)) `cast` <Co:10>)

-- RHS size: {terms: 16, types: 45, coercions: 0, joins: 0/0}
_TmAdd2
  :: forall (f1 :: * -> *) a1 (f2 :: * -> *) a2.
     BaseF f1 a1 -> Either (BaseF f2 a2) (f1 a1, f1 a1)
_TmAdd2
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (f1 :: * -> *))
      (@ a1)
      (x :: BaseF f a) ->
      case x of {
        TmLit dt -> Left (TmLit dt);
        TmAdd y1 y2 -> Right (y1, y2)
      }

-- RHS size: {terms: 9, types: 22, coercions: 0, joins: 0/0}
_TmAdd1 :: forall (f :: * -> *) a. (f a, f a) -> BaseF f a
_TmAdd1
  = \ (@ (f :: * -> *)) (@ a) (ds :: (f a, f a)) ->
      case ds of { (x1, x2) -> $WTmAdd x1 x2 }

-- RHS size: {terms: 33, types: 168, coercions: 0, joins: 0/2}
_TmAdd
  :: forall (f1 :: * -> *) a1 (f2 :: * -> *) a2.
     Prism (BaseF f2 a2) (BaseF f1 a1) (f2 a2, f2 a2) (f1 a1, f1 a1)
_TmAdd
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (f1 :: * -> *))
      (@ a1)
      (@ (p :: * -> * -> *))
      (@ (f2 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f2) ->
      let {
        f3
          :: p (Either (BaseF f a) (f1 a1, f1 a1)) (Either
                                                      (BaseF f a) (f2 (f a, f a)))
             -> p (BaseF f1 a1) (f2 (BaseF f a))
        f3
          = dimap
              ($p1Choice $dChoice)
              _TmAdd2
              (let {
                 ds :: f2 (f a, f a) -> f2 (BaseF f a)
                 ds = fmap ($p1Applicative $dApplicative) _TmAdd1 } in
               \ (ds1 :: Either (BaseF f a) (f2 (f a, f a))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (f1 a1, f1 a1) (f2 (f a, f a))) -> f3 (right' $dChoice x)

-- RHS size: {terms: 29, types: 150, coercions: 383, joins: 0/3}
_Add
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Prism' (Term tm a) (Term tm a, Term tm a)
_Add
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm)
      (@ (p :: * -> * -> *))
      (@ (f :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f) ->
      let {
        f1
          :: p (Unwrapped (Term tm a)) (f (Unwrapped (Term tm a)))
             -> p (Term tm a) (f (Term tm a))
        f1
          = dimap
              ($p1Choice $dChoice)
              (_Add2 `cast` <Co:13>)
              (fmap ($p1Applicative $dApplicative) (_Add1 `cast` <Co:358>)) } in
      let {
        f2
          :: p (BaseF (Term tm) a) (f (BaseF (Term tm) a))
             -> p (tm (Term tm) a) (f (tm (Term tm) a))
        f2 = ($dHasBaseF `cast` <Co:2>) $dChoice $dApplicative } in
      let {
        g :: p (Term tm a, Term tm a) (f (Term tm a, Term tm a))
             -> p (BaseF (Term tm) a) (f (BaseF (Term tm) a))
        g = _TmAdd $dChoice $dApplicative } in
      \ (x :: p (Term tm a, Term tm a) (f (Term tm a, Term tm a))) ->
        f1 ((f2 (g x)) `cast` <Co:10>)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepTyConApp $tcConstraint []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcBaseF1 :: KindRep
$tcBaseF1 = KindRepFun krep$*Arr* krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcHasBaseF1 :: KindRep
$tcHasBaseF1 = KindRepFun $tcBaseF1 $krep1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepApp $krep3 $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcBaseF3 :: Addr#
$tcBaseF3 = "BaseF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcBaseF2 :: TrName
$tcBaseF2 = TrNameS $tcBaseF3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcBaseF :: TyCon
$tcBaseF
  = TyCon
      5710402104387038467##
      1385426594668003690##
      $trModule
      $tcBaseF2
      0#
      $tcBaseF1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep5 :: [KindRep]
$krep5 = : $krep2 []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep6 :: [KindRep]
$krep6 = : $krep3 $krep5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7 :: KindRep
$krep7 = KindRepTyConApp $tcBaseF $krep6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8 :: KindRep
$krep8 = KindRepFun $krep4 $krep7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'TmAdd1 :: KindRep
$tc'TmAdd1 = KindRepFun $krep4 $krep8

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'TmAdd3 :: Addr#
$tc'TmAdd3 = "'TmAdd"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'TmAdd2 :: TrName
$tc'TmAdd2 = TrNameS $tc'TmAdd3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'TmAdd :: TyCon
$tc'TmAdd
  = TyCon
      18055387651722055321##
      14156134494288808707##
      $trModule
      $tc'TmAdd2
      2#
      $tc'TmAdd1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'TmLit1 :: KindRep
$tc'TmLit1 = KindRepFun $krep $krep7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'TmLit3 :: Addr#
$tc'TmLit3 = "'TmLit"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'TmLit2 :: TrName
$tc'TmLit2 = TrNameS $tc'TmLit3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'TmLit :: TyCon
$tc'TmLit
  = TyCon
      1739297698197566515##
      4377365426959515487##
      $trModule
      $tc'TmLit2
      2#
      $tc'TmLit1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcHasBaseF3 :: Addr#
$tcHasBaseF3 = "HasBaseF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcHasBaseF2 :: TrName
$tcHasBaseF2 = TrNameS $tcHasBaseF3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcHasBaseF :: TyCon
$tcHasBaseF
  = TyCon
      3644673707559412914##
      8728320531909697975##
      $trModule
      $tcHasBaseF2
      0#
      $tcHasBaseF1



Configuring library 'final-bp-mul-print' for final-bp-0.1.0.0..
[ 8 of 20] Compiling Mul.Eval         ( src/Mul/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Mul/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 135, types: 436, coercions: 1,042, joins: 0/0}

-- RHS size: {terms: 7, types: 17, coercions: 12, joins: 0/0}
lvl
  :: forall a b.
     Const (First Int) a -> Const (First Int) b -> First Int
lvl
  = \ (@ a)
      (@ b)
      (ds :: Const (First Int) a)
      (ds1 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds `cast` <Co:6>) (ds1 `cast` <Co:6>)

-- RHS size: {terms: 9, types: 22, coercions: 12, joins: 0/0}
lvl1
  :: forall a b c.
     (a -> b -> c)
     -> Const (First Int) a -> Const (First Int) b -> First Int
lvl1
  = \ (@ a)
      (@ b)
      (@ c)
      _
      (ds1 :: Const (First Int) a)
      (ds2 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds1 `cast` <Co:6>) (ds2 `cast` <Co:6>)

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl2 :: forall a. a -> Maybe Int
lvl2 = \ (@ a) _ -> Nothing

-- RHS size: {terms: 9, types: 12, coercions: 136, joins: 0/0}
$s$fApplicativeConst :: Applicative (Const (First Int))
$s$fApplicativeConst
  = C:Applicative
      $fFunctorConst
      (lvl2 `cast` <Co:18>)
      ((\ (@ a) (@ b) -> $fMonoidFirst_$cmappend) `cast` <Co:30>)
      (lvl1 `cast` <Co:34>)
      (lvl `cast` <Co:27>)
      (lvl `cast` <Co:27>)

-- RHS size: {terms: 11, types: 27, coercions: 48, joins: 0/0}
evalRules2
  :: forall (f :: (* -> *) -> * -> *) a.
     BaseF (Term f) a -> Const (First Int) (BaseF (Term f) a)
evalRules2
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (x :: BaseF (Term f) a) ->
      case x of {
        TmLit dt -> (Just (I# dt)) `cast` <Co:34>;
        TmAdd ipv ipv1 -> Nothing `cast` <Co:14>
      }

-- RHS size: {terms: 4, types: 25, coercions: 0, joins: 0/0}
evalRules3
  :: forall (f :: (* -> *) -> * -> *) a.
     Applicative (Const (First (Term f a, Term f a)))
evalRules3
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) ->
      $fApplicativeConst $fMonoidFirst

-- RHS size: {terms: 59, types: 132, coercions: 806, joins: 0/0}
evalRules1
  :: forall (f :: (* -> *) -> * -> *) a.
     (HasBaseF f, HasMulF f) =>
     forall r.
     (Term f a -> Term f a)
     -> (Term f a -> r) -> (Term f a -> r) -> Term f a -> r
evalRules1
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF f)
      ($dHasMulF :: HasMulF f)
      (@ r)
      (e :: Term f a -> Term f a)
      (good :: Term f a -> r)
      (bad :: Term f a -> r)
      (tm :: Term f a) ->
      case (_Mul
              $dHasMulF $fChoice(->) evalRules3 (Just `cast` <Co:45>) tm)
           `cast` <Co:32>
      of {
        Nothing -> bad tm;
        Just x ->
          case x of { (tm1, tm2) ->
          case (($dHasBaseF `cast` <Co:2>)
                  $fChoice(->)
                  $s$fApplicativeConst
                  evalRules2
                  ((e tm1) `cast` <Co:26>))
               `cast` <Co:48>
          of {
            Nothing -> bad tm;
            Just x1 ->
              case (($dHasBaseF `cast` <Co:2>)
                      $fChoice(->)
                      $s$fApplicativeConst
                      evalRules2
                      ((e tm2) `cast` <Co:26>))
                   `cast` <Co:48>
              of {
                Nothing -> bad tm;
                Just x2 ->
                  good
                    ((($dHasBaseF `cast` <Co:2>)
                        $fChoiceTagged
                        $fApplicativeIdentity
                        (case x1 of { I# x3 ->
                         case x2 of { I# y -> (TmLit (*# x3 y)) `cast` <Co:45> }
                         }))
                     `cast` <Co:530>)
              }
          }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 23, joins: 0/0}
mulRule
  :: forall (f :: (* -> *) -> * -> *) a.
     (HasBaseF f, HasMulF f) =>
     EvalRule (Term f a)
mulRule = evalRules1 `cast` <Co:23>

-- RHS size: {terms: 9, types: 24, coercions: 5, joins: 0/0}
evalRules
  :: forall (f :: (* -> *) -> * -> *) a.
     (HasBaseF f, HasMulF f) =>
     [EvalRule (Term f a)]
evalRules
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF f)
      ($dHasMulF :: HasMulF f) ->
      : ((evalRules1 $dHasBaseF $dHasMulF) `cast` <Co:5>) []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1


------ Local rules for imported ids --------
"SPEC/Mul.Eval $fApplicativeConst @ (First Int)"
    forall (v :: Monoid (First Int)).
      $fApplicativeConst v
      = $s$fApplicativeConst


[ 9 of 20] Compiling Example.Term.BaseMul.Type ( src/Example/Term/BaseMul/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/BaseMul/Type.o )

==================== Simplified expression ====================
makePrisms
  (mkNameG_tc
     (unpackCString# "initial-0.1.0.0-inplace"#)
     (unpackCString# "Example.Term.BaseMul.Type"#)
     (unpackCString# "TermF"#))



==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 766, types: 1,727, coercions: 397, joins: 0/6}

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
$WBMBase :: forall (f :: * -> *) a. BaseF f a -> TermF f a
$WBMBase
  = \ (@ (f :: * -> *)) (@ a) (dt :: BaseF f[sk:1] a[sk:1]) ->
      case dt of dt { __DEFAULT -> BMBase dt }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
$WBMMul :: forall (f :: * -> *) a. MulF f a -> TermF f a
$WBMMul
  = \ (@ (f :: * -> *)) (@ a) (dt :: MulF f[sk:1] a[sk:1]) ->
      case dt of dt { __DEFAULT -> BMMul dt }

-- RHS size: {terms: 12, types: 122, coercions: 174, joins: 0/0}
$fGenericTermF_$cto
  :: forall (f :: * -> *) a x. Rep (TermF f a) x -> TermF f a
$fGenericTermF_$cto
  = \ (@ (f :: * -> *)) (@ a) (@ x) (ds :: Rep (TermF f a) x) ->
      case ds `cast` <Co:68> of {
        L1 ds1 -> $WBMBase (ds1 `cast` <Co:53>);
        R1 ds1 -> $WBMMul (ds1 `cast` <Co:53>)
      }

-- RHS size: {terms: 12, types: 125, coercions: 112, joins: 0/0}
$fGenericTermF1
  :: forall (f :: * -> *) a x.
     TermF f a
     -> (:+:)
          (M1
             C
             ('MetaCons "BMBase" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                (K1 R (BaseF f a))))
          (M1
             C
             ('MetaCons "BMMul" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                (K1 R (MulF f a))))
          x
$fGenericTermF1
  = \ (@ (f :: * -> *)) (@ a) (@ x) (x1 :: TermF f a) ->
      case x1 of {
        BMBase g1 -> L1 (g1 `cast` <Co:56>);
        BMMul g1 -> R1 (g1 `cast` <Co:56>)
      }

-- RHS size: {terms: 5, types: 13, coercions: 76, joins: 0/0}
$fGenericTermF :: forall (f :: * -> *) a. Generic (TermF f a)
$fGenericTermF
  = \ (@ (f :: * -> *)) (@ a) ->
      C:Generic ($fGenericTermF1 `cast` <Co:76>) $fGenericTermF_$cto

-- RHS size: {terms: 28, types: 38, coercions: 12, joins: 0/0}
$fNFDataTermF_$crnf
  :: forall (f :: * -> *) a. NFData (f a) => TermF f a -> ()
$fNFDataTermF_$crnf
  = \ (@ (f :: * -> *))
      (@ a)
      ($dNFData :: NFData (f a))
      (eta :: TermF f a) ->
      case eta of {
        BMBase g1 ->
          case g1 of {
            TmLit dt -> ();
            TmAdd g2 g3 ->
              case ($dNFData `cast` <Co:3>) g2 of { () ->
              ($dNFData `cast` <Co:3>) g3
              }
          };
        BMMul g1 ->
          case g1 of { TmMul g2 g3 ->
          case ($dNFData `cast` <Co:3>) g2 of { () ->
          ($dNFData `cast` <Co:3>) g3
          }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
$fNFDataTermF
  :: forall (f :: * -> *) a. NFData (f a) => NFData (TermF f a)
$fNFDataTermF = $fNFDataTermF_$crnf `cast` <Co:17>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowTermF5 :: Addr#
$fShowTermF5 = "BMBase "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTermF4 :: [Char]
$fShowTermF4 = unpackCString# $fShowTermF5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShowTermF3 :: Addr#
$fShowTermF3 = "BMMul "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTermF2 :: [Char]
$fShowTermF2 = unpackCString# $fShowTermF3

-- RHS size: {terms: 65, types: 53, coercions: 0, joins: 0/2}
$w$cshowsPrec
  :: forall (f :: * -> *) a. Show (f a) => Int# -> TermF f a -> ShowS
$w$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (ww :: Int#)
      (w1 :: TermF f a) ->
      case w1 of {
        BMBase b1 ->
          let {
            g :: String -> String
            g = $w$cshowsPrec w 11# b1 } in
          case tagToEnum# (>=# ww 11#) of {
            False -> \ (x :: String) -> ++ $fShowTermF4 (g x);
            True ->
              \ (x :: String) ->
                : $fShow(,)4 (++ $fShowTermF4 (g (: $fShow(,)2 x)))
          };
        BMMul b1 ->
          case b1 of { TmMul ww3 ww4 ->
          let {
            g :: String -> String
            g = $w$cshowsPrec w 11# ww3 ww4 } in
          case tagToEnum# (>=# ww 11#) of {
            False -> \ (x :: String) -> ++ $fShowTermF2 (g x);
            True ->
              \ (x :: String) ->
                : $fShow(,)4 (++ $fShowTermF2 (g (: $fShow(,)2 x)))
          }
          }
      }

-- RHS size: {terms: 12, types: 17, coercions: 0, joins: 0/0}
$fShowTermF_$cshowsPrec
  :: forall (f :: * -> *) a. Show (f a) => Int -> TermF f a -> ShowS
$fShowTermF_$cshowsPrec
  = \ (@ (f :: * -> *))
      (@ a)
      (w :: Show (f a))
      (w1 :: Int)
      (w2 :: TermF f a) ->
      case w1 of { I# ww1 -> $w$cshowsPrec w ww1 w2 }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$fShowTermF6 :: [Char]
$fShowTermF6 = : $fShow(,)2 []

-- RHS size: {terms: 53, types: 58, coercions: 0, joins: 0/0}
$fShowTermF_$cshow
  :: forall (f :: * -> *) a. Show (f a) => TermF f a -> String
$fShowTermF_$cshow
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (x :: TermF f a) ->
      case x of {
        BMBase b1 ->
          ++
            $fShowTermF4
            (case b1 of {
               TmLit dt ->
                 : $fShow(,)4
                   (unpackAppendCString#
                      $fShowBaseF4
                      (case $wshowSignedInt 11# dt $fShowTermF6 of { (# ww5, ww6 #) ->
                       : ww5 ww6
                       }));
               TmAdd b2 b3 ->
                 : $fShow(,)4
                   (unpackAppendCString#
                      $fShowBaseF2
                      (showsPrec
                         $dShow
                         $fShowBaseF3
                         b2
                         (: showSpace1 (showsPrec $dShow $fShowBaseF3 b3 $fShowTermF6))))
             });
        BMMul b1 ->
          case b1 of { TmMul ww3 ww4 ->
          ++ $fShowTermF2 ($w$cshowsPrec $dShow 11# ww3 ww4 [])
          }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTermF1 :: Int
$fShowTermF1 = I# 0#

-- RHS size: {terms: 13, types: 22, coercions: 0, joins: 0/0}
$fShowTermF_$cshowList
  :: forall (f :: * -> *) a. Show (f a) => [TermF f a] -> ShowS
$fShowTermF_$cshowList
  = \ (@ (f :: * -> *))
      (@ a)
      ($dShow :: Show (f a))
      (eta :: [TermF f a])
      (eta1 :: String) ->
      showList__
        (\ (w :: TermF f a) -> $w$cshowsPrec $dShow 0# w) eta eta1

-- RHS size: {terms: 10, types: 18, coercions: 0, joins: 0/0}
$fShowTermF
  :: forall (f :: * -> *) a. Show (f a) => Show (TermF f a)
$fShowTermF
  = \ (@ (f :: * -> *)) (@ a) ($dShow :: Show (f a)) ->
      C:Show
        ($fShowTermF_$cshowsPrec $dShow)
        ($fShowTermF_$cshow $dShow)
        ($fShowTermF_$cshowList $dShow)

-- RHS size: {terms: 71, types: 91, coercions: 0, joins: 0/0}
$fOrdTermF_$c<
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> Bool
$fOrdTermF_$c<
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: TermF f a)
      (b :: TermF f a) ->
      case a1 of {
        BMBase a2 ->
          case b of {
            BMBase b1 ->
              case a2 of {
                TmLit dt ->
                  case b1 of {
                    TmLit dt1 -> tagToEnum# (<# dt dt1);
                    TmAdd ipv ipv1 -> True
                  };
                TmAdd a3 a4 ->
                  case b1 of {
                    TmLit ipv -> False;
                    TmAdd b2 b3 ->
                      case compare $dOrd a3 b2 of {
                        LT -> True;
                        EQ -> < $dOrd a4 b3;
                        GT -> False
                      }
                  }
              };
            BMMul ipv -> True
          };
        BMMul a2 ->
          case a2 of { TmMul ww1 ww2 ->
          case b of {
            BMBase ipv -> False;
            BMMul b1 ->
              case b1 of { TmMul ww4 ww5 ->
              case compare $dOrd ww1 ww4 of {
                LT -> True;
                EQ -> < $dOrd ww2 ww5;
                GT -> False
              }
              }
          }
          }
      }

-- RHS size: {terms: 70, types: 90, coercions: 0, joins: 0/0}
$fOrdTermF_$ccompare
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> Ordering
$fOrdTermF_$ccompare
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: TermF f a)
      (b :: TermF f a) ->
      case a1 of {
        BMBase a2 ->
          case b of {
            BMBase b1 ->
              case a2 of {
                TmLit dt ->
                  case b1 of {
                    TmLit dt1 -> compareInt# dt dt1;
                    TmAdd ipv ipv1 -> LT
                  };
                TmAdd a3 a4 ->
                  case b1 of {
                    TmLit ipv -> GT;
                    TmAdd b2 b3 ->
                      case compare $dOrd a3 b2 of {
                        LT -> LT;
                        EQ -> compare $dOrd a4 b3;
                        GT -> GT
                      }
                  }
              };
            BMMul ipv -> LT
          };
        BMMul a2 ->
          case a2 of { TmMul ww1 ww2 ->
          case b of {
            BMBase ipv -> GT;
            BMMul b1 ->
              case b1 of { TmMul ww4 ww5 ->
              case compare $dOrd ww1 ww4 of {
                LT -> LT;
                EQ -> compare $dOrd ww2 ww5;
                GT -> GT
              }
              }
          }
          }
      }

-- RHS size: {terms: 67, types: 91, coercions: 0, joins: 0/0}
$fEqTermF_$c==
  :: forall (f :: * -> *) a.
     Eq (f a) =>
     TermF f a -> TermF f a -> Bool
$fEqTermF_$c==
  = \ (@ (f :: * -> *))
      (@ a)
      ($dEq :: Eq (f a))
      (ds :: TermF f a)
      (ds1 :: TermF f a) ->
      case ds of {
        BMBase a1 ->
          case ds1 of {
            BMBase b1 ->
              case a1 of {
                TmLit dt ->
                  case b1 of {
                    TmLit dt1 -> tagToEnum# (==# dt dt1);
                    TmAdd ipv ipv1 -> False
                  };
                TmAdd a2 a3 ->
                  case b1 of {
                    TmLit ipv -> False;
                    TmAdd b2 b3 ->
                      case == $dEq a2 b2 of {
                        False -> False;
                        True -> == $dEq a3 b3
                      }
                  }
              };
            BMMul ipv -> False
          };
        BMMul a1 ->
          case a1 of { TmMul ww1 ww2 ->
          case ds1 of {
            BMBase ipv -> False;
            BMMul b1 ->
              case b1 of { TmMul ww4 ww5 ->
              case == $dEq ww1 ww4 of {
                False -> False;
                True -> == $dEq ww2 ww5
              }
              }
          }
          }
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fEqTermF_$c/=
  :: forall (f :: * -> *) a.
     Eq (f a) =>
     TermF f a -> TermF f a -> Bool
$fEqTermF_$c/=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dEq :: Eq (f a))
      (a1 :: TermF f a)
      (b :: TermF f a) ->
      case $fEqTermF_$c== $dEq a1 b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 8, types: 16, coercions: 0, joins: 0/0}
$fEqTermF :: forall (f :: * -> *) a. Eq (f a) => Eq (TermF f a)
$fEqTermF
  = \ (@ (f :: * -> *)) (@ a) ($dEq :: Eq (f a)) ->
      C:Eq ($fEqTermF_$c== $dEq) ($fEqTermF_$c/= $dEq)

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
$fOrdTermF_$cp1Ord
  :: forall (f :: * -> *) a. Ord (f a) => Eq (TermF f a)
$fOrdTermF_$cp1Ord
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      $fEqTermF ($p1Ord $dOrd)

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdTermF_$c<=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> Bool
$fOrdTermF_$c<=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: TermF f a)
      (b :: TermF f a) ->
      case $fOrdTermF_$c< $dOrd b a1 of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdTermF_$cmax
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> TermF f a
$fOrdTermF_$cmax
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (x :: TermF f a)
      (y :: TermF f a) ->
      case $fOrdTermF_$c< $dOrd y x of {
        False -> y;
        True -> x
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdTermF_$c>=
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> Bool
$fOrdTermF_$c>=
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (a1 :: TermF f a)
      (b :: TermF f a) ->
      case $fOrdTermF_$c< $dOrd a1 b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fOrdTermF_$cmin
  :: forall (f :: * -> *) a.
     Ord (f a) =>
     TermF f a -> TermF f a -> TermF f a
$fOrdTermF_$cmin
  = \ (@ (f :: * -> *))
      (@ a)
      ($dOrd :: Ord (f a))
      (x :: TermF f a)
      (y :: TermF f a) ->
      case $fOrdTermF_$c< $dOrd y x of {
        False -> x;
        True -> y
      }

-- RHS size: {terms: 24, types: 34, coercions: 0, joins: 0/0}
$fOrdTermF :: forall (f :: * -> *) a. Ord (f a) => Ord (TermF f a)
$fOrdTermF
  = \ (@ (f :: * -> *)) (@ a) ($dOrd :: Ord (f a)) ->
      C:Ord
        ($fOrdTermF_$cp1Ord $dOrd)
        ($fOrdTermF_$ccompare $dOrd)
        ($fOrdTermF_$c< $dOrd)
        ($fOrdTermF_$c<= $dOrd)
        (\ (a1 :: TermF f a) (b :: TermF f a) -> $fOrdTermF_$c< $dOrd b a1)
        ($fOrdTermF_$c>= $dOrd)
        ($fOrdTermF_$cmax $dOrd)
        ($fOrdTermF_$cmin $dOrd)

-- RHS size: {terms: 11, types: 30, coercions: 0, joins: 0/0}
_BMBase1
  :: forall (f :: * -> *) a.
     TermF f a -> Either (TermF f a) (BaseF f a)
_BMBase1
  = \ (@ (f :: * -> *)) (@ a) (x :: TermF f a) ->
      case x of wild {
        BMBase y1 -> Right y1;
        BMMul ipv -> Left wild
      }

-- RHS size: {terms: 31, types: 134, coercions: 0, joins: 0/2}
_BMBase :: forall (f :: * -> *) a. Prism' (TermF f a) (BaseF f a)
_BMBase
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f1) ->
      let {
        f2
          :: p (Either (TermF f a) (BaseF f a)) (Either
                                                   (TermF f a) (f1 (BaseF f a)))
             -> p (TermF f a) (f1 (TermF f a))
        f2
          = dimap
              ($p1Choice $dChoice)
              _BMBase1
              (let {
                 ds :: f1 (BaseF f a) -> f1 (TermF f a)
                 ds = fmap ($p1Applicative $dApplicative) $WBMBase } in
               \ (ds1 :: Either (TermF f a) (f1 (BaseF f a))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (BaseF f a) (f1 (BaseF f a))) -> f2 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fHasBaseFTermF :: HasBaseF TermF
$fHasBaseFTermF = _BMBase `cast` <Co:3>

-- RHS size: {terms: 11, types: 30, coercions: 0, joins: 0/0}
_BMMul1
  :: forall (f :: * -> *) a.
     TermF f a -> Either (TermF f a) (MulF f a)
_BMMul1
  = \ (@ (f :: * -> *)) (@ a) (x :: TermF f a) ->
      case x of wild {
        BMBase ipv -> Left wild;
        BMMul y1 -> Right y1
      }

-- RHS size: {terms: 31, types: 134, coercions: 0, joins: 0/2}
_BMMul :: forall (f :: * -> *) a. Prism' (TermF f a) (MulF f a)
_BMMul
  = \ (@ (f :: * -> *))
      (@ a)
      (@ (p :: * -> * -> *))
      (@ (f1 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f1) ->
      let {
        f2
          :: p (Either (TermF f a) (MulF f a)) (Either
                                                  (TermF f a) (f1 (MulF f a)))
             -> p (TermF f a) (f1 (TermF f a))
        f2
          = dimap
              ($p1Choice $dChoice)
              _BMMul1
              (let {
                 ds :: f1 (MulF f a) -> f1 (TermF f a)
                 ds = fmap ($p1Applicative $dApplicative) $WBMMul } in
               \ (ds1 :: Either (TermF f a) (f1 (MulF f a))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (MulF f a) (f1 (MulF f a))) -> f2 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fHasMulFTermF :: HasMulF TermF
$fHasMulFTermF = _BMMul `cast` <Co:3>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.BaseMul.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcTermF1 :: KindRep
$tcTermF1 = KindRepFun krep$*Arr* krep$*Arr*

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepVar 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep2 :: [KindRep]
$krep2 = : $krep []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3 :: [KindRep]
$krep3 = : $krep1 $krep2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepTyConApp $tcBaseF $krep3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepTyConApp $tcMulF $krep3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcTermF3 :: Addr#
$tcTermF3 = "TermF"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcTermF2 :: TrName
$tcTermF2 = TrNameS $tcTermF3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcTermF :: TyCon
$tcTermF
  = TyCon
      3926542919675209495##
      15495442658314935867##
      $trModule
      $tcTermF2
      0#
      $tcTermF1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepTyConApp $tcTermF $krep3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'BMBase1 :: KindRep
$tc'BMBase1 = KindRepFun $krep4 $krep6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'BMBase3 :: Addr#
$tc'BMBase3 = "'BMBase"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'BMBase2 :: TrName
$tc'BMBase2 = TrNameS $tc'BMBase3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'BMBase :: TyCon
$tc'BMBase
  = TyCon
      6418924972322557299##
      4094132794458399817##
      $trModule
      $tc'BMBase2
      2#
      $tc'BMBase1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'BMMul1 :: KindRep
$tc'BMMul1 = KindRepFun $krep5 $krep6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'BMMul3 :: Addr#
$tc'BMMul3 = "'BMMul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'BMMul2 :: TrName
$tc'BMMul2 = TrNameS $tc'BMMul3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'BMMul :: TyCon
$tc'BMMul
  = TyCon
      6924412029024001015##
      14813373258268439940##
      $trModule
      $tc'BMMul2
      2#
      $tc'BMMul1



[10 of 20] Compiling Example.Term.Base.Type ( src/Example/Term/Base/Type.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/Base/Type.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.Base.Type"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[11 of 20] Compiling Base.Print       ( src/Base/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Base/Print.o )
Preprocessing library 'initial-bp-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-print' for initial-bp-0.1.0.0..

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 155, types: 509, coercions: 504, joins: 0/0}

-- RHS size: {terms: 7, types: 17, coercions: 12, joins: 0/0}
lvl
  :: forall a b.
     Const (First Int) a -> Const (First Int) b -> First Int
lvl
  = \ (@ a)
      (@ b)
      (ds :: Const (First Int) a)
      (ds1 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds `cast` <Co:6>) (ds1 `cast` <Co:6>)

-- RHS size: {terms: 9, types: 22, coercions: 12, joins: 0/0}
lvl1
  :: forall a b c.
     (a -> b -> c)
     -> Const (First Int) a -> Const (First Int) b -> First Int
lvl1
  = \ (@ a)
      (@ b)
      (@ c)
      _
      (ds1 :: Const (First Int) a)
      (ds2 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds1 `cast` <Co:6>) (ds2 `cast` <Co:6>)

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl2 :: forall a. a -> Maybe Int
lvl2 = \ (@ a) _ -> Nothing

-- RHS size: {terms: 9, types: 12, coercions: 136, joins: 0/0}
$s$fApplicativeConst :: Applicative (Const (First Int))
$s$fApplicativeConst
  = C:Applicative
      $fFunctorConst
      (lvl2 `cast` <Co:18>)
      ((\ (@ a) (@ b) -> $fMonoidFirst_$cmappend) `cast` <Co:30>)
      (lvl1 `cast` <Co:34>)
      (lvl `cast` <Co:27>)
      (lvl `cast` <Co:27>)

-- RHS size: {terms: 11, types: 27, coercions: 48, joins: 0/0}
printRules7
  :: forall (f :: (* -> *) -> * -> *) a.
     BaseF (Term f) a -> Const (First Int) (BaseF (Term f) a)
printRules7
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (x :: BaseF (Term f) a) ->
      case x of {
        TmLit dt -> (Just (I# dt)) `cast` <Co:34>;
        TmAdd ipv ipv1 -> Nothing `cast` <Co:14>
      }

-- RHS size: {terms: 4, types: 25, coercions: 0, joins: 0/0}
printRules6
  :: forall (f :: (* -> *) -> * -> *) a.
     Applicative (Const (First (Term f a, Term f a)))
printRules6
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) ->
      $fApplicativeConst $fMonoidFirst

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules4 :: Addr#
printRules4 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules3 :: Addr#
printRules3 = " + "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules2 :: Addr#
printRules2 = ")"#

-- RHS size: {terms: 12, types: 45, coercions: 108, joins: 0/0}
printRules5
  :: forall (f :: (* -> *) -> * -> *) a.
     BaseF (Term f) a
     -> Const (First (Term f a, Term f a)) (BaseF (Term f) a)
printRules5
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (x :: BaseF (Term f) a) ->
      case x of {
        TmLit dt -> Nothing `cast` <Co:26>;
        TmAdd y1 y2 -> (Just (y1, y2)) `cast` <Co:82>
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
printRules1 :: [Char]
printRules1 = unpackCString# printRules2

-- RHS size: {terms: 58, types: 141, coercions: 188, joins: 0/0}
$wprintRules
  :: forall (f :: (* -> *) -> * -> *) a.
     HasBaseF f =>
     (# PrintRule (Term f a), [PrintRule (Term f a)] #)
$wprintRules
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (w :: HasBaseF f) ->
      (# PrintRule
           (\ _ (tm :: Term f a) ->
              case ((w `cast` <Co:2>)
                      $fChoice(->) $s$fApplicativeConst printRules7 (tm `cast` <Co:26>))
                   `cast` <Co:48>
              of {
                Nothing -> Nothing;
                Just x -> Just ($fShowInt_$cshow x)
              }),
         : (PrintRule
              (\ (pr :: Term f a -> Maybe [Char]) (tm :: Term f a) ->
                 case ((w `cast` <Co:2>)
                         $fChoice(->) printRules6 printRules5 (tm `cast` <Co:38>))
                      `cast` <Co:72>
                 of {
                   Nothing -> Nothing;
                   Just x ->
                     case x of { (tm1, tm2) ->
                     case pr tm1 of {
                       Nothing -> Nothing;
                       Just x1 ->
                         case pr tm2 of {
                           Nothing -> Nothing;
                           Just x2 ->
                             Just
                               (unpackAppendCString#
                                  printRules4
                                  (++ x1 (unpackAppendCString# printRules3 (++ x2 printRules1))))
                         }
                     }
                     }
                 }))
           [] #)

-- RHS size: {terms: 10, types: 39, coercions: 0, joins: 0/0}
printRules
  :: forall (f :: (* -> *) -> * -> *) a.
     HasBaseF f =>
     [PrintRule (Term f a)]
printRules
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (w :: HasBaseF f) ->
      case $wprintRules w of { (# ww1, ww2 #) -> : ww1 ww2 }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1


------ Local rules for imported ids --------
"SPEC/Base.Print $fApplicativeConst @ (First Int)"
    forall (v :: Monoid (First Int)).
      $fApplicativeConst v
      = $s$fApplicativeConst


Configuring library 'final-bp-base-print' for final-bp-0.1.0.0..
[12 of 20] Compiling Base.Eval        ( src/Base/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Base/Eval.o )
[1 of 1] Compiling Interpret.Print  ( initial-bp-print/Interpret/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-print/build/initial-bp-print/Interpret/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 144, types: 496, coercions: 1,182, joins: 0/0}

-- RHS size: {terms: 7, types: 17, coercions: 12, joins: 0/0}
lvl
  :: forall a b.
     Const (First Int) a -> Const (First Int) b -> First Int
lvl
  = \ (@ a)
      (@ b)
      (ds :: Const (First Int) a)
      (ds1 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds `cast` <Co:6>) (ds1 `cast` <Co:6>)

-- RHS size: {terms: 9, types: 22, coercions: 12, joins: 0/0}
lvl1
  :: forall a b c.
     (a -> b -> c)
     -> Const (First Int) a -> Const (First Int) b -> First Int
lvl1
  = \ (@ a)
      (@ b)
      (@ c)
      _
      (ds1 :: Const (First Int) a)
      (ds2 :: Const (First Int) b) ->
      $fMonoidFirst_$cmappend (ds1 `cast` <Co:6>) (ds2 `cast` <Co:6>)

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl2 :: forall a. a -> Maybe Int
lvl2 = \ (@ a) _ -> Nothing

-- RHS size: {terms: 9, types: 12, coercions: 136, joins: 0/0}
$s$fApplicativeConst :: Applicative (Const (First Int))
$s$fApplicativeConst
  = C:Applicative
      $fFunctorConst
      (lvl2 `cast` <Co:18>)
      ((\ (@ a) (@ b) -> $fMonoidFirst_$cmappend) `cast` <Co:30>)
      (lvl1 `cast` <Co:34>)
      (lvl `cast` <Co:27>)
      (lvl `cast` <Co:27>)

-- RHS size: {terms: 11, types: 27, coercions: 48, joins: 0/0}
addRule2
  :: forall (f :: (* -> *) -> * -> *) a.
     BaseF (Term f) a -> Const (First Int) (BaseF (Term f) a)
addRule2
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (x :: BaseF (Term f) a) ->
      case x of {
        TmLit dt -> (Just (I# dt)) `cast` <Co:34>;
        TmAdd ipv ipv1 -> Nothing `cast` <Co:14>
      }

-- RHS size: {terms: 4, types: 25, coercions: 0, joins: 0/0}
addRule4
  :: forall (f :: (* -> *) -> * -> *) a.
     Applicative (Const (First (Term f a, Term f a)))
addRule4
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) ->
      $fApplicativeConst $fMonoidFirst

-- RHS size: {terms: 12, types: 45, coercions: 108, joins: 0/0}
addRule3
  :: forall (f :: (* -> *) -> * -> *) a.
     BaseF (Term f) a
     -> Const (First (Term f a, Term f a)) (BaseF (Term f) a)
addRule3
  = \ (@ (f :: (* -> *) -> * -> *)) (@ a) (x :: BaseF (Term f) a) ->
      case x of {
        TmLit dt -> Nothing `cast` <Co:26>;
        TmAdd y1 y2 -> (Just (y1, y2)) `cast` <Co:82>
      }

-- RHS size: {terms: 57, types: 126, coercions: 841, joins: 0/0}
addRule1
  :: forall (f :: (* -> *) -> * -> *) a.
     HasBaseF f =>
     forall r.
     (Term f a -> Term f a)
     -> (Term f a -> r) -> (Term f a -> r) -> Term f a -> r
addRule1
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF f)
      (@ r)
      (e :: Term f a -> Term f a)
      (good :: Term f a -> r)
      (bad :: Term f a -> r)
      (tm :: Term f a) ->
      case (($dHasBaseF `cast` <Co:2>)
              $fChoice(->) addRule4 addRule3 (tm `cast` <Co:38>))
           `cast` <Co:72>
      of {
        Nothing -> bad tm;
        Just x ->
          case x of { (tm1, tm2) ->
          case (($dHasBaseF `cast` <Co:2>)
                  $fChoice(->)
                  $s$fApplicativeConst
                  addRule2
                  ((e tm1) `cast` <Co:26>))
               `cast` <Co:48>
          of {
            Nothing -> bad tm;
            Just x1 ->
              case (($dHasBaseF `cast` <Co:2>)
                      $fChoice(->)
                      $s$fApplicativeConst
                      addRule2
                      ((e tm2) `cast` <Co:26>))
                   `cast` <Co:48>
              of {
                Nothing -> bad tm;
                Just x2 ->
                  good
                    ((($dHasBaseF `cast` <Co:2>)
                        $fChoiceTagged
                        $fApplicativeIdentity
                        (case x1 of { I# x3 ->
                         case x2 of { I# y -> (TmLit (+# x3 y)) `cast` <Co:45> }
                         }))
                     `cast` <Co:530>)
              }
          }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 20, joins: 0/0}
addRule
  :: forall (f :: (* -> *) -> * -> *) a.
     HasBaseF f =>
     EvalRule (Term f a)
addRule = addRule1 `cast` <Co:20>

-- RHS size: {terms: 7, types: 22, coercions: 5, joins: 0/0}
evalRules
  :: forall (f :: (* -> *) -> * -> *) a.
     HasBaseF f =>
     [EvalRule (Term f a)]
evalRules
  = \ (@ (f :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF f) ->
      : ((addRule1 $dHasBaseF) `cast` <Co:5>) []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1


------ Local rules for imported ids --------
"SPEC/Base.Eval $fApplicativeConst @ (First Int)"
    forall (v :: Monoid (First Int)).
      $fApplicativeConst v
      = $s$fApplicativeConst


[13 of 20] Compiling Base             ( src/Base.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Base.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 38, types: 146, coercions: 754, joins: 0/0}

-- RHS size: {terms: 7, types: 18, coercions: 0, joins: 0/0}
lit1
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Tagged Int (Identity Int)
     -> Tagged (Term tm a) (Identity (Term tm a))
lit1
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm) ->
      _Lit $dHasBaseF $fChoiceTagged $fApplicativeIdentity

-- RHS size: {terms: 1, types: 0, coercions: 76, joins: 0/0}
lit
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Int -> Term tm a
lit = lit1 `cast` <Co:76>

-- RHS size: {terms: 11, types: 28, coercions: 77, joins: 0/0}
add1
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Term tm a
     -> Term tm a -> Tagged (tm (Term tm) a) (Identity (tm (Term tm) a))
add1
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm)
      (tm1 :: Term tm a)
      (tm2 :: Term tm a) ->
      ($dHasBaseF `cast` <Co:2>)
        $fChoiceTagged
        $fApplicativeIdentity
        (($WTmAdd tm1 tm2) `cast` <Co:75>)

-- RHS size: {terms: 1, types: 0, coercions: 601, joins: 0/0}
add
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Term tm a -> Term tm a -> Term tm a
add = add1 `cast` <Co:601>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 112, types: 78, coercions: 0, joins: 1/2}

-- RHS size: {terms: 28, types: 38, coercions: 0, joins: 1/2}
mkPrint :: forall tm. [PrintRule tm] -> tm -> Maybe String
mkPrint
  = \ (@ tm) (rules :: [PrintRule tm]) (eta :: tm) ->
      letrec {
        pr :: tm -> Maybe String
        pr
          = \ (tm1 :: tm) ->
              joinrec {
                go :: [PrintRule tm] -> Maybe String
                go (ds :: [PrintRule tm])
                  = case ds of {
                      [] -> Nothing;
                      : y ys ->
                        case y of { PrintRule f ->
                        case f pr tm1 of wild2 {
                          Nothing -> jump go ys;
                          Just ipv -> wild2
                        }
                        }
                    }; } in
              jump go rules; } in
      pr eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-bp-0.1.0.0-inplace-initial-bp-print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Interpret.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcChar []

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1 :: [KindRep]
$krep1 = : $krep []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepTyConApp $tc[] $krep1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep3 :: [KindRep]
$krep3 = : $krep2 []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepTyConApp $tcMaybe $krep3

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepFun $krep5 $krep4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7 :: KindRep
$krep7 = KindRepFun $krep6 $krep6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcPrintRule2 :: Addr#
$tcPrintRule2 = "PrintRule"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcPrintRule1 :: TrName
$tcPrintRule1 = TrNameS $tcPrintRule2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcPrintRule :: TyCon
$tcPrintRule
  = TyCon
      17714313620178505416##
      17504649792137627185##
      $trModule
      $tcPrintRule1
      0#
      krep$*Arr*

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep8 :: [KindRep]
$krep8 = : $krep5 []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9 :: KindRep
$krep9 = KindRepTyConApp $tcPrintRule $krep8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule1 :: KindRep
$tc'PrintRule1 = KindRepFun $krep7 $krep9

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule3 :: Addr#
$tc'PrintRule3 = "'PrintRule"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule2 :: TrName
$tc'PrintRule2 = TrNameS $tc'PrintRule3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'PrintRule :: TyCon
$tc'PrintRule
  = TyCon
      3231236959102998075##
      13503017589867352638##
      $trModule
      $tc'PrintRule2
      1#
      $tc'PrintRule1



[14 of 20] Compiling Initial.Bench    ( src/Initial/Bench.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Initial/Bench.o )
Preprocessing library 'initial-bp-term' for initial-bp-0.1.0.0..
Building library 'initial-bp-term' instantiated with Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
Preprocessing library for vanilla-0.1.0.0..
Building library for vanilla-0.1.0.0..
[1 of 1] Compiling Term.Type[sig]   ( initial-bp-term/Term/Type.hsig, nothing )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 231, types: 539, coercions: 14,433, joins: 0/0}

Rec {
-- RHS size: {terms: 26, types: 44, coercions: 3, joins: 0/0}
$fNFDataTerm_$crnf :: forall a. Term TermF a -> ()
$fNFDataTerm_$crnf
  = \ (@ a) (x :: Term TermF a) ->
      case x `cast` <Co:3> of {
        BMBase g1 ->
          case g1 of {
            TmLit dt -> ();
            TmAdd g2 g3 ->
              case $fNFDataTerm_$crnf g2 of { () -> $fNFDataTerm_$crnf g3 }
          };
        BMMul g1 ->
          case g1 of { TmMul g2 g3 ->
          case $fNFDataTerm_$crnf g2 of { () -> $fNFDataTerm_$crnf g3 }
          }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
$fNFDataTerm :: forall a. NFData (Term TermF a)
$fNFDataTerm = $fNFDataTerm_$crnf `cast` <Co:8>

Rec {
-- RHS size: {terms: 70, types: 148, coercions: 1,505, joins: 0/0}
evalTerm :: forall a. Term TermF a -> Term TermF a
evalTerm
  = \ (@ a) (tm1 :: Term TermF a) ->
      case tm1 `cast` <Co:38> of wild {
        BMBase y1 ->
          case y1 of {
            TmLit dt -> wild `cast` <Co:37>;
            TmAdd y2 y3 ->
              case (evalTerm y2) `cast` <Co:26> of {
                BMBase y4 ->
                  case y4 of {
                    TmLit dt ->
                      case (evalTerm y3) `cast` <Co:26> of {
                        BMBase y5 ->
                          case y5 of {
                            TmLit dt1 ->
                              evalTerm ((BMBase (TmLit (+# dt dt1))) `cast` <Co:515>);
                            TmAdd ipv ipv1 -> wild `cast` <Co:37>
                          };
                        BMMul ipv -> wild `cast` <Co:37>
                      };
                    TmAdd ipv ipv1 -> wild `cast` <Co:37>
                  };
                BMMul ipv -> wild `cast` <Co:37>
              }
          };
        BMMul ipv ->
          case ipv of { TmMul x1 x2 ->
          case (evalTerm x1) `cast` <Co:26> of {
            BMBase y1 ->
              case y1 of {
                TmLit dt ->
                  case (evalTerm x2) `cast` <Co:26> of {
                    BMBase y2 ->
                      case y2 of {
                        TmLit dt1 ->
                          evalTerm ((BMBase (TmLit (*# dt dt1))) `cast` <Co:515>);
                        TmAdd ipv1 ipv2 -> wild `cast` <Co:37>
                      };
                    BMMul ipv1 -> wild `cast` <Co:37>
                  };
                TmAdd ipv1 ipv2 -> wild `cast` <Co:37>
              };
            BMMul ipv1 -> wild `cast` <Co:37>
          }
          }
      }
end Rec }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lit3 :: forall a. BaseF (Term TermF) a
lit3 = \ (@ a) -> TmLit 2#

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
lit1 :: forall a. TermF (Term TermF) a
lit1 = \ (@ a) -> BMBase lit3

-- RHS size: {terms: 1, types: 0, coercions: 594, joins: 0/0}
lit2 :: forall a. Term TermF a
lit2 = lit1 `cast` <Co:594>

-- RHS size: {terms: 11, types: 21, coercions: 574, joins: 0/0}
evalAddSmall
  :: forall a.
     (Term TermF a -> Term TermF a) -> Term TermF a -> Term TermF a
evalAddSmall
  = \ (@ a)
      (eval :: Term TermF a -> Term TermF a)
      (tm :: Term TermF a) ->
      eval
        (case tm `cast` <Co:3> of nt { __DEFAULT ->
         (BMBase (TmAdd (nt `cast` <Co:4>) (nt `cast` <Co:4>)))
         `cast` <Co:563>
         })

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
evalAddBig4 :: forall a. BaseF (Term TermF) a
evalAddBig4 = \ (@ a) -> TmLit 3#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
evalAddBig2 :: forall a. BaseF (Term TermF) a
evalAddBig2 = \ (@ a) -> TmLit 5#

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
evalAddBig3 :: forall a. TermF (Term TermF) a
evalAddBig3 = \ (@ a) -> BMBase evalAddBig4

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
evalAddBig1 :: forall a. TermF (Term TermF) a
evalAddBig1 = \ (@ a) -> BMBase evalAddBig2

-- RHS size: {terms: 14, types: 29, coercions: 2,391, joins: 0/0}
evalAddMulSmall
  :: forall a.
     (Term TermF a -> Term TermF a) -> Term TermF a -> Term TermF a
evalAddMulSmall
  = \ (@ a)
      (eval :: Term TermF a -> Term TermF a)
      (tm :: Term TermF a) ->
      eval
        (case tm `cast` <Co:3> of nt { __DEFAULT ->
         (BMBase
            (TmAdd
               ((BMMul (TmMul (nt `cast` <Co:4>) (evalAddBig3 `cast` <Co:591>)))
                `cast` <Co:639>)
               (evalAddBig1 `cast` <Co:591>)))
         `cast` <Co:563>
         })

-- RHS size: {terms: 17, types: 35, coercions: 2,882, joins: 0/0}
evalAddBig
  :: forall a.
     (Term TermF a -> Term TermF a) -> Term TermF a -> Term TermF a
evalAddBig
  = \ (@ a)
      (eval :: Term TermF a -> Term TermF a)
      (tm :: Term TermF a) ->
      eval
        (case tm `cast` <Co:3> of nt { __DEFAULT ->
         (BMBase
            (TmAdd
               ((BMBase (TmAdd (nt `cast` <Co:4>) (evalAddBig3 `cast` <Co:591>)))
                `cast` <Co:563>)
               ((BMBase (TmAdd (nt `cast` <Co:4>) (evalAddBig1 `cast` <Co:591>)))
                `cast` <Co:563>)))
         `cast` <Co:563>
         })

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
evalAddMulBig4 :: forall a. BaseF (Term TermF) a
evalAddMulBig4 = \ (@ a) -> TmLit 7#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
evalAddMulBig2 :: forall a. BaseF (Term TermF) a
evalAddMulBig2 = \ (@ a) -> TmLit 11#

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
evalAddMulBig3 :: forall a. TermF (Term TermF) a
evalAddMulBig3 = \ (@ a) -> BMBase evalAddMulBig4

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
evalAddMulBig1 :: forall a. TermF (Term TermF) a
evalAddMulBig1 = \ (@ a) -> BMBase evalAddMulBig2

-- RHS size: {terms: 29, types: 61, coercions: 6,476, joins: 0/0}
evalAddMulBig
  :: forall a.
     (Term TermF a -> Term TermF a) -> Term TermF a -> Term TermF a
evalAddMulBig
  = \ (@ a)
      (eval :: Term TermF a -> Term TermF a)
      (tm :: Term TermF a) ->
      eval
        (case tm `cast` <Co:3> of nt { __DEFAULT ->
         (BMBase
            (TmAdd
               ((BMMul
                   (TmMul
                      ((BMBase (TmAdd (nt `cast` <Co:4>) (evalAddBig3 `cast` <Co:591>)))
                       `cast` <Co:563>)
                      ((BMBase (TmAdd (nt `cast` <Co:4>) (evalAddBig1 `cast` <Co:591>)))
                       `cast` <Co:563>)))
                `cast` <Co:639>)
               ((BMMul
                   (TmMul
                      ((BMBase
                          (TmAdd (nt `cast` <Co:4>) (evalAddMulBig3 `cast` <Co:591>)))
                       `cast` <Co:563>)
                      ((BMBase
                          (TmAdd (nt `cast` <Co:4>) (evalAddMulBig1 `cast` <Co:591>)))
                       `cast` <Co:563>)))
                `cast` <Co:639>)))
         `cast` <Co:563>
         })

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Initial.Bench"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[1 of 4] Compiling Term             ( src/Term.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/vanilla-0.1.0.0/build/Term.o )
[15 of 20] Compiling Example.Base     ( src/Example/Base.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Base.o )
Preprocessing library 'final-bp-mul' for final-bp-0.1.0.0..
Building library 'final-bp-mul' instantiated with
  Mul = <Mul>
  Repr = <Repr>
for final-bp-0.1.0.0..

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 67, types: 200, coercions: 3,088, joins: 0/0}

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
term5 :: forall a (tm :: (* -> *) -> * -> *). BaseF (Term tm) a
term5 = \ (@ a) (@ (tm :: (* -> *) -> * -> *)) -> TmLit 8#

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
term4 :: forall a (tm :: (* -> *) -> * -> *). BaseF (Term tm) a
term4 = \ (@ a) (@ (tm :: (* -> *) -> * -> *)) -> TmLit 1#

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
term3 :: forall a (tm :: (* -> *) -> * -> *). BaseF (Term tm) a
term3 = \ (@ a) (@ (tm :: (* -> *) -> * -> *)) -> TmLit 2#

-- RHS size: {terms: 35, types: 75, coercions: 2,495, joins: 0/0}
term2
  :: forall (tm :: (* -> *) -> * -> *) a.
     HasBaseF tm =>
     Tagged (tm (Term tm) a) (Identity (tm (Term tm) a))
term2
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm) ->
      ($dHasBaseF `cast` <Co:2>)
        $fChoiceTagged
        $fApplicativeIdentity
        (case (($dHasBaseF `cast` <Co:2>)
                 $fChoiceTagged $fApplicativeIdentity (term5 `cast` <Co:45>))
              `cast` <Co:534>
         of nt
         { __DEFAULT ->
         case (($dHasBaseF `cast` <Co:2>)
                 $fChoiceTagged
                 $fApplicativeIdentity
                 (case (($dHasBaseF `cast` <Co:2>)
                          $fChoiceTagged $fApplicativeIdentity (term4 `cast` <Co:45>))
                       `cast` <Co:534>
                  of nt1
                  { __DEFAULT ->
                  case (($dHasBaseF `cast` <Co:2>)
                          $fChoiceTagged $fApplicativeIdentity (term3 `cast` <Co:45>))
                       `cast` <Co:534>
                  of nt2
                  { __DEFAULT ->
                  (TmAdd (nt1 `cast` <Co:4>) (nt2 `cast` <Co:4>)) `cast` <Co:75>
                  }
                  }))
              `cast` <Co:582>
         of nt1
         { __DEFAULT ->
         (TmAdd (nt `cast` <Co:4>) (nt1 `cast` <Co:4>)) `cast` <Co:75>
         }
         })

-- RHS size: {terms: 1, types: 0, coercions: 593, joins: 0/0}
term1
  :: forall (tm :: (* -> *) -> * -> *) a. HasBaseF tm => Term tm a
term1 = term2 `cast` <Co:593>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[16 of 20] Compiling Example.Term.Base.Print ( src/Example/Term/Base/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/Base/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 48, types: 119, coercions: 907, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.Base.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 8, types: 29, coercions: 3, joins: 0/0}
print7 :: forall a. [PrintRule (Term TermF a)]
print7
  = \ (@ a) ->
      case $wprintRules ($fHasBaseFBaseF_$c_BaseF `cast` <Co:3>) of
      { (# ww1, ww2 #) ->
      : ww1 ww2
      }

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
printTerm :: forall a. Term TermF a -> Maybe String
printTerm = \ (@ a) -> mkPrint print7

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print6 :: BaseF (Term TermF) Any
print6 = TmLit 8#

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print5 :: BaseF (Term TermF) Any
print5 = TmLit 1#

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print4 :: BaseF (Term TermF) Any
print4 = TmLit 2#

-- RHS size: {terms: 3, types: 5, coercions: 12, joins: 0/0}
print3 :: BaseF (Term TermF) Any
print3 = TmAdd (print5 `cast` <Co:6>) (print4 `cast` <Co:6>)

-- RHS size: {terms: 3, types: 5, coercions: 12, joins: 0/0}
print2 :: BaseF (Term TermF) Any
print2 = TmAdd (print6 `cast` <Co:6>) (print3 `cast` <Co:6>)

-- RHS size: {terms: 3, types: 8, coercions: 880, joins: 0/0}
print1 :: Maybe String
print1 = mkPrint print7 (print2 `cast` <Co:880>)



[17 of 20] Compiling Example.Term.Base.Eval ( src/Example/Term/Base/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/Base/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 395, types: 1,388, coercions: 716, joins: 0/0}

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
$WLit :: Int -> Term
$WLit = \ (dt :: Int) -> case dt of { I# dt -> Lit dt }

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
$WAdd :: Term -> Term -> Term
$WAdd
  = \ (dt :: Term) (dt :: Term) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> Add dt dt }
      }

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
$WMul :: Term -> Term -> Term
$WMul
  = \ (dt :: Term) (dt :: Term) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> Mul dt dt }
      }

-- RHS size: {terms: 24, types: 528, coercions: 347, joins: 0/0}
$fGenericTerm_$cto :: forall x. Rep Term x -> Term
$fGenericTerm_$cto
  = \ (@ x) (ds :: Rep Term x) ->
      case ds `cast` <Co:124> of {
        L1 ds1 -> $WLit (ds1 `cast` <Co:47>);
        R1 ds1 ->
          case ds1 of {
            L1 ds2 ->
              case ds2 `cast` <Co:42> of { :*: ds3 ds4 ->
              $WAdd (ds3 `cast` <Co:23>) (ds4 `cast` <Co:23>)
              };
            R1 ds2 ->
              case ds2 `cast` <Co:42> of { :*: ds3 ds4 ->
              $WMul (ds3 `cast` <Co:23>) (ds4 `cast` <Co:23>)
              }
          }
      }

-- RHS size: {terms: 20, types: 577, coercions: 236, joins: 0/0}
$fGenericTerm1
  :: forall x.
     Term
     -> (:+:)
          (M1
             C
             ('MetaCons "Lit" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedUnpack)
                (K1 R Int)))
          (M1
             C
             ('MetaCons "Add" 'PrefixI 'False)
             (M1
                S
                ('MetaSel
                   'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                (K1 R Term)
              :*: M1
                    S
                    ('MetaSel
                       'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                    (K1 R Term))
           :+: M1
                 C
                 ('MetaCons "Mul" 'PrefixI 'False)
                 (M1
                    S
                    ('MetaSel
                       'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                    (K1 R Term)
                  :*: M1
                        S
                        ('MetaSel
                           'Nothing 'NoSourceUnpackedness 'SourceStrict 'DecidedStrict)
                        (K1 R Term)))
          x
$fGenericTerm1
  = \ (@ x) (x1 :: Term) ->
      case x1 of {
        Lit dt -> L1 ((I# dt) `cast` <Co:50>);
        Add g1 g2 ->
          R1
            (L1
               ((:*: (g1 `cast` <Co:25>) (g2 `cast` <Co:25>)) `cast` <Co:43>));
        Mul g1 g2 ->
          R1
            (R1 ((:*: (g1 `cast` <Co:25>) (g2 `cast` <Co:25>)) `cast` <Co:43>))
      }

-- RHS size: {terms: 3, types: 1, coercions: 130, joins: 0/0}
$fGenericTerm :: Generic Term
$fGenericTerm
  = C:Generic ($fGenericTerm1 `cast` <Co:130>) $fGenericTerm_$cto

Rec {
-- RHS size: {terms: 19, types: 9, coercions: 0, joins: 0/0}
$fNFDataTerm_$crnf :: Term -> ()
$fNFDataTerm_$crnf
  = \ (x :: Term) ->
      case x of {
        Lit dt -> ();
        Add g1 g2 ->
          case $fNFDataTerm_$crnf g1 of { () -> $fNFDataTerm_$crnf g2 };
        Mul g1 g2 ->
          case $fNFDataTerm_$crnf g1 of { () -> $fNFDataTerm_$crnf g2 }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
$fNFDataTerm :: NFData Term
$fNFDataTerm = $fNFDataTerm_$crnf `cast` <Co:3>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Addr#
lvl = "Mul "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1 :: Addr#
lvl1 = "Add "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2 :: Addr#
lvl2 = "Lit "#

Rec {
-- RHS size: {terms: 107, types: 45, coercions: 0, joins: 0/0}
$w$cshowsPrec :: Int# -> Term -> String -> String
$w$cshowsPrec
  = \ (ww :: Int#) (w :: Term) (w1 :: String) ->
      case w of {
        Lit dt ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl2
                (case $wshowSignedInt 11# dt w1 of { (# ww5, ww6 #) ->
                 : ww5 ww6
                 });
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl2
                   (case $wshowSignedInt 11# dt (: $fShow(,)2 w1) of
                    { (# ww5, ww6 #) ->
                    : ww5 ww6
                    }))
          };
        Add b1 b2 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl1
                ($w$cshowsPrec 11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 w1)));
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl1
                   ($w$cshowsPrec
                      11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 (: $fShow(,)2 w1)))))
          };
        Mul b1 b2 ->
          case tagToEnum# (>=# ww 11#) of {
            False ->
              unpackAppendCString#
                lvl
                ($w$cshowsPrec 11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 w1)));
            True ->
              : $fShow(,)4
                (unpackAppendCString#
                   lvl
                   ($w$cshowsPrec
                      11# b1 (: showSpace1 ($w$cshowsPrec 11# b2 (: $fShow(,)2 w1)))))
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
$fShowTerm_$cshowsPrec :: Int -> Term -> ShowS
$fShowTerm_$cshowsPrec
  = \ (w :: Int) (w1 :: Term) (w2 :: String) ->
      case w of { I# ww1 -> $w$cshowsPrec ww1 w1 w2 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShowTerm2 :: Int
$fShowTerm2 = I# 0#

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$fShowTerm_$cshow :: Term -> String
$fShowTerm_$cshow = \ (x :: Term) -> $w$cshowsPrec 0# x []

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
$fShowTerm1 :: Term -> ShowS
$fShowTerm1 = \ (w :: Term) (w1 :: String) -> $w$cshowsPrec 0# w w1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
$fShowTerm_$cshowList :: [Term] -> ShowS
$fShowTerm_$cshowList = showList__ $fShowTerm1

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$fShowTerm :: Show Term
$fShowTerm
  = C:Show
      $fShowTerm_$cshowsPrec $fShowTerm_$cshow $fShowTerm_$cshowList

Rec {
-- RHS size: {terms: 46, types: 19, coercions: 0, joins: 0/0}
$fEqTerm_$c== :: Term -> Term -> Bool
$fEqTerm_$c==
  = \ (ds :: Term) (ds1 :: Term) ->
      case ds of {
        Lit dt ->
          case ds1 of {
            __DEFAULT -> False;
            Lit dt1 -> tagToEnum# (==# dt dt1)
          };
        Add a1 a2 ->
          case ds1 of {
            __DEFAULT -> False;
            Add b1 b2 ->
              case $fEqTerm_$c== a1 b1 of {
                False -> False;
                True -> $fEqTerm_$c== a2 b2
              }
          };
        Mul a1 a2 ->
          case ds1 of {
            __DEFAULT -> False;
            Mul b1 b2 ->
              case $fEqTerm_$c== a1 b1 of {
                False -> False;
                True -> $fEqTerm_$c== a2 b2
              }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
$fEqTerm_$c/= :: Term -> Term -> Bool
$fEqTerm_$c/=
  = \ (a :: Term) (b :: Term) ->
      case $fEqTerm_$c== a b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$fEqTerm :: Eq Term
$fEqTerm = C:Eq $fEqTerm_$c== $fEqTerm_$c/=

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "vanilla-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcInt []

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcTerm :: TyCon
$tcTerm
  = TyCon
      8629467898741628768##
      9951461721024085629##
      $trModule
      $trModule1
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepTyConApp $tcTerm []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Lit1 :: KindRep
$tc'Lit1 = KindRepFun $krep $krep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Lit3 :: Addr#
$tc'Lit3 = "'Lit"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Lit2 :: TrName
$tc'Lit2 = TrNameS $tc'Lit3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Lit :: TyCon
$tc'Lit
  = TyCon
      2342378171150062080##
      12472488204346948629##
      $trModule
      $tc'Lit2
      0#
      $tc'Lit1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepFun $krep1 $krep1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Add1 :: KindRep
$tc'Add1 = KindRepFun $krep1 $krep2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Add3 :: Addr#
$tc'Add3 = "'Add"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Add2 :: TrName
$tc'Add2 = TrNameS $tc'Add3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Add :: TyCon
$tc'Add
  = TyCon
      174417796076596483##
      11704673920255722318##
      $trModule
      $tc'Add2
      0#
      $tc'Add1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Mul2 :: Addr#
$tc'Mul2 = "'Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Mul1 :: TrName
$tc'Mul1 = TrNameS $tc'Mul2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Mul :: TyCon
$tc'Mul
  = TyCon
      3199096669262240386##
      17499016737731937603##
      $trModule
      $tc'Mul1
      0#
      $tc'Add1



[1 of 2] Compiling Repr[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-mul/build/final-bp-mul/autogen/Repr.hsig, nothing )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 65, types: 125, coercions: 1,447, joins: 0/0}

Rec {
-- RHS size: {terms: 24, types: 44, coercions: 777, joins: 0/0}
evalTerm :: forall a. Term TermF a -> Term TermF a
evalTerm
  = \ (@ a) (tm1 :: Term TermF a) ->
      case tm1 `cast` <Co:38> of wild {
        TmLit dt -> wild `cast` <Co:37>;
        TmAdd y1 y2 ->
          case (evalTerm y1) `cast` <Co:26> of {
            TmLit dt ->
              case (evalTerm y2) `cast` <Co:26> of {
                TmLit dt1 -> evalTerm ((TmLit (+# dt dt1)) `cast` <Co:576>);
                TmAdd ipv ipv1 -> wild `cast` <Co:37>
              };
            TmAdd ipv ipv1 -> wild `cast` <Co:37>
          }
      }
end Rec }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
eval6 :: forall a. BaseF (Term TermF) a
eval6 = \ (@ a) -> TmLit 8#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
eval5 :: forall a. BaseF (Term TermF) a
eval5 = \ (@ a) -> TmLit 1#

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
eval4 :: forall a. BaseF (Term TermF) a
eval4 = \ (@ a) -> TmLit 2#

-- RHS size: {terms: 4, types: 7, coercions: 8, joins: 0/0}
eval3 :: forall a. BaseF (Term TermF) a
eval3
  = \ (@ a) -> TmAdd (eval5 `cast` <Co:4>) (eval4 `cast` <Co:4>)

-- RHS size: {terms: 4, types: 7, coercions: 8, joins: 0/0}
eval2 :: forall a. BaseF (Term TermF) a
eval2
  = \ (@ a) -> TmAdd (eval6 `cast` <Co:4>) (eval3 `cast` <Co:4>)

-- RHS size: {terms: 3, types: 4, coercions: 654, joins: 0/0}
eval1 :: forall a. Term TermF a
eval1 = \ (@ a) -> evalTerm (eval2 `cast` <Co:654>)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.Base.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[18 of 20] Compiling Example.Mul      ( src/Example/Mul.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Mul.o )
[2 of 2] Compiling Mul[sig]         ( final-bp-mul/Mul.hsig, nothing )
Configuring library 'final-bp-mul-eval' for final-bp-0.1.0.0..
[2 of 4] Compiling Interpret.Print  ( src/Interpret/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/vanilla-0.1.0.0/build/Interpret/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 81, types: 278, coercions: 4,039, joins: 0/0}

-- RHS size: {terms: 4, types: 13, coercions: 0, joins: 0/0}
term7 :: forall a (tm :: (* -> *) -> * -> *). BaseF (Term tm) a
term7 = \ (@ a) (@ (tm :: (* ->
 *) -> * -> *)) -> TmLit 7#

==================== Tidy Core ====================
-- RHS size:Result size of {terms: Tidy Core 4, types: 13, coercions: 0, joins: 0/0}

  = {terms: 63, types: 35, coercions: 0, joins: 0/0}

-- RHS size: {terms:term6 :: forall 1, types: a (tm :: 0, coercions: (* -> 0, joins: *) -> 0/0}
 * -> *). BaseF (Term tm) a
$trModule4 :: Addr#
$trModule4 = "vanilla-0.1.0.0-inplace"#
term6 = \
 (@-- RHS size: a) (@ {terms: (tm :: (* -> 2, types: *) -> 0, coercions: * -> 0, joins: *)) -> 0/0}
 TmLit 1#
$trModule3 ::
 TrName
-- RHS size: {terms:$trModule3 = TrNameS $trModule4
 4, types:
 13, coercions:-- RHS size: 0, joins: {terms: 0/0}
 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Interpret.Print"#
term5 :: forall
 a (tm ::-- RHS size: (* -> {terms: *) -> * -> 2, types: *). BaseF (Term tm) a
 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
term5 = \$trModule1 = TrNameS $trModule2
 (@ a) (@
 (tm ::-- RHS size: (* -> {terms: *) -> * -> 3, types: *)) -> 0, coercions: TmLit 2#
 0, joins: 0/0}
$trModule ::
 Module
-- RHS size: {terms:$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Addr#
lvl = ")"#

-- RHS size: {terms: 31, types: 71, coercions: 1, types: 2,047, joins: 0, coercions: 0/0}
 0, joins: 0/0}
lvl1 :: Addr#
lvl1 = " * "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins:term1
 0/0}
  :: foralllvl2 :: Addr#
 (tm ::lvl2 = "("#
 (* ->
 *) ->-- RHS size: * -> {terms: *) a.
 1, types:     (HasBaseF tm, HasMulF tm) => 0, coercions:
 0, joins: 0/0}
lvl3 :: Addr#
lvl3 = " + "#
     Tagged (tm (Term tm) a) (Identity (tm (Term tm) a))

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term1
  = \lvl4 :: (@ [Char]
 (tm ::lvl4 = unpackCString# lvl

Rec { (* -> *) ->
 * ->-- RHS size: *))
 {terms:      (@ a)
 37, types:      ($dHasBaseF :: 22, coercions: HasBaseF tm)
 0, joins: 0/0}
      ($dHasMulF ::printTerm :: HasMulF tm) -> Term ->
 String
      ($dHasBaseF `cast` <Co:2>)
        printTerm
$fChoiceTagged
  = \        $fApplicativeIdentity
        (case (ds :: Term) ->
 (($dHasBaseF `cast`      case <Co:2>)
                 ds of {
        Lit dt ->
         $fChoiceTagged $fApplicativeIdentity (term7 `cast`  case <Co:45>))
              `cast` <Co: $wshowSignedInt 0# dt [] of { (#534>
         ww5, ww6 #) of -> nt
 : ww5 ww6 };
                 { __DEFAULT ->
        Add tm1 tm2 -> case
          unpackAppendCString#
         (_Mul
                    lvl2
         $dHasMulF
            (++
                 $fChoiceTagged
               (printTerm tm1)
                 $fApplicativeIdentity
                       (unpackAppendCString# lvl3 (++ (printTerm tm2) lvl4)));
         (((($dHasBaseF `cast` <Co:Mul tm1 tm2 ->2>)

                          unpackAppendCString#
            lvl2
            (++
              $fChoiceTagged $fApplicativeIdentity (term6 `cast`       (printTerm tm1)
 <Co:        45>))
                   `cast`       (unpackAppendCString# lvl1 (++ (printTerm tm2) lvl4)))
 <Co:      }
end Rec }530>,

        
        

   (($dHasBaseF `cast` <Co:2>)
                      $fChoiceTagged $fApplicativeIdentity (term5 `cast` <Co:45>))
                   `cast` <Co:530>)
                  `cast` <Co:113>))
              `cast` <Co:114>
         of nt1
         { __DEFAULT ->
         (TmAdd (nt `cast` <Co:4>) (nt1 `cast` <Co:4>)) `cast` <Co:75>
         }
         })

-- RHS size: {terms: 1, types: 0, coercions: 596, joins: 0/0}
term2
  :: forall (tm :: (* -> *) -> * -> *) a.
     (HasBaseF tm, HasMulF tm) =>
     Term tm a
term2 = term1 `cast` <Co:596>

-- RHS size: {terms: 15, types: 37, coercions: 1,268, joins: 0/0}
term8
  :: forall (tm :: (* -> *) -> * -> *) a.
     (HasBaseF tm, HasMulF tm) =>
     Tagged (Term tm a) (Identity (Term tm a))
term8
  = \ (@ (tm :: (* -> *) -> * -> *))
      (@ a)
      ($dHasBaseF :: HasBaseF tm)
      ($dHasMulF :: HasMulF tm) ->
      _Mul
        $dHasMulF
        $fChoiceTagged
        $fApplicativeIdentity
        (((($dHasBaseF `cast` <Co:2>)
             $fChoiceTagged $fApplicativeIdentity (term7 `cast` <Co:45>))
          `cast` <Co:530>,
          (term2 $dHasBaseF) `cast` <Co:578>)
         `cast` <Co:113>)

-- RHS size: {terms: 1, types: 0, coercions: 128, joins: 0/0}
term3
  :: forall (tm :: (* -> *) -> * -> *) a.
     (HasBaseF tm, HasMulF tm) =>
     Term tm a
term3 = term8 `cast` <Co:128>

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[3 of 4] Compiling Interpret.Eval   ( src/Interpret/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/vanilla-0.1.0.0/build/Interpret/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 54, types: 22, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "vanilla-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Interpret.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

Rec {
-- RHS size: {terms: 39, types: 15, coercions: 0, joins: 0/0}
evalTerm :: Term -> Term
evalTerm
  = \ (tm :: Term) ->
      case tm of wild {
        Lit ipv -> wild;
        Add tm1 tm2 ->
          case evalTerm tm1 of {
            __DEFAULT -> wild;
            Lit dt ->
              case evalTerm tm2 of {
                __DEFAULT -> wild;
                Lit dt1 -> Lit (+# dt dt1)
              }
          };
        Mul tm1 tm2 ->
          case evalTerm tm1 of {
            __DEFAULT -> wild;
            Lit dt ->
              case evalTerm tm2 of {
                __DEFAULT -> wild;
                Lit dt1 -> Lit (*# dt dt1)
              }
          }
      }
end Rec }



[19 of 20] Compiling Example.Term.BaseMul.Print ( src/Example/Term/BaseMul/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/BaseMul/Print.o )
Configuring library 'final-bp-base-eval' for final-bp-0.1.0.0..
Preprocessing library 'final-bp-base' for final-bp-0.1.0.0..
[4 of 4] Compiling Vanilla.Bench    ( src/Vanilla/Bench.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/vanilla-0.1.0.0/build/Vanilla/Bench.o )
Building library 'final-bp-base' instantiated with
  Base = <Base>
  Repr = <Repr>
for final-bp-0.1.0.0..

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 83, types: 26, coercions: 0, joins: 0/0}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lit2 :: Term
lit2 = Lit 2#

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
evalAddSmall :: Term -> Term
evalAddSmall
  = \ (tm :: Term) ->
      case tm of dt { __DEFAULT -> evalTerm (Add dt dt) }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddBig2 :: Term
evalAddBig2 = Lit 3#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddBig1 :: Term
evalAddBig1 = Lit 5#

-- RHS size: {terms: 10, types: 2, coercions: 0, joins: 0/0}
evalAddMulSmall :: Term -> Term
evalAddMulSmall
  = \ (tm :: Term) ->
      case tm of dt { __DEFAULT ->
      evalTerm (Add (Mul dt evalAddBig2) evalAddBig1)
      }

-- RHS size: {terms: 12, types: 2, coercions: 0, joins: 0/0}
evalAddBig :: Term -> Term
evalAddBig
  = \ (tm :: Term) ->
      case tm of dt { __DEFAULT ->
      evalTerm (Add (Add dt evalAddBig2) (Add dt evalAddBig1))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddMulBig2 :: Term
evalAddMulBig2 = Lit 7#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddMulBig1 :: Term
evalAddMulBig1 = Lit 11#

-- RHS size: {terms: 20, types: 2, coercions: 0, joins: 0/0}
evalAddMulBig :: Term -> Term
evalAddMulBig
  = \ (tm :: Term) ->
      case tm of dt { __DEFAULT ->
      evalTerm
        (Add
           (Mul (Add dt evalAddBig2) (Add dt evalAddBig1))
           (Mul (Add dt evalAddMulBig2) (Add dt evalAddMulBig1)))
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "vanilla-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Vanilla.Bench"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 109, types: 323, coercions: 5,199, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.BaseMul.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 8, types: 29, coercions: 3, joins: 0/0}
print15 :: forall a. [PrintRule (Term TermF a)]
print15
  = \ (@ a) ->
      case $wprintRules (_BMMul `cast` <Co:3>) of { (# ww1, ww2 #) ->
      : ww1 ww2
      }

-- RHS size: {terms: 10, types: 34, coercions: 3, joins: 0/0}
print14 :: forall a. [PrintRule (Term TermF a)]
print14
  = \ (@ a) ->
      case $wprintRules (_BMBase `cast` <Co:3>) of { (# ww1, ww2 #) ->
      ++ (: ww1 ww2) print15
      }

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
printTerm :: forall a. Term TermF a -> Maybe String
printTerm = \ (@ a) -> mkPrint print14

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print13 :: BaseF (Term TermF) Any
print13 = TmLit 8#

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print12 :: TermF (Term TermF) Any
print12 = BMBase print13

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print11 :: BaseF (Term TermF) Any
print11 = TmLit 1#

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print10 :: TermF (Term TermF) Any
print10 = BMBase print11

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print9 :: BaseF (Term TermF) Any
print9 = TmLit 2#

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print8 :: TermF (Term TermF) Any
print8 = BMBase print9

-- RHS size: {terms: 3, types: 5, coercions: 12, joins: 0/0}
print7 :: BaseF (Term TermF) Any
print7 = TmAdd (print10 `cast` <Co:6>) (print8 `cast` <Co:6>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print6 :: TermF (Term TermF) Any
print6 = BMBase print7

-- RHS size: {terms: 3, types: 5, coercions: 12, joins: 0/0}
print5 :: BaseF (Term TermF) Any
print5 = TmAdd (print12 `cast` <Co:6>) (print6 `cast` <Co:6>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print4 :: TermF (Term TermF) Any
print4 = BMBase print5

-- RHS size: {terms: 3, types: 8, coercions: 757, joins: 0/0}
print1 :: Maybe String
print1 = mkPrint print14 (print4 `cast` <Co:757>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print21 :: BaseF (Term TermF) Any
print21 = TmLit 7#

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print20 :: TermF (Term TermF) Any
print20 = BMBase print21

-- RHS size: {terms: 3, types: 5, coercions: 1,354, joins: 0/0}
print19 :: MulF (Term TermF) Any
print19 = TmMul (print10 `cast` <Co:677>) (print8 `cast` <Co:677>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print18 :: TermF (Term TermF) Any
print18 = BMMul print19

-- RHS size: {terms: 3, types: 5, coercions: 12, joins: 0/0}
print17 :: BaseF (Term TermF) Any
print17 = TmAdd (print20 `cast` <Co:6>) (print18 `cast` <Co:6>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print16 :: TermF (Term TermF) Any
print16 = BMBase print17

-- RHS size: {terms: 3, types: 8, coercions: 757, joins: 0/0}
print2 :: Maybe String
print2 = mkPrint print14 (print16 `cast` <Co:757>)

-- RHS size: {terms: 3, types: 5, coercions: 1,434, joins: 0/0}
print23 :: MulF (Term TermF) Any
print23 = TmMul (print20 `cast` <Co:677>) (print4 `cast` <Co:757>)

-- RHS size: {terms: 2, types: 5, coercions: 0, joins: 0/0}
print22 :: TermF (Term TermF) Any
print22 = BMMul print23

-- RHS size: {terms: 3, types: 8, coercions: 855, joins: 0/0}
print3 :: Maybe String
print3 = mkPrint print14 (print22 `cast` <Co:855>)



[20 of 20] Compiling Example.Term.BaseMul.Eval ( src/Example/Term/BaseMul/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-0.1.0.0/build/Example/Term/BaseMul/Eval.o )
[1 of 2] Compiling Repr[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-base/build/final-bp-base/autogen/Repr.hsig, nothing )
Configuring library 'initial-bp-mul-sig' for initial-bp-0.1.0.0..
[2 of 2] Compiling Base[sig]        ( final-bp-base/Base.hsig, nothing )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 174, types: 405, coercions: 5,402, joins: 0/0}

Rec {
-- RHS size: {terms: 70, types: 148, coercions: 1,505, joins: 0/0}
evalTerm :: forall a. Term TermF a -> Term TermF a
evalTerm
  = \ (@ a) (tm1 :: Term TermF a) ->
      case tm1 `cast` <Co:38> of wild {
        BMBase y1 ->
          case y1 of {
            TmLit dt -> wild `cast` <Co:37>;
            TmAdd y2 y3 ->
              case (evalTerm y2) `cast` <Co:26> of {
                BMBase y4 ->
                  case y4 of {
                    TmLit dt ->
                      case (evalTerm y3) `cast` <Co:26> of {
                        BMBase y5 ->
                          case y5 of {
                            TmLit dt1 ->
                              evalTerm ((BMBase (TmLit (+# dt dt1))) `cast` <Co:515>);
                            TmAdd ipv ipv1 -> wild `cast` <Co:37>
                          };
                        BMMul ipv -> wild `cast` <Co:37>
                      };
                    TmAdd ipv ipv1 -> wild `cast` <Co:37>
                  };
                BMMul ipv -> wild `cast` <Co:37>
              }
          };
        BMMul ipv ->
          case ipv of { TmMul x1 x2 ->
          case (evalTerm x1) `cast` <Co:26> of {
            BMBase y1 ->
              case y1 of {
                TmLit dt ->
                  case (evalTerm x2) `cast` <Co:26> of {
                    BMBase y2 ->
                      case y2 of {
                        TmLit dt1 ->
                          evalTerm ((BMBase (TmLit (*# dt dt1))) `cast` <Co:515>);
                        TmAdd ipv1 ipv2 -> wild `cast` <Co:37>
                      };
                    BMMul ipv1 -> wild `cast` <Co:37>
                  };
                TmAdd ipv1 ipv2 -> wild `cast` <Co:37>
              };
            BMMul ipv1 -> wild `cast` <Co:37>
          }
          }
      }
end Rec }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
eval13 :: forall a. BaseF (Term TermF) a
eval13 = \ (@ a) -> TmLit 8#

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval12 :: forall a. TermF (Term TermF) a
eval12 = \ (@ a) -> BMBase eval13

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
eval11 :: forall a. BaseF (Term TermF) a
eval11 = \ (@ a) -> TmLit 1#

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval10 :: forall a. TermF (Term TermF) a
eval10 = \ (@ a) -> BMBase eval11

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
eval9 :: forall a. BaseF (Term TermF) a
eval9 = \ (@ a) -> TmLit 2#

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval8 :: forall a. TermF (Term TermF) a
eval8 = \ (@ a) -> BMBase eval9

-- RHS size: {terms: 4, types: 7, coercions: 8, joins: 0/0}
eval7 :: forall a. BaseF (Term TermF) a
eval7
  = \ (@ a) -> TmAdd (eval10 `cast` <Co:4>) (eval8 `cast` <Co:4>)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval6 :: forall a. TermF (Term TermF) a
eval6 = \ (@ a) -> BMBase eval7

-- RHS size: {terms: 4, types: 7, coercions: 8, joins: 0/0}
eval5 :: forall a. BaseF (Term TermF) a
eval5
  = \ (@ a) -> TmAdd (eval12 `cast` <Co:4>) (eval6 `cast` <Co:4>)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval4 :: forall a. TermF (Term TermF) a
eval4 = \ (@ a) -> BMBase eval5

-- RHS size: {terms: 3, types: 4, coercions: 563, joins: 0/0}
eval1 :: forall a. Term TermF a
eval1 = \ (@ a) -> evalTerm (eval4 `cast` <Co:563>)

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
eval19 :: forall a. BaseF (Term TermF) a
eval19 = \ (@ a) -> TmLit 7#

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval18 :: forall a. TermF (Term TermF) a
eval18 = \ (@ a) -> BMBase eval19

-- RHS size: {terms: 4, types: 7, coercions: 1,030, joins: 0/0}
eval17 :: forall a. MulF (Term TermF) a
eval17
  = \ (@ a) -> TmMul (eval10 `cast` <Co:515>) (eval8 `cast` <Co:515>)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval16 :: forall a. TermF (Term TermF) a
eval16 = \ (@ a) -> BMMul eval17

-- RHS size: {terms: 4, types: 7, coercions: 8, joins: 0/0}
eval15 :: forall a. BaseF (Term TermF) a
eval15
  = \ (@ a) -> TmAdd (eval18 `cast` <Co:4>) (eval16 `cast` <Co:4>)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval14 :: forall a. TermF (Term TermF) a
eval14 = \ (@ a) -> BMBase eval15

-- RHS size: {terms: 3, types: 4, coercions: 563, joins: 0/0}
eval2 :: forall a. Term TermF a
eval2 = \ (@ a) -> evalTerm (eval14 `cast` <Co:563>)

-- RHS size: {terms: 4, types: 7, coercions: 1,078, joins: 0/0}
eval21 :: forall a. MulF (Term TermF) a
eval21
  = \ (@ a) -> TmMul (eval18 `cast` <Co:515>) (eval4 `cast` <Co:563>)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
eval20 :: forall a. TermF (Term TermF) a
eval20 = \ (@ a) -> BMMul eval21

-- RHS size: {terms: 3, types: 4, coercions: 639, joins: 0/0}
eval3 :: forall a. Term TermF a
eval3 = \ (@ a) -> evalTerm (eval20 `cast` <Co:639>)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Term.BaseMul.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Preprocessing library 'final-bp-mul-print' for final-bp-0.1.0.0..
Building library 'final-bp-mul-print' for final-bp-0.1.0.0..
[1 of 1] Compiling Mul              ( final-bp-mul-print/Mul.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-mul-print/build/final-bp-mul-print/Mul.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 35, types: 17, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
mul4 :: Addr#
mul4 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
mul3 :: Addr#
mul3 = ") * ("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
mul2 :: Addr#
mul2 = ")"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
mul1 :: [Char]
mul1 = unpackCString# mul2

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
mul :: String -> String -> String
mul
  = \ (x :: String) (y :: String) ->
      unpackAppendCString#
        mul4 (++ x (unpackAppendCString# mul3 (++ y mul1)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-bp-0.1.0.0-inplace-final-bp-mul-print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Configuring library 'initial-bp-base-sig' for initial-bp-0.1.0.0..
Preprocessing library 'final-bp-base-print' for final-bp-0.1.0.0..
Building library 'final-bp-base-print' for final-bp-0.1.0.0..
[1 of 1] Compiling Base             ( final-bp-base-print/Base.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-base-print/build/final-bp-base-print/Base.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 37, types: 19, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
add4 :: Addr#
add4 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
add3 :: Addr#
add3 = ") + ("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
add2 :: Addr#
add2 = ")"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
add1 :: [Char]
add1 = unpackCString# add2

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
add :: String -> String -> String
add
  = \ (x :: String) (y :: String) ->
      unpackAppendCString#
        add4 (++ x (unpackAppendCString# add3 (++ y add1)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-bp-0.1.0.0-inplace-final-bp-base-print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lit :: Int -> String
lit = $fShowInt_$cshow



Configuring library 'final-bp-example-base' for final-bp-0.1.0.0..
Preprocessing library 'final-bp-mul-eval' for final-bp-0.1.0.0..
Building library 'final-bp-mul-eval' for final-bp-0.1.0.0..
Preprocessing library 'final-bp-base-eval' for final-bp-0.1.0.0..
Building library 'final-bp-base-eval' for final-bp-0.1.0.0..
[1 of 1] Compiling Mul              ( final-bp-mul-eval/Mul.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-mul-eval/build/final-bp-mul-eval/Mul.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 16, types: 8, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-bp-0.1.0.0-inplace-final-bp-mul-eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
mul :: Int -> Int -> Int
mul = $fNumInt_$c*



[1 of 1] Compiling Base             ( final-bp-base-eval/Base.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-base-eval/build/final-bp-base-eval/Base.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 18, types: 11, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 1, coercions: 0, joins: 0/0}
lit :: Int -> Int
lit = id

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-bp-0.1.0.0-inplace-final-bp-base-eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
add :: Int -> Int -> Int
add = $fNumInt_$c+



Preprocessing library 'initial-bp-mul-sig' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul-sig' instantiated with
  Mul.Type = <Mul.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[1 of 2] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-sig/build/initial-bp-mul-sig/autogen/Term/Type.hsig, nothing )
[2 of 2] Compiling Mul.Type[sig]    ( initial-bp-mul-sig/Mul/Type.hsig, nothing )
Preprocessing library 'initial-bp-base-sig' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-sig' instantiated with
  Base.Type = <Base.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
Configuring library 'final-bp-mul' instantiated with
  Mul = final-bp-0.1.0.0-inplace-final-bp-mul-eval:Mul
  Repr = final-bp-0.1.0.0-inplace-final-bp-eval:Repr
for final-bp-0.1.0.0..
[1 of 2] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-sig/build/initial-bp-base-sig/autogen/Term/Type.hsig, nothing )
[2 of 2] Compiling Base.Type[sig]   ( initial-bp-base-sig/Base/Type.hsig, nothing )
Configuring library 'final-bp-base' instantiated with
  Base = final-bp-0.1.0.0-inplace-final-bp-base-eval:Base
  Repr = final-bp-0.1.0.0-inplace-final-bp-eval:Repr
for final-bp-0.1.0.0..
Preprocessing library 'final-bp-example-base' for final-bp-0.1.0.0..
Building library 'final-bp-example-base' instantiated with
  Base = <Base>
  Repr = <Repr>
for final-bp-0.1.0.0..
Configuring library 'initial-bp-mul-print' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-mul' for initial-bp-0.1.0.0..
[1 of 3] Compiling Repr[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/build/final-bp-example-base/autogen/Repr.hsig, nothing )
[2 of 3] Compiling Base[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/build/final-bp-example-base/autogen/Base.hsig, nothing )
[3 of 3] Compiling Example.Base     ( final-bp-example-base/Example/Base.hs, nothing )
Configuring library 'initial-bp-mul-eval' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base-eval' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base-print' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base' for initial-bp-0.1.0.0..
Preprocessing library 'final-bp-mul' for final-bp-0.1.0.0..
Building library 'final-bp-mul' instantiated with
  Mul = final-bp-0.1.0.0-inplace-final-bp-mul-eval:Mul
  Repr = final-bp-0.1.0.0-inplace-final-bp-eval:Repr
for final-bp-0.1.0.0..
Preprocessing library 'final-bp-base' for final-bp-0.1.0.0..
Building library 'final-bp-base' instantiated with
  Base = final-bp-0.1.0.0-inplace-final-bp-base-eval:Base
  Repr = final-bp-0.1.0.0-inplace-final-bp-eval:Repr
for final-bp-0.1.0.0..
[1 of 2] Compiling Repr[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-mul/final-bp-0.1.0.0-inplace-final-bp-mul+7fLy7lkPLW6J7AGrTyeZEp/build/final-bp-0.1.0.0-inplace-final-bp-mul+7fLy7lkPLW6J7AGrTyeZEp/autogen/Repr.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-mul/final-bp-0.1.0.0-inplace-final-bp-mul+7fLy7lkPLW6J7AGrTyeZEp/build/final-bp-0.1.0.0-inplace-final-bp-mul+7fLy7lkPLW6J7AGrTyeZEp/Repr.o )
[1 of 2] Compiling Repr[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-base/final-bp-0.1.0.0-inplace-final-bp-base+2XuPNKz0qU7KGxJd49xi0c/build/final-bp-0.1.0.0-inplace-final-bp-base+2XuPNKz0qU7KGxJd49xi0c/autogen/Repr.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-base/final-bp-0.1.0.0-inplace-final-bp-base+2XuPNKz0qU7KGxJd49xi0c/build/final-bp-0.1.0.0-inplace-final-bp-base+2XuPNKz0qU7KGxJd49xi0c/Repr.o )
Preprocessing library 'initial-bp-mul-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul-print' instantiated with
  Mul.Type = <Mul.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[2 of 2] Compiling Mul[sig]         ( final-bp-mul/Mul.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-mul/final-bp-0.1.0.0-inplace-final-bp-mul+7fLy7lkPLW6J7AGrTyeZEp/build/final-bp-0.1.0.0-inplace-final-bp-mul+7fLy7lkPLW6J7AGrTyeZEp/Mul.o )
Preprocessing library 'initial-bp-mul' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul' instantiated with
  Mul.Type = <Mul.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[2 of 2] Compiling Base[sig]        ( final-bp-base/Base.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-base/final-bp-0.1.0.0-inplace-final-bp-base+2XuPNKz0qU7KGxJd49xi0c/build/final-bp-0.1.0.0-inplace-final-bp-base+2XuPNKz0qU7KGxJd49xi0c/Base.o )
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/build/initial-bp-mul-print/autogen/Term/Type.hsig, nothing )
[2 of 3] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/build/initial-bp-mul-print/autogen/Mul/Type.hsig, nothing )
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul/build/initial-bp-mul/autogen/Term/Type.hsig, nothing )
[2 of 3] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul/build/initial-bp-mul/autogen/Mul/Type.hsig, nothing )
Preprocessing library 'initial-bp-base-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-eval' instantiated with
  Base.Type = <Base.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-mul-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul-eval' instantiated with
  Base.Type = <Base.Type>
  Mul.Type = <Mul.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-base-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-print' instantiated with
  Base.Type = <Base.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[3 of 3] Compiling Mul.Print        ( initial-bp-mul-print/Mul/Print.hs, nothing )
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/build/initial-bp-base-eval/autogen/Term/Type.hsig, nothing )
[3 of 3] Compiling Mul              ( initial-bp-mul/Mul.hs, nothing )
[1 of 4] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/build/initial-bp-mul-eval/autogen/Term/Type.hsig, nothing )
[2 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/build/initial-bp-base-eval/autogen/Base/Type.hsig, nothing )
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/build/initial-bp-base-print/autogen/Term/Type.hsig, nothing )
Preprocessing library 'initial-bp-base' for initial-bp-0.1.0.0..
Building library 'initial-bp-base' instantiated with
  Base.Type = <Base.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[2 of 4] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/build/initial-bp-mul-eval/autogen/Mul/Type.hsig, nothing )
[2 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/build/initial-bp-base-print/autogen/Base/Type.hsig, nothing )
Configuring library 'final-bp-example-mul' for final-bp-0.1.0.0..
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base/build/initial-bp-base/autogen/Term/Type.hsig, nothing )
[2 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base/build/initial-bp-base/autogen/Base/Type.hsig, nothing )
[3 of 3] Compiling Base.Eval        ( initial-bp-base-eval/Base/Eval.hs, nothing )
Configuring library 'final-bp-example-base' instantiated with
  Base = final-bp-0.1.0.0-inplace-final-bp-base-print:Base
  Repr = final-bp-0.1.0.0-inplace-final-bp-print:Repr
for final-bp-0.1.0.0..
[3 of 4] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/build/initial-bp-mul-eval/autogen/Base/Type.hsig, nothing )
[3 of 3] Compiling Base.Print       ( initial-bp-base-print/Base/Print.hs, nothing )
[4 of 4] Compiling Mul.Eval         ( initial-bp-mul-eval/Mul/Eval.hs, nothing )
Configuring library 'final-bp-example-base' instantiated with
  Base = final-bp-0.1.0.0-inplace-final-bp-base-eval:Base
  Repr = final-bp-0.1.0.0-inplace-final-bp-eval:Repr
for final-bp-0.1.0.0..
Configuring library 'initial-bp-mul-print' instantiated with
  Mul.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
[3 of 3] Compiling Base             ( initial-bp-base/Base.hs, nothing )
Configuring library for final-bp-0.1.0.0..
Configuring library 'initial-bp-base-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type
for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
Configuring library 'initial-bp-base-print' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type
for initial-bp-0.1.0.0..
Preprocessing library 'final-bp-example-mul' for final-bp-0.1.0.0..
Building library 'final-bp-example-mul' instantiated with
  Base = <Base>
  Mul = <Mul>
  Repr = <Repr>
for final-bp-0.1.0.0..
Preprocessing library 'final-bp-example-base' for final-bp-0.1.0.0..
Building library 'final-bp-example-base' instantiated with
  Base = final-bp-0.1.0.0-inplace-final-bp-base-print:Base
  Repr = final-bp-0.1.0.0-inplace-final-bp-print:Repr
for final-bp-0.1.0.0..
[1 of 4] Compiling Repr[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/build/final-bp-example-mul/autogen/Repr.hsig, nothing )
[1 of 3] Compiling Base[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8/build/final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8/autogen/Base.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8/build/final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8/Base.o )
Preprocessing library 'final-bp-example-base' for final-bp-0.1.0.0..
Building library 'final-bp-example-base' instantiated with
  Base = final-bp-0.1.0.0-inplace-final-bp-base-eval:Base
  Repr = final-bp-0.1.0.0-inplace-final-bp-eval:Repr
for final-bp-0.1.0.0..
[2 of 4] Compiling Mul[sig]         ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/build/final-bp-example-mul/autogen/Mul.hsig, nothing )
[3 of 4] Compiling Base[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/build/final-bp-example-mul/autogen/Base.hsig, nothing )
[4 of 4] Compiling Example.Mul      ( final-bp-example-mul/Example/Mul.hs, nothing )
Preprocessing library 'initial-bp-mul-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul-print' instantiated with
  Mul.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
[2 of 3] Compiling Repr[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8/build/final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8/autogen/Repr.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8/build/final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8/Repr.o )
[1 of 3] Compiling Base[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c/build/final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c/autogen/Base.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c/build/final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c/Base.o )
[3 of 3] Compiling Example.Base     ( final-bp-example-base/Example/Base.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8/build/final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8/Example/Base.o )
Preprocessing library for final-bp-0.1.0.0..
Building library for final-bp-0.1.0.0..

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 70, types: 57, coercions: 0, joins: 0/0}

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
term8 :: [Char]
term8
  = case $wshowSignedInt 0# 2# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) add1
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
term7 :: [Char]
term7 = unpackAppendCString# add3 term8

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
term6 :: [Char]
term6
  = case $wshowSignedInt 0# 1# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) term7
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
term5 :: [Char]
term5 = unpackAppendCString# add4 term6

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
term4 :: [Char]
term4 = ++ term5 add1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
term3 :: [Char]
term3 = unpackAppendCString# add3 term4

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
term2 :: [Char]
term2
  = case $wshowSignedInt 0# 8# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) term3
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
term1 :: Repr
term1 = unpackAppendCString# add4 term2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "final-bp-0.1.0.0-inplace-final-bp-example-base+3MC5EwTupCy72A2xzHDwu8"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[1 of 3] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/autogen/Mul/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/Mul/Type.o )
[2 of 3] Compiling Repr[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c/build/final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c/autogen/Repr.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c/build/final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c/Repr.o )
Configuring library 'initial-bp-base-print' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-base-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type
for initial-bp-0.1.0.0..
[1 of 1] Compiling FinalBP.Bench    ( src/FinalBP/Bench.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/build/FinalBP/Bench.o )
[3 of 3] Compiling Example.Base     ( final-bp-example-base/Example/Base.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-base/final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c/build/final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c/Example/Base.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 17, types: 6, coercions: 0, joins: 0/0}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term1 :: Repr
term1 = I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "final-bp-0.1.0.0-inplace-final-bp-example-base+2XuPNKz0qU7KGxJd49xi0c"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 67, types: 24, coercions: 0, joins: 0/0}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lit2 :: Repr
lit2 = I# 2#

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
evalAddSmall :: Repr -> Repr
evalAddSmall = \ (tm :: Repr) -> $fNumInt_$c+ tm tm

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
evalAddMulSmall :: Repr -> Repr
evalAddMulSmall
  = \ (tm :: Repr) -> case tm of { I# x -> I# (+# (*# x 3#) 5#) }

-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
evalAddBig :: Repr -> Repr
evalAddBig
  = \ (tm :: Repr) ->
      case tm of { I# x -> I# (+# (+# x 3#) (+# x 5#)) }

-- RHS size: {terms: 20, types: 3, coercions: 0, joins: 0/0}
evalAddMulBig :: Repr -> Repr
evalAddMulBig
  = \ (tm :: Repr) ->
      case tm of { I# x ->
      I# (+# (*# (+# x 3#) (+# x 5#)) (*# (+# x 7#) (+# x 11#)))
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-bp-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "FinalBP.Bench"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Preprocessing library 'initial-bp-base-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
[1 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/autogen/Base/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/Base/Type.o )
Preprocessing library 'initial-bp-base-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-print' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base:Term.Type
for initial-bp-0.1.0.0..
[1 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/autogen/Base/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/Base/Type.o )
[2 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/Term/Type.o )
[1 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/autogen/Base/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/Base/Type.o )
[3 of 3] Compiling Mul.Print        ( initial-bp-mul-print/Mul/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-print/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY/Mul/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 60, types: 56, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules6 :: Addr#
printRules6 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules5 :: Addr#
printRules5 = " * "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules4 :: Addr#
printRules4 = ")"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
printRules3 :: [Char]
printRules3 = unpackCString# printRules4

-- RHS size: {terms: 29, types: 28, coercions: 0, joins: 0/0}
printRules2 :: (Term -> Maybe [Char]) -> Term -> Maybe [Char]
printRules2
  = \ (p :: Term -> Maybe [Char]) (tm :: Term) ->
      case tm of {
        __DEFAULT -> Nothing;
        Mul y1 y2 ->
          case p y1 of {
            Nothing -> Nothing;
            Just x ->
              case p y2 of {
                Nothing -> Nothing;
                Just x1 ->
                  Just
                    (unpackAppendCString#
                       printRules6
                       (++ x (unpackAppendCString# printRules5 (++ x1 printRules3))))
              }
          }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printRules1 :: PrintRule Term
printRules1 = PrintRule printRules2

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
printRules :: [PrintRule Term]
printRules = : printRules1 []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-mul-print+G7vqlwbi8qICy04tY6C9RY"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Configuring library 'initial-bp-mul-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Mul.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
[2 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/Term/Type.o )
[2 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/Term/Type.o )
[3 of 3] Compiling Base.Eval        ( initial-bp-base-eval/Base/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK/Base/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 51, types: 45, coercions: 6, joins: 0/0}

-- RHS size: {terms: 30, types: 21, coercions: 0, joins: 0/0}
addRule1
  :: forall r.
     (Term -> Term) -> (Term -> r) -> (Term -> r) -> Term -> r
addRule1
  = \ (@ r)
      (e :: Term -> Term)
      (good :: Term -> r)
      (bad :: Term -> r)
      (tm :: Term) ->
      case tm of wild {
        Lit ipv -> bad wild;
        Add y1 y2 ->
          case e y1 of {
            Lit y4 ->
              case e y2 of {
                Lit y5 -> good (Lit ($fNumInt_$c+ y4 y5));
                Add ipv ipv1 -> bad wild
              };
            Add ipv ipv1 -> bad wild
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
addRule :: EvalRule Term
addRule = addRule1 `cast` <Co:3>

-- RHS size: {terms: 3, types: 4, coercions: 3, joins: 0/0}
evalRules :: [EvalRule Term]
evalRules = : (addRule1 `cast` <Co:3>) []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-base-eval+CrWoJKfZaH70LMmcO19YK"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[3 of 3] Compiling Base.Eval        ( initial-bp-base-eval/Base/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-eval/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP/Base/Eval.o )
Configuring library 'initial-bp-example-base' for initial-bp-0.1.0.0..

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 51, types: 40, coercions: 6, joins: 0/0}

-- RHS size: {terms: 30, types: 16, coercions: 0, joins: 0/0}
addRule1
  :: forall r.
     (Term -> Term) -> (Term -> r) -> (Term -> r) -> Term -> r
addRule1
  = \ (@ r)
      (e :: Term -> Term)
      (good :: Term -> r)
      (bad :: Term -> r)
      (tm :: Term) ->
      case tm of wild {
        __DEFAULT -> bad wild;
        Add y1 y2 ->
          case e y1 of {
            __DEFAULT -> bad wild;
            Lit dt ->
              case e y2 of {
                __DEFAULT -> bad wild;
                Lit dt1 -> good (Lit (+# dt dt1))
              }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
addRule :: EvalRule Term
addRule = addRule1 `cast` <Co:3>

-- RHS size: {terms: 3, types: 4, coercions: 3, joins: 0/0}
evalRules :: [EvalRule Term]
evalRules = : (addRule1 `cast` <Co:3>) []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-base-eval+5x0SUPDSVDaA4gvRrnNuSP"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[2 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/Term/Type.o )
Configuring library 'final-bp-example-mul' instantiated with
  Base = final-bp-0.1.0.0-inplace-final-bp-base-print:Base
  Mul = final-bp-0.1.0.0-inplace-final-bp-mul-print:Mul
  Repr = final-bp-0.1.0.0-inplace-final-bp-print:Repr
for final-bp-0.1.0.0..
[3 of 3] Compiling Base.Print       ( initial-bp-base-print/Base/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK/Base/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 78, types: 81, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules7 :: Addr#
printRules7 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules6 :: Addr#
printRules6 = " + "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules5 :: Addr#
printRules5 = ")"#

-- RHS size: {terms: 10, types: 10, coercions: 0, joins: 0/0}
printRules9 :: (Term -> Maybe String) -> Term -> Maybe String
printRules9
  = \ _ (tm :: Term) ->
      case tm of {
        Lit y1 -> Just ($fShowInt_$cshow y1);
        Add ipv ipv1 -> Nothing
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printRules8 :: PrintRule Term
printRules8 = PrintRule printRules9

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
printRules4 :: [Char]
printRules4 = unpackCString# printRules5

-- RHS size: {terms: 29, types: 29, coercions: 0, joins: 0/0}
printRules3 :: (Term -> Maybe [Char]) -> Term -> Maybe [Char]
printRules3
  = \ (pr :: Term -> Maybe [Char]) (tm :: Term) ->
      case tm of {
        Lit ipv -> Nothing;
        Add y1 y2 ->
          case pr y1 of {
            Nothing -> Nothing;
            Just x ->
              case pr y2 of {
                Nothing -> Nothing;
                Just x1 ->
                  Just
                    (unpackAppendCString#
                       printRules7
                       (++ x (unpackAppendCString# printRules6 (++ x1 printRules4))))
              }
          }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printRules2 :: PrintRule Term
printRules2 = PrintRule printRules3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
printRules1 :: [PrintRule Term]
printRules1 = : printRules2 []

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
printRules :: [PrintRule Term]
printRules = : printRules8 printRules1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-base-print+CrWoJKfZaH70LMmcO19YK"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Configuring library 'final-bp-example-mul' instantiated with
  Base = final-bp-0.1.0.0-inplace-final-bp-base-eval:Base
  Mul = final-bp-0.1.0.0-inplace-final-bp-mul-eval:Mul
  Repr = final-bp-0.1.0.0-inplace-final-bp-eval:Repr
for final-bp-0.1.0.0..
Configuring library 'initial-bp-example-term-base-eval' for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-base-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-base-print' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
[1 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/autogen/Base/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/Base/Type.o )
Configuring library 'initial-bp-example-term-base-print' for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-mul-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-mul-eval' instantiated with
  Base.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Base.Type
  Mul.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Mul.Type
  Term.Type = initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul:Term.Type
for initial-bp-0.1.0.0..
[2 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/Term/Type.o )
[3 of 3] Compiling Base.Print       ( initial-bp-base-print/Base/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-base-print/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/build/initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP/Base/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 85, types: 89, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules7 :: Addr#
printRules7 = "("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules6 :: Addr#
printRules6 = " + "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
printRules5 :: Addr#
printRules5 = ")"#

-- RHS size: {terms: 17, types: 19, coercions: 0, joins: 0/0}
printRules9 :: (Term -> Maybe String) -> Term -> Maybe String
printRules9
  = \ _ (tm :: Term) ->
      case tm of {
        __DEFAULT -> Nothing;
        Lit dt ->
          Just
            (case $wshowSignedInt 0# dt [] of { (# ww5, ww6 #) -> : ww5 ww6 })
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printRules8 :: PrintRule Term
printRules8 = PrintRule printRules9

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
printRules4 :: [Char]
printRules4 = unpackCString# printRules5

-- RHS size: {terms: 29, types: 28, coercions: 0, joins: 0/0}
printRules3 :: (Term -> Maybe [Char]) -> Term -> Maybe [Char]
printRules3
  = \ (pr :: Term -> Maybe [Char]) (tm :: Term) ->
      case tm of {
        __DEFAULT -> Nothing;
        Add y1 y2 ->
          case pr y1 of {
            Nothing -> Nothing;
            Just x ->
              case pr y2 of {
                Nothing -> Nothing;
                Just x1 ->
                  Just
                    (unpackAppendCString#
                       printRules7
                       (++ x (unpackAppendCString# printRules6 (++ x1 printRules4))))
              }
          }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printRules2 :: PrintRule Term
printRules2 = PrintRule printRules3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
printRules1 :: [PrintRule Term]
printRules1 = : printRules2 []

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
printRules :: [PrintRule Term]
printRules = : printRules8 printRules1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-base-print+5x0SUPDSVDaA4gvRrnNuSP"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Base.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Preprocessing library 'initial-bp-example-base' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-base' instantiated with
  Base.Type = <Base.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[1 of 4] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/autogen/Base/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/Base/Type.o )
Preprocessing library 'final-bp-example-mul' for final-bp-0.1.0.0..
Building library 'final-bp-example-mul' instantiated with
  Base = final-bp-0.1.0.0-inplace-final-bp-base-print:Base
  Mul = final-bp-0.1.0.0-inplace-final-bp-mul-print:Mul
  Repr = final-bp-0.1.0.0-inplace-final-bp-print:Repr
for final-bp-0.1.0.0..
[1 of 3] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-base/build/initial-bp-example-base/autogen/Term/Type.hsig, nothing )
[2 of 3] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-base/build/initial-bp-example-base/autogen/Base/Type.hsig, nothing )
[1 of 4] Compiling Base[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/autogen/Base.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/Base.o )
[2 of 4] Compiling Mul[sig]         ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/autogen/Mul.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/Mul.o )
[3 of 4] Compiling Repr[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/autogen/Repr.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/Repr.o )
[3 of 3] Compiling Example.Base     ( initial-bp-example-base/Example/Base.hs, nothing )
[2 of 4] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/autogen/Mul/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/Mul/Type.o )
[4 of 4] Compiling Example.Mul      ( final-bp-example-mul/Example/Mul.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8/Example/Mul.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 84, types: 70, coercions: 0, joins: 0/0}

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
term10 :: [Char]
term10
  = case $wshowSignedInt 0# 2# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) mul1
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
term9 :: [Char]
term9 = unpackAppendCString# mul3 term10

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
term8 :: [Char]
term8
  = case $wshowSignedInt 0# 1# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) term9
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
term7 :: [Char]
term7 = unpackAppendCString# mul4 term8

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
term6 :: [Char]
term6 = ++ term7 add1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
term5 :: [Char]
term5 = unpackAppendCString# add3 term6

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
term1 :: [Char]
term1
  = case $wshowSignedInt 0# 7# [] of { (# ww5, ww6 #) ->
    ++ (: ww5 ww6) term5
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
term2 :: Repr
term2 = unpackAppendCString# add4 term1

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/0}
term11 :: String
term11
  = case $wshowSignedInt 0# 7# [] of { (# ww5, ww6 #) -> : ww5 ww6 }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
term3 :: Repr
term3 = mul term11 term1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "final-bp-0.1.0.0-inplace-final-bp-example-mul+3kBcPTnbVUlDbio0wW7eL8"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[3 of 4] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/autogen/Term/Type.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/Term/Type.o )
[4 of 4] Compiling Mul.Eval         ( initial-bp-mul-eval/Mul/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-mul-eval/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/build/initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh/Mul/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 51, types: 40, coercions: 6, joins: 0/0}

-- RHS size: {terms: 30, types: 16, coercions: 0, joins: 0/0}
evalRules1
  :: forall r.
     (Term -> Term) -> (Term -> r) -> (Term -> r) -> Term -> r
evalRules1
  = \ (@ r)
      (e :: Term -> Term)
      (good :: Term -> r)
      (bad :: Term -> r)
      (tm :: Term) ->
      case tm of wild {
        __DEFAULT -> bad wild;
        Mul y1 y2 ->
          case e y1 of {
            __DEFAULT -> bad wild;
            Lit dt ->
              case e y2 of {
                __DEFAULT -> bad wild;
                Lit dt1 -> good (Lit (*# dt dt1))
              }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
mulRule :: EvalRule Term
mulRule = evalRules1 `cast` <Co:3>

-- RHS size: {terms: 3, types: 4, coercions: 3, joins: 0/0}
evalRules :: [EvalRule Term]
evalRules = : (evalRules1 `cast` <Co:3>) []

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-mul-eval+DN6a746NDooFN5IuVw0eQh"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Mul.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Preprocessing library 'final-bp-example-mul' for final-bp-0.1.0.0..
Building library 'final-bp-example-mul' instantiated with
  Base = final-bp-0.1.0.0-inplace-final-bp-base-eval:Base
  Mul = final-bp-0.1.0.0-inplace-final-bp-mul-eval:Mul
  Repr = final-bp-0.1.0.0-inplace-final-bp-eval:Repr
for final-bp-0.1.0.0..
Configuring library 'initial-bp-example-mul' for initial-bp-0.1.0.0..
[1 of 4] Compiling Base[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/autogen/Base.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/Base.o )
Preprocessing library 'initial-bp-example-term-base-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base-eval' for initial-bp-0.1.0.0..
Configuring library 'initial-bp-example-term-base-mul-print' for initial-bp-0.1.0.0..
[2 of 4] Compiling Mul[sig]         ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/autogen/Mul.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/Mul.o )
[1 of 1] Compiling Term.Eval        ( initial-bp-example-term-base-eval/Term/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-eval/build/initial-bp-example-term-base-eval/Term/Eval.o )
[3 of 4] Compiling Repr[sig]        ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/autogen/Repr.hsig, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/Repr.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 38, types: 20, coercions: 0, joins: 0/0}

Rec {
-- RHS size: {terms: 23, types: 13, coercions: 0, joins: 0/0}
evalTerm :: Term -> Term
evalTerm
  = \ (tm1 :: Term) ->
      case tm1 of wild {
        Lit ipv -> wild;
        Add y1 y2 ->
          case evalTerm y1 of {
            Lit y4 ->
              case evalTerm y2 of {
                Lit y5 -> evalTerm (Lit ($fNumInt_$c+ y4 y5));
                Add ipv ipv1 -> wild
              };
            Add ipv ipv1 -> wild
          }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[4 of 4] Compiling Example.Mul      ( final-bp-example-mul/Example/Mul.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-mul/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/build/final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY/Example/Mul.o )
Preprocessing library 'initial-bp-example-term-base-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base-print' for initial-bp-0.1.0.0..

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 20, types: 7, coercions: 0, joins: 0/0}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term2 :: Repr
term2 = I# 9#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
term3 :: Repr
term3 = I# 77#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "final-bp-0.1.0.0-inplace-final-bp-example-mul+LMCbfyEXrwD5Vje3yxLfLY"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Mul"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Configuring library 'final-bp-example-print' for final-bp-0.1.0.0..
[1 of 1] Compiling Term.Print       ( initial-bp-example-term-base-print/Term/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-print/build/initial-bp-example-term-base-print/Term/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 17, types: 9, coercions: 0, joins: 0/0}

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printTerm :: Term -> Maybe String
printTerm = mkPrint printRules

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Configuring library 'initial-bp-example-term-base-mul-eval' for initial-bp-0.1.0.0..
Configuring library for initial-bp-0.1.0.0..
Configuring library 'final-bp-example-eval' for final-bp-0.1.0.0..
Preprocessing library 'initial-bp-example-mul' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-mul' instantiated with
  Base.Type = <Base.Type>
  Mul.Type = <Mul.Type>
  Term.Type = <Term.Type>
for initial-bp-0.1.0.0..
[1 of 4] Compiling Term.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-mul/build/initial-bp-example-mul/autogen/Term/Type.hsig, nothing )
[2 of 4] Compiling Mul.Type[sig]    ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-mul/build/initial-bp-example-mul/autogen/Mul/Type.hsig, nothing )
Preprocessing library 'initial-bp-example-term-base-mul-print' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base-mul-print' for initial-bp-0.1.0.0..
[1 of 1] Compiling Term.Print       ( initial-bp-example-term-base-mul-print/Term/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-mul-print/build/initial-bp-example-term-base-mul-print/Term/Print.o )
Preprocessing library 'final-bp-example-print' for final-bp-0.1.0.0..
Building library 'final-bp-example-print' for final-bp-0.1.0.0..
[3 of 4] Compiling Base.Type[sig]   ( /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-mul/build/initial-bp-example-mul/autogen/Base/Type.hsig, nothing )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 21, types: 14, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
printTerm1 :: [PrintRule Term]
printTerm1 = ++ printRules printRules

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
printTerm :: Term -> Maybe String
printTerm = mkPrint printTerm1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul-print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



[4 of 4] Compiling Example.Mul      ( initial-bp-example-mul/Example/Mul.hs, nothing )
[1 of 1] Compiling Example.Print    ( final-bp-example-print/Example/Print.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-print/build/final-bp-example-print/Example/Print.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-bp-0.1.0.0-inplace-final-bp-example-print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Print"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Preprocessing library for initial-bp-0.1.0.0..
Building library for initial-bp-0.1.0.0..
Preprocessing library 'initial-bp-example-term-base-mul-eval' for initial-bp-0.1.0.0..
Building library 'initial-bp-example-term-base-mul-eval' for initial-bp-0.1.0.0..
[1 of 1] Compiling InitialBP.Bench  ( src/InitialBP/Bench.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/build/InitialBP/Bench.o )
[1 of 1] Compiling Term.Eval        ( initial-bp-example-term-base-mul-eval/Term/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-bp-0.1.0.0/c/initial-bp-example-term-base-mul-eval/build/initial-bp-example-term-base-mul-eval/Term/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 126, types: 58, coercions: 0, joins: 0/0}

Rec {
-- RHS size: {terms: 41, types: 15, coercions: 0, joins: 0/0}
evalTerm :: Term -> Term
evalTerm
  = \ (tm1 :: Term) ->
      case tm1 of wild {
        Lit ipv -> wild;
        Add y1 y2 ->
          case evalTerm y1 of {
            __DEFAULT -> wild;
            Lit dt ->
              case evalTerm y2 of {
                __DEFAULT -> wild;
                Lit dt1 -> evalTerm (Lit (+# dt dt1))
              }
          };
        Mul y1 y2 ->
          case evalTerm y1 of {
            __DEFAULT -> wild;
            Lit dt ->
              case evalTerm y2 of {
                __DEFAULT -> wild;
                Lit dt1 -> evalTerm (Lit (*# dt dt1))
              }
          }
      }
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lit2 :: Term
lit2 = Lit 2#

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
evalAddSmall :: (Term -> Term) -> Term -> Term
evalAddSmall
  = \ (eval :: Term -> Term) (tm :: Term) -> eval ($WAdd tm tm)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddBig2 :: Term
evalAddBig2 = Lit 3#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddBig1 :: Term
evalAddBig1 = Lit 5#

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
evalAddMulSmall :: (Term -> Term) -> Term -> Term
evalAddMulSmall
  = \ (eval :: Term -> Term) (tm :: Term) ->
      eval
        (case tm of dt { __DEFAULT ->
         Add (Mul dt evalAddBig2) evalAddBig1
         })

-- RHS size: {terms: 13, types: 4, coercions: 0, joins: 0/0}
evalAddBig :: (Term -> Term) -> Term -> Term
evalAddBig
  = \ (eval :: Term -> Term) (tm :: Term) ->
      eval
        (case tm of dt { __DEFAULT ->
         Add (Add dt evalAddBig2) (Add dt evalAddBig1)
         })

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddMulBig2 :: Term
evalAddMulBig2 = Lit 7#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
evalAddMulBig1 :: Term
evalAddMulBig1 = Lit 11#

-- RHS size: {terms: 21, types: 4, coercions: 0, joins: 0/0}
evalAddMulBig :: (Term -> Term) -> Term -> Term
evalAddMulBig
  = \ (eval :: Term -> Term) (tm :: Term) ->
      eval
        (case tm of dt { __DEFAULT ->
         Add
           (Mul (Add dt evalAddBig2) (Add dt evalAddBig1))
           (Mul (Add dt evalAddMulBig2) (Add dt evalAddMulBig1))
         })

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "initial-bp-0.1.0.0-inplace"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "InitialBP.Bench"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 56, types: 22, coercions: 0, joins: 0/0}

Rec {
-- RHS size: {terms: 41, types: 15, coercions: 0, joins: 0/0}
evalTerm :: Term -> Term
evalTerm
  = \ (tm1 :: Term) ->
      case tm1 of wild {
        Lit ipv -> wild;
        Add y1 y2 ->
          case evalTerm y1 of {
            __DEFAULT -> wild;
            Lit dt ->
              case evalTerm y2 of {
                __DEFAULT -> wild;
                Lit dt1 -> evalTerm (Lit (+# dt dt1))
              }
          };
        Mul y1 y2 ->
          case evalTerm y1 of {
            __DEFAULT -> wild;
            Lit dt ->
              case evalTerm y2 of {
                __DEFAULT -> wild;
                Lit dt1 -> evalTerm (Lit (*# dt dt1))
              }
          }
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4
  = "initial-bp-0.1.0.0-inplace-initial-bp-example-term-base-mul-eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Term.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Preprocessing library 'final-bp-example-eval' for final-bp-0.1.0.0..
Building library 'final-bp-example-eval' for final-bp-0.1.0.0..
[1 of 1] Compiling Example.Eval     ( final-bp-example-eval/Example/Eval.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/final-bp-0.1.0.0/c/final-bp-example-eval/build/final-bp-example-eval/Example/Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 14, types: 5, coercions: 0, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "final-bp-0.1.0.0-inplace-final-bp-example-eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Example.Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1



Configuring executable 'bench' for initial-final-bench-0.1.0.0..
Preprocessing executable 'bench' for initial-final-bench-0.1.0.0..
Building executable 'bench' for initial-final-bench-0.1.0.0..
[1 of 1] Compiling Main             ( Main.hs, /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-final-bench-0.1.0.0/c/bench/build/bench/bench-tmp/Main.o )
Linking /home/dave/work/github.com/dalaing/initial-final/dist-newstyle/build/x86_64-linux/ghc-8.2.2/initial-final-bench-0.1.0.0/c/bench/build/bench/bench ...
